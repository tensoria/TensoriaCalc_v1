(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* ============================================== *)
(*            Copyright Yi-Zen Chu.               *)
(* ============================================== *)
(* One main goal of this software is the          *)
(* computation of Christoffel symbols, Riemann,   *)
(* Ricci tensor and scalar, etc. given a specific *)
(* metric. We are working within a Riemannian     *)
(* geometry frameowork. Explicit tensorial        *)
(* calculations will increasingly be supported.   *)
(* ============================================== *)
(* Please feel free to use and/or modify this     *)
(* code for the purposes of scientific research.  *)
(* Please cite the URL below in your publications *)
(* if you do use this code for your research.     *)
(* If you want to make money off this, write to   *)
(* me first at yizen[dot]chu[at]gmail[dot]com.    *)
(* Feel free to send comments to the same e-mail. *)
(* This software, a user's guide, and future      *)
(* updates/revisions should be available at       *)
(* http://www.stargazing.net/yizen/Tensoria.html  *)
(* ============================================== *)
(* While developing this code, I have taken       *)
(* inspiration from the following three software: *)
(* FeynCalc @ http://www.feyncalc.org/            *)
(* grt @ http://www.vaudrevange.com/pascal/grt/   *)
(* xAct @ http://www.xact.es/                     *)
(* ============================================== *)
(* Please refer to the TensoriaCalc.nb file for   *)
(* the definitions of the geometric objects       *)
(* computed by this package. (It is difficult to  *)
(* type the definitions in text.)                 *)


(* ::Input::Initialization:: *)
BeginPackage["TensoriaCalc`"];
(* Upper indices are denoted by, e.g. \[Mu]^-. Lower indices are denoted by, e.g. Subscript[\[Mu], -] *)
(* This notation is the same as Pascal's gtr *)


(* ::Input::Initialization:: *)
(* Usage allows us to say which functions will be `public' *)
Tensor::usage="Tensor is the generic Head of all tensorial objects.";
TensorType::usage="TensorType specifies the type of Tensor.";
TensorName::usage="TensorName specifies the name of Tensor.";
Indices::usage="(I) Indices \[Rule] {\[Mu],\[Nu],...} is one of the arguments of Tensor. It defines the indices of the Tensor. An upper index carries a superscript '-' and a lower index a subscript '-'. For example \!\(\*SuperscriptBox[\(\[Alpha]\), \(-\)]\) (also equivalent to SuperMinus[\[Alpha]]) is an upper index and \!\(\*SubscriptBox[\(\[Alpha]\), \(-\)]\) (also equivalent to SubMinus[\[Alpha]]) is a lower index. (II) Indices[M_Tensor] takes in a Tensor and returns a List of the indices used.";
(*NewCode: public declaration for Metric*)
(*The message haven't be expanded.*)
Metric::usage="(\!\(\*
StyleBox[\"I\",\nFontColor->RGBColor[0, 0, 1]]\)) Metric[\[Mu],\[Nu],M,CoordinateSystem\[Rule]coords_List,TensorName\[Rule]name,StartIndex\[Rule]i,ChristoffelOperator\[Rule]op,RiemannOperator\[Rule]op,RicciOperator\[Rule]op,RicciScalarOperator\[Rule]op] returns a Tensor object representing a metric M with indices \[Mu] and \[Nu] (either both upper, i.e., \!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\) and \!\(\*SuperscriptBox[\(\[Nu]\), \(-\)]\), or both lower, i.e. \!\(\*SubscriptBox[\(\[Mu]\), \(-\)]\) and \!\(\*SubscriptBox[\(\[Nu]\), \(-\)]\); the coordinates are specified through the List coords. The name of the metric is name, and the metric M itself can either be given as a square matrix or an expression quadratic in differentials of the coordinates (e.g. (\[DifferentialD]x\!\(\*SuperscriptBox[\()\), \(2\)]\)+(\[DifferentialD]y\!\(\*SuperscriptBox[\()\), \(2\)]\)). StartIndex i tells TensoriaCalc when to begin counting indices; for example spacetime indices usually start at 0 while spatial indices usually start at 1. The ChristoffelOperator, RiemannOperator, etc. specify operators that will be applied to the components of the Christoffel symbols, Riemann tensor, etc. (Note: TensorName, StartIndex, ChristoffelOperator, RiemannOperator, RicciOperator, RicciScalarOperator are optional; the defaults are name = \!\(\*
StyleBox[\"g\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\) i = 0 and op = FullSimplify.) (\!\(\*
StyleBox[\"II\",\nFontColor->RGBColor[0, 0, 1]]\)) Metric[\[Mu], \[Nu], \[Tau]_Tensor] takes in \[Tau], an object with Head Tensor, of TensorType Metric, and returns the same Tensor object with TensorComponents representing the metric (if \[Mu],\[Nu] are both SuperMinus), the inverse metric (if \[Mu],\[Nu] are both SubMinus), or the identity matrix (if one index is SubMinus and one is SuperMinus).";
NonMetricTensor::usage="(\!\(\*
StyleBox[\"I\",\nFontColor->RGBColor[0, 0, 1]]\)) NonMetricTensor[\[Mu]_List,stuff_List,exp_,CoordinateSystem\[Rule]coords_List,TensorType\[Rule]Null,TooltipDisplay\[Rule]Null,
	StartIndex\[Rule]0] returns a Tensor with indices \[Mu], components (entered as a Table) stuff, TensorName \[Rule] exp, coordinates coords, etc. TensorName, TensorType, TooltipDisplay, and StartIndex are Optional arguments, with default values as shown. (\!\(\*
StyleBox[\"II\",\nFontColor->RGBColor[0, 0, 1]]\)) NonMetricTensor[{},stuff,exp_,CoordinateSystem\[Rule]coords_List,TensorType\[Rule]Null,TooltipDisplay\[Rule]Null,
	StartIndex\[Rule]0] returns a Tensor containing a scalar field with no indices {}. Its explicit expression is \!\(\*
StyleBox[\"stuff\",\nFontSlant->\"Italic\"]\); its TensorName is \!\(\*
StyleBox[\"exp\",\nFontSlant->\"Italic\"]\); and coordinates coords, etc. TensorName, TensorType, TooltipDisplay, and StartIndex are Optional arguments, with default values as shown.";
Riemann::usage="Riemann[\[Mu],\[Nu],\[Alpha],\[Beta],MetricT] takes in the metric MetricT and returns a Tensor containing the components of the Riemann curvature tensor, if indices are Symbols. If indices are Integers or if indices are the coordinates, the specified component will be returned.";
Ricci::usage="Ricci[\[Nu],\[Beta],MetricT_Tensor] takes in the Tensor MetricT and returns a Tensor containing the components of the Ricci curvature tensor, if indices are Symbols. If indices are Integers or if indices are the coordinates, the specified component will be returned.";
RicciScalar::usage="RicciScalar[MetricT] takes in the Tensor MetricT and returns the Ricci scalar.";
Einstein::usage="Einstein[\[Nu],\[Beta],MetricT_Tensor,EinsteinOperator\[Rule]op] takes in the Tensor MetricT and returns a Tensor containing (the operation op applied to) the components of the Einstein tensor, where Einstein-Tensor = Ricci-Tensor - (Metric-Tensor/2) Ricci-Scalar \[LongDash] if indices are Symbols. If indices are Integers or if indices are the coordinates, the specified component will be returned. (EinsteinOperator is optional; if left unspecified, the default is op = FullSimplify.)";
LeviCivita::usage="LeviCivita[\[Nu]1,\[Nu]2,...,\[Nu]d,MetricT_Tensor] takes in the Tensor MetricT (in \!\(\*
StyleBox[\"d\",\nFontSlant->\"Italic\"]\) dimensions) and return a Tensor that yields the generally covariant Levi-Civita volume form, with indices \[Nu]1 through \[Nu]d. Note that Mathematica has an in-built LeviCivitaTensor, but it is really our LeviCivita here implemented for flat (Euclidean) space.";
CovariantHodgeDual::usage="CovariantHodgeDual[\[Nu]I__,\[Tau]_Tensor,m_Tensor] returns the generally covariant Hodge dual of the Tensor \[Tau] using the Metric Tensor m. Note that Mathematica has an in-built HodgeDual, but it is really the Hodge dual (aka Hodge star operator) in flat (Euclidean) space. Now, the Hodge dual (aka Hodge star operation), in \!\(\*FormBox[\(d\),
TraditionalForm]\) space(time) dimensions, of a fully antisymmetric tensor \!\(\*FormBox[SubscriptBox[\(A\), \(\(\*SubscriptBox[\(\[Mu]\), \(1\)] ... \) \*SubscriptBox[\(\[Mu]\), \(n\)]\)],
TraditionalForm]\) (where \!\(\*FormBox[\(n\\\  \[LessEqual] \\\ d\),
TraditionalForm]\)), is defined as, for e.g., \[FivePointedStar]\!\(\*FormBox[SubscriptBox[\(A\), \(\(\*SubscriptBox[\(\[Mu]\), \(1\)] ... \) \*SubscriptBox[\(\[Mu]\), \(d - n\)]\)],
TraditionalForm]\)\[Congruent]\!\(\*FormBox[\((1/\(n!\))\),
TraditionalForm]\)\!\(\*FormBox[SubscriptBox[OverscriptBox[\(\[Epsilon]\), \(~\)], \(\(\(\*SubscriptBox[\(\[Mu]\), \(1\)] ... \) \*SubscriptBox[\(\[Mu]\), \(d - n\)] \*SubscriptBox[\(\[Nu]\), \(1\)] ... \) \*SubscriptBox[\(\[Nu]\), \(n\)]\)],
TraditionalForm]\)\!\(\*FormBox[SuperscriptBox[\(A\), \(\(\*SubscriptBox[\(\[Nu]\), \(1\)] ... \) \*SubscriptBox[\(\[Nu]\), \(n\)]\)],
TraditionalForm]\). Note: CovariantHodgeDual does check whether the Tensor \[Tau] is fully antisymmetric.";
EinsteinOperator::usage="EinsteinOperator->op is an Option when using the TensoriaCalc function Einstein. It tells TensoriaCalc to apply op to the components of the Einstein tensor. The default op = FullSimplify.";
Weyl::usage="Weyl[\[Mu],\[Nu],\[Alpha],\[Beta],MetricT_Tensor] takes in the metric MetricT and returns a Tensor containing the components of the Weyl curvature tensor, if indices are Symbols. If indices are Integers or if indices are the coordinates, the specified component will be returned.";
WeylOperator::usage="WeylOperator->op is an Option when using the TensoriaCalc function Weyl. It tells TensoriaCalc to apply op to the components of the Weyl curvature tensor. The default op = FullSimplify.";
CoordinateSystem::usage="CoordinateSystem defines the variables used in a given coordinate system. For example CoordinateSystem \[Rule] {t,x,y,z}.";
Coordinates::usage="Coordinates[M_Tensor] takes in a Tensor of type Metric and returns a List of the coordinates used.";
TensorComponents::usage="(I) TensorComponents \[Rule] tt is one of the arguments of Tensor. It defines the components for a given Tensor through tt. (II) TensorComponents[m_Tensor] takes in a Tensor object m and returns its TensorComponents";
MetricDeterminant::usage="MetricDeterminant is an Option within a Tensor of type Metric whose OptionValue is the determinant of the metric in use.";
Determinant::usage="Determinant[MetricT] takes in a Tensor of type Metric and returns the determinant of the metric."
RiemannComponents::usage="RiemannComponents refer to the components of the Riemann curvature tensor.";
RicciComponents::usage="RicciComponents refer to the components of the Ricci curvature tensor.";
RicciScalarInvariant::usage="RicciScalarCurvature is the Option occuring within a Tensor of Metric type, whose OptionValue gives the rule referring to the Ricci scalar.";
ChristoffelComponents::usage="ChristoffelComponents refer to the components of the Christoffel symbols.";
StartIndex::usage="StartIndex is the Option occuring within Tensor that tells TensoriaCalc which Integer to start counting indices from. For example, spacetime indices usually have StartIndex \[Rule] 0 whereas purely spatial indices usually have StartIndex \[Rule] 1.";
Christoffel::usage="Christoffel[SuperMinus[\[Mu]_Integer],SubMinus[\[Alpha]_Integer],SubMinus[\[Beta]_Intger],M_Tensor] takes in the metric Tensor M (TensorType must be Metric) and returns a Tensor containing the components of the Christoffel symbol, if indices are Symbols. If indices are Integers or if indices are the coordinates, the specified component will be returned.";
TooltipDisplay::usage="TooltipDisplay is an Option occuring within a non-Metric type Tensor which tells TensoriaCalc what to display when the user hovers her mouse over the Tensor.";
(*NewCode: public declaration for TooltipStyle*)
TooltipStyle::usage="";
(*NewCode:public declaration for MetricOperator*)
MetricOperator::usage="";
ChristoffelOperator::usage="ChristoffelOperator \[Rule] Op is an Option when using Metric. It tells TensoriaCalc to apply Op when calculating the components of the Christoffel symbols, for example FullSimplify the resulting expression.";
RiemannOperator::usage="RiemannOperator \[Rule] Op is an Option when using Metric. It tells TensoriaCalc to apply Op when calculating the components of the Riemann curvature tensor, for example FullSimplify the resulting expression.";
RicciOperator::usage="RicciOperator \[Rule] Op is an Option when using Metric. It tells TensoriaCalc to apply Op when calculating the components of the Ricci curvature tensor, for example FullSimplify the resulting expression.";
RicciScalarOperator::usage="RicciScalarOperator \[Rule] Op is an Option when using Metric. It tells TensoriaCalc to apply Op when calculating the components of the Ricci scalar, for example FullSimplify the resulting expression.";
(*NewCode:public declaration for SymmetrizeIndicesOperator*)
SymmetrizeIndicesOperator::usage="";
(*NewCode:public declaration for AntiSymmetrizeIndicesOperator*)
AntiSymmetrizeIndicesOperator::usage="";
(*NewCode:public declaration for LieDerivativeOperator*)
LieDerivativeOperator::usage="";
(*NewCode: public declaration for CovariantBox*)
(*The message haven't be expanded.*)
CovariantBox::usage="CovariantBox[X,MetricT] applies the operator \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\)\!\(\*SubscriptBox[\(\[Del]\), \(\[Nu]\)]\) on X using the metric Tensor MetricT. Currently, only the scalar operator is supported, i.e. X cannot contain Tensor objects and CovariantBox[X,MetricT] \[Congruent] (|det g|\!\(\*SuperscriptBox[\()\), \(\(-1\)/2\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]\)((|det g|\!\(\*SuperscriptBox[\()\), \(1/2\)]\) \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) \!\(\*SubscriptBox[\(\[PartialD]\), \(\[Nu]\)]\)X).";
(*NewCode: public declaration for JacobianComponents*)
(*This piece is supposed to not inside the official version.*)
JacobianComponents::usage="Please ignore it's, it's only public in Wei-Hao version.";
(*NewCode: public declaration for CoordinateTransformation*)
(*The message haven't be expanded.*)
CoordinateTransformation::usage="(\!\(\*
StyleBox[\"I\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\".1\",\nFontColor->RGBColor[0, 0, 1]]\)) CoordinateTransformation[{x\[Rule]f1[x,y,z,...], y\[Rule]f2[x,y,z,...], z\[Rule]f3[x,y,z,...], ...}] returns the coordinate transformation and the associated Jacobian for the infinitesimals, i.e. the output is Union[{x\[Rule]f1[x,y,z,...], y\[Rule]f2[x,y,z,...], z\[Rule]f3[x,y,z,...], ...}, {dx\[Rule](\[PartialD]f1/\[PartialD]x)\[DifferentialD]x+(\[PartialD]f1/\[PartialD]y)\[DifferentialD]y+ ..., dy\[Rule](\[PartialD]f2/\[PartialD]x)\[DifferentialD]x+(\[PartialD]f2/\[PartialD]y)\[DifferentialD]y+...}]. 
	(\!\(\*
StyleBox[\"I\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\".2\",\nFontColor->RGBColor[0, 0, 1]]\)) CoordinateTransformation[{x\[Rule]f1[p,q,r,...], y\[Rule]f2[p,q,r,...], z\[Rule]f3[p,q,r,...], ...}, {p,q,r, ...}] returns the coordinate transformation and the associated Jacobian for the infinitesimals, i.e. the output is Union[{x\[Rule]f1[p,q,r,...], y\[Rule]f2[p,q,r,...], z\[Rule]f3[p,q,r,...], ...}, {dx\[Rule](\[PartialD]f1/\[PartialD]p)\[DifferentialD]p+(\[PartialD]f1/\[PartialD]q)\[DifferentialD]q+ ..., dy\[Rule](\[PartialD]f2/\[PartialD]p)\[DifferentialD]p+(\[PartialD]f2/\[PartialD]q)\[DifferentialD]q+...}]. The main difference between (I.1) and (I.2) is that (I.2) allows for new coordinate names on the right hand side of the rules; of course, that means one has to specify what the new coordinates are for (I.2). (\!\(\*
StyleBox[\"II\",\nFontColor->RGBColor[0, 0, 1]]\)) CoordinateTransformation[mt_Tensor,{x\[Rule]f1[x,y,z,...], y\[Rule]f2[x,y,z,...], z\[Rule]f3[x,y,z,...], ...}, CoordinateTransformationOperator\[Rule]op, StartIndex\[Rule]si] or CoordinateTransformation[mt_Tensor,{x\[Rule]f1[p,q,r,...], y\[Rule]f2[p,q,r,...], z\[Rule]f3[p,q,r,...], ...}, {p,q,r, ...}, CoordinateTransformationOperator\[Rule]op, StartIndex\[Rule]si], where mt is a Tensor of TensorType Metric, returns the same Tensor mt except coordinate-transformed according to the specified rules. Note that the index names and placement (i.e., down-down or up-up) are preserved. The CoordinateTransformationOperator\[Rule]op is an optional rule; with the default op = FullSimplify. StartIndex\[Rule]si is Optional; with default given by that in mt. Note: the new coordinates will be ordered according to the chronology specified in {p,q,r,...}.";
GradientSquared::usage="GradientSquared[X,MetricT] computes \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\)X \!\(\*SubscriptBox[\(\[Del]\), \(\[Nu]\)]\)X using the metric Tensor MetricT. Currently, only the scalar operator is supported, i.e. X cannot contain Tensor objects.";
(*NewCode: public declaration for PartialD*)
(*The message haven't be expanded.*)
PartialD::usage="PartialD[\!\(\*SubscriptBox[\(\[Mu]\), \(-\)]\),S_,MetricT_Tensor] or PartialD[\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\),S_,MetricT_Tensor] returns a Tensor object with TensorComponents \!\(\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]\)TensorComponent[S] or \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Nu]\)]\)TensorComponent[S] if S is a Tensor object, and \!\(\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]\)S or \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Nu]\)]\)S if S is simply an expression, using the metric \!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) of MetricT.";
(*NewCode: public declaration for SymmetrizeIndices*)
PartialDWeiHao::usage="WeiHao's version PartialD";
SymmetrizeIndices::usage="public";
(*NewCode: public declaration for AntiSymmetrizeIndices*)
AntiSymmetrizeIndices::usage="public";
CovariantD::usage="CovariantD[\!\(\*SubscriptBox[\(\[Mu]\), \(-\)]\),S_Tensor,MetricT_Tensor] (or CovariantD[\!\(\*SuperscriptBox[\(\[Mu]\), \(-\)]\),S_,MetricT_Tensor]) returns a Tensor object with TensorComponents containing the metric-compatible covariant derivative \!\(\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\) (or \!\(\*SuperscriptBox[\(\[Del]\), \(\[Mu]\)]\)) acting on S, using the metric MetricT.";
(*NewCode: public declaration for ExteriorD*)
ExteriorD::usage="public";
TensorsProduct::usage="TensorsProduct[Times[tt__Tensor]] \[LongDash] not to be confused with Mathematica's own TensorContract \[LongDash] returns a Tensor whose TensorComponents is built from contracting the sequence of Tensors in tt, i.e., by forming a tensor product out of their TensorComponents, and summing over repeated indices. All other attributes of the output Tensor are inherited from the first Tensor of the sequence in tt.";
SwapIndices::usage="SwapIndices[tt_Tensor,idx_List] returns the Tensor object tt, with its un-UnderBarred indices (say, \!\(\*SubscriptBox[\(i\), \(1\)]\)...\!\(\*SubscriptBox[\(i\), \(n\)]\)) re-arranged into idx; the TensorComponents of tt are re-arranged accordingly. When specifying idx, remember not to include the UnderBarred Indices of tt.";
TensorIsZero::usage="TensorIsZero[tt_Tensor] returns True if every component of the Tensor object tt is zero and False otherwise.";
MoveIndices::usage="(I) MoveIndices[tt_Tensor,idx_List,m_Tensor] returns the Tensor tt with its indices raised/lowered by specifying idx, using the Metric Tensor m. Suppose tt has indices {\!\(\*FormBox[SubscriptBox[\(\[Alpha]\), \(-\)],
TraditionalForm]\), \!\(\*FormBox[SuperscriptBox[\(\[Beta]\), \(-\)],
TraditionalForm]\) ,\!\(\*FormBox[SuperscriptBox[\(\[Mu]\), \(-\)],
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(\[Nu]\), \(-\)],
TraditionalForm]\)} and \[Alpha] and \[Mu] need to be raised and lowered respectively, then do MoveIndices[tt_Tensor,{\!\(\*FormBox[\(\*SuperscriptBox[\(\[Alpha]\), \(-\)], \*SubscriptBox[\(\[Mu]\), \(-\)]\),
TraditionalForm]\)},m]. (II) MoveIndices[tt_Tensor,m_Tensor] essentially returns the Tensor tt[\[Alpha],\[Beta],...] where the indices \[Alpha],\[Beta],... can be specified arbitrarily \[LongDash] either up or down. If the specified indices were not in the same up/down position as the input tt, the indices are automatically moved using the Metric Tensor m.";
RaiseAllIndices::usage="RaiseAllIndices[tt_Tensor,m_Tensor] returns the Tensor tt with all its indices raised using the Metric Tensor m.";
LowerAllIndices::usage="LowerAllIndices[tt_Tensor,m_Tensor] returns the Tensor tt with all its indices lowered using the Metric Tensor m.";
UniqueIndices::usage="UniqueIndices[tt_Tensor] returns the Tensor tt with its indices replaced with Unique ones.";
GeodesicSystem::usage="GeodesicSystem[MetricT_Tensor,AffineParameter\[Rule]\[Lambda],NonAffineParameter\[Rule]t] returns the affine parameter Lagrangian (1/2)\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)[z[\[Lambda]]](\!\(\*SuperscriptBox[\(dz\), \(\[Mu]\)]\)/d\[Lambda])(\!\(\*SuperscriptBox[\(dz\), \(\[Nu]\)]\)/d\[Lambda]) for geodesic motion, the non-affine parameter Lagrangian (\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)[z[t]](\!\(\*SuperscriptBox[\(dz\), \(\[Mu]\)]\)/dt)(\!\(\*SuperscriptBox[\(dz\), \(\[Nu]\)]\)/dt)\!\(\*SuperscriptBox[\()\), \(1/2\)]\) for geodesic motion, and the geodesic equations in both affine and non-affine parameter forms.";
GeodesicLagrangians::usage="GeodesicLagrangians[MetricT_Tensor,AffineParameter\[Rule]\[Lambda],NonAffineParameter\[Rule]t] returns the affine parameter Lagrangian (1/2)\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)[z[\[Lambda]]](\!\(\*SuperscriptBox[\(dz\), \(\[Mu]\)]\)/d\[Lambda])(\!\(\*SuperscriptBox[\(dz\), \(\[Nu]\)]\)/d\[Lambda]) for geodesic motion, and the non-affine parameter Lagrangian (\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)[z[t]](\!\(\*SuperscriptBox[\(dz\), \(\[Mu]\)]\)/dt)(\!\(\*SuperscriptBox[\(dz\), \(\[Nu]\)]\)/dt)\!\(\*SuperscriptBox[\()\), \(1/2\)]\) for geodesic motion. It does what GeodesicSystem does, but does not output the geodesic equations themselves.";
GeodesicHamiltonianDynamics::usage="GeodesicHamiltonianDynamics[MetricT_Tensor,{z1->p1,z2->p2,...},\[Lambda]] returns the affine parameter Hamiltonian (1/2)\!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)[z[\[Lambda]]]\!\(\*SubscriptBox[\(p\), \(\[Mu]\)]\)[\[Lambda]]\!\(\*SubscriptBox[\(p\), \(\[Nu]\)]\)[\[Lambda]] 
	and the geodesic equations {\!\(\*SuperscriptBox[\(dz\), \(\[Mu]\)]\)/d\[Lambda]==\!\(\*SuperscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(p\), \(\[Nu]\)]\),\!\(\*SubscriptBox[\(dp\), \(\[Mu]\)]\)=-\[PartialD]H/\[PartialD]\!\(\*SuperscriptBox[\(z\), \(\[Mu]\)]\)}.";
LieDerivative::usage="LieDerivative[\[Xi]_Tensor,m_Tensor] returns the Lie derivative of the Tensor m with respect to the rank-1 Tensor \[Xi]. Currently, LieDerivative only takes in Metric m; i.e., it only computes the Lie derivatives of metrics: \!\(\*SubscriptBox[\(\[Sterling]\), \(\[Xi]\)]\)\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) = \!\(\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]\)\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)+\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]\)\!\(\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)\!\(\*SubscriptBox[\(g\), \(\[Nu]\[Sigma]\)]\)+\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Nu]\)]\)\!\(\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Sigma]\)]\).";
(*NewCode: TensorEquations*)
TensorEquations::usage="";
(*NewCode: OrthonormalFrameField*)
OrthonormalFrameField::usage="";
InverseOrthonormalFrameField::usage="";
OrthonormalFrameFieldOperator::usage="";
FlatMetric::usage="";
TestOrthonormalFrameField::usage="";
OrthonormalFrameFieldIndices::usage="";
OrthonormalBasis::usage="";
CoordinateBasis::usage="";
(*NewCode: LieBracket*)
LieBracket::usage="";
LieBracketOperator::usage="";
(*NewCode: Derivative for Tensor*)
PD::usage="";
(*NewCode: PotentialForm*)
PotentialForm::usage="";
(*NewCode: ExpressionForm*)
ToExpressionForm::usage="";
(*NewCode: Operator Linearity*)
(*OperatorLinearity::usage="";*)
(*NewCode: Operator ProductRule*)
OperatorProductRule::usage="";
(*\[FivePointedStar]::usage="";*)
(*NewCode: SphericalHarmonicYTensor*)
SphericalHarmonicYTensor::usage="";
(*NewCode: VectorSphericalHarmonic*)
VectorSphericalHarmonic::usage="";
(*NewCode: TensorAssumption*)
TensorAssumption::usage="";
(*NewCode: TensorIsZeroOperator*)
TensorIsZeroOperator::usage="";
(*NewCode: TensorOperator*)
TensorOperator::usage="";
(*NewCode: TensorDivision*)
TensorDivision::usage="";
TensorDivisionOperator::usage="";
(*NewCode: TensorPlus*)
TensorPlus::usage="";
(*NewCode: TensorComponentsManipulation*)
TensorComponentsManipulation::usage="";
(*NewCode: InteriorProduct*)
InteriorProduct::usage="";
(*NewCode: WedgeProductExpand*)
WedgeProductExpand::usage="";
(*NewCode: ToTensorComponents*)
ToTensorComponents::usage="";
(*NewCode: New ContractTensors*)
ContractTensors::usage="";
(*NewCode: Publish Operators' Rules*)
OperatorDistributeOverPlus::usage="";
(*OperatorNullList::usage="";OperatorExpansion::usage="";OperatorFactorOutScalar::usage="";OperatorRemoveSingleComponentList::usage="";OperatorThreadThroughFunction::usage="";OperatorTensorReturnItself::usage="";OperatorExpressionFormReturnItself::usage="";OperatorTensorsProduct::usage="";OperatorContractThroughFunction::usage="";OutputBecomesOneTensor::usage="";OperatorThreadThroughTimes::usage="";*)


(* ::Input::Initialization:: *)
(* 4D Ideal MHD Functions *)
MHDSystem::usage="MHDSystem[{\[CapitalPhi]1_,\[CapitalPhi]2_,\[CapitalPhi]3_}, \[Rho]0_Function, m_Tensor, MetricSignature \[Rule] s_String, MHDOperator \[Rule] op] returns an object, with Head MHDSystem, that stores all relevant information described by the 3 scalar fields {\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi]3} and the plasma energy density (pure function) \[Rho]0. Note that MetricSignature and MHDOperator are optional; s = `Mostly minus' tells TensoriaCalc the user employs \!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu]\[Nu]\)]\) = diag[1,-1,...,-1] and s = `Mostly plus' tells TensoriaCalc the user employs \!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu]\[Nu]\)]\) = diag[-1,+1,...,+1]; the default values are s = `Mostly minus' and op = Simplify.";
MHDScalar::usage="(\!\(\*
StyleBox[\"I\",\nFontColor->RGBColor[0, 0, 1]]\)) MHDScalar[1,mm_MHDSystem], MHDScalar[2,mm_MHDSystem], and MHDScalar[3,mm_MHDSystem] returns, respectively, the 1st, 2nd, and 3rd fundamental scalar fields of the MHDSystem mm. (\!\(\*
StyleBox[\"II\",\nFontColor->RGBColor[0, 0, 1]]\)) MHDScalar[\[Mu]T_,1,mm_MHDSystem], MHDScalar[\[Mu]T_,2,mm_MHDSystem], and MHDScalar[\[Mu]T_,3,mm_MHDSystem] returns, respectively, the Tensor object describing \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\), \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\), and \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\), with index \[Mu]T.";
MHD3Form::usage="MHD3Form[\[Mu]T_,\[Nu]T_,\[Gamma]T_,mm_MHDSystem] returns the Tensor built from the 3 fundamental scalars \!\(\*
StyleBox[OverscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \"~\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\[Congruent] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\), of the MHDSystem mm, with indices {\[Mu]T,\[Nu]T,\[Gamma]T}.";
MHDPlasmaCurrent::usage="MHDPlasmaCurrent[\[Mu]T_,mm_MHDSystem] returns the plasma current Tensor \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\), of the MHDSystem mm, with indices {\[Mu]T}. Note that \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) is the Hodge dual of the 3-form built from the 3 fundamental MHD scalars, namely \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\).";
MHDMaxwell::usage="MHDMaxwell[\[Mu]T_,\[Nu]T_,mm_MHDSystem] returns the Maxwell Tensor \!\(\*
StyleBox[\"F\",\nFontSlant->\"Italic\"]\), of the MHDSystem mm, with indices {\[Mu]T,\[Nu]T}.";
MHDMaxwellCurrent::usage="MHDMaxwellCurrent[\[Mu]T_,mm_MHDSystem] returns the electromagnetic (Maxwell) current \!\(\*
StyleBox[\"J\",\nFontSlant->\"Italic\"]\) = div \!\(\*
StyleBox[\"F\",\nFontSlant->\"Italic\"]\), of the MHDSystem mm, with index {\[Mu]T}.";
MHDRank2P::usage="MHDRank2P[\[Mu]T_,\[Nu]T_,mm_MHDSystem] returns the rank-2 Tensor object \!\(\*
StyleBox[\"P\",\nFontSlant->\"Italic\"]\), of the MHDSystem mm, with indices {\[Mu]T,\[Nu]T}. This \!\(\*
StyleBox[\"P\",\nFontSlant->\"Italic\"]\) occurs on the right hand side of the 3 MHD PDEs.";
MHDMetric::usage="MHDMetric[\[Mu]T_, \[Nu]T_, mm_MHDSystem] returns the Metric Tensor object describing the background spacetime geometry of the MHDSystem in mm, with indices {\[Mu]T, \[Nu]T}.";
(* ... MHDSystem arguments *)
MHDScalarFunction1::usage="MHDScalarFunction1 \[Rule] \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) is one of the arguments of an MHDSystem object. It describes the 1st fundamental scalar of the MHDSstem.";
MHDScalarFunction2::usage="MHDScalarFunction2 \[Rule] \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) is one of the arguments of an MHDSystem object. It describes the 2nd fundamental scalar of the MHDSstem.";
MHDScalarFunction3::usage="MHDScalarFunction3 \[Rule] \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\) is one of the arguments of an MHDSystem object. It describes the 3rd fundamental scalar of the MHDSstem.";
MHD1FormTensor1::usage="MHD1FormTensor1 \[Rule] \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) is one of the arguements of an MHDSystem object. It describes the gradient of the 1st fundamental scalar of the MHDSstem.";
MHD1FormTensor2::usage="MHD1FormTensor2 \[Rule] \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) is one of the arguements of an MHDSystem object. It describes the gradient of the 2nd fundamental scalar of the MHDSstem.";
MHD1FormTensor3::usage="MHD1FormTensor3 \[Rule] \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\) is one of the arguements of an MHDSystem object. It describes the gradient of the 3rd fundamental scalar of the MHDSstem.";
MHD3FormTensor::usage="MHD3FormTensor \[Rule] \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)\[Wedge]\[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\)\[Wedge]\[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\) is one of the arguments of an MHDSystem object. It describes the 3-form \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)\[Wedge]\[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\)\[Wedge]\[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\), where \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(I = 1, 2, 3\)]\) are the 3 fundamental scalars of the MHDSystem.";
MHDMaxwellTensor::usage="MHDMaxwellTensor \[Rule] \[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)\[Wedge]\[Del]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) is one of the arguments of an MHDSystem object. It describes the 2-form Maxwell Tensor \!\(\*
StyleBox[\"F\",\nFontSlant->\"Italic\"]\) = \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)\[Wedge]\[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\), where \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(I = 1, 2\)]\) are the first 2 fundamental scalars of the MHDSystem.";
MHDPlasmaCurrentTensor::usage="MHDPlasmaCurrentTensor \[Rule] \[FivePointedStar](\[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) \[Wedge] \[DifferentialD]\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\)) is one of the arguments of an MHDSystem object. It describes the (identically conserved) plasma current Tensor, which in index notation reads \!\(\*SuperscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(\[Mu]\)]\) \[Congruent] \!\(\*SuperscriptBox[OverscriptBox[\(\[Epsilon]\), \(~\)], \(\[Mu]\\\ \[Alpha]\[Beta]\[Gamma]\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)\!\(\*SubscriptBox[\(\[Del]\), \(\[Beta]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\)\!\(\*SubscriptBox[\(\[Del]\), \(\[Gamma]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\), where \!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(I = 1, 2, 3\)]\) are the 3 fundamental scalars of the MHDSystem.";
MHDRank2PTensor::usage="MHDRank2PTensor \[Rule] \!\(\*FormBox[SuperscriptBox[\(P\), \(\[Alpha]\[Beta]\)],
TraditionalForm]\) is one of the arguments of an MHDSystem object. It describes the Tensor object \!\(\*SuperscriptBox[
StyleBox[\"P\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\) \[Congruent] \!\(\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\)(\!\(\*SubscriptBox[\(\[Rho]\), \(0\)]\) \!\(\*SuperscriptBox[\(\[Del]\), \([\[Sigma]\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(1\)]\) \!\(\*SuperscriptBox[\(\[Del]\), \(\[Alpha]\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(2\)]\) \!\(\*SuperscriptBox[\(\[Del]\), \(\(\[Beta]\)\(]\)\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(3\)]\)), which occurs on the right-hand-sides of the 3 PDEs governing the MHDSystem.";
MHDMaxwellCurrentTensor::usage="MHDMaxwellCurrentTensor \[Rule] \!\(\*FormBox[SuperscriptBox[\(J\), \(\[Alpha]\)],
TraditionalForm]\) is one of the arguments of an MHDSystem object. It describes the Tensor object \!\(\*SuperscriptBox[
StyleBox[\"J\",\nFontSlant->\"Italic\"], \(\[Alpha]\)]\) \[Congruent] \!\(\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\)\!\(\*SuperscriptBox[
StyleBox[\"F\",\nFontSlant->\"Italic\"], \(\[Sigma]\[Alpha]\)]\), \!\(\*
StyleBox[\"i\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"e\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\), the electromagnetic current.";
MHDEquationsList::usage="MHDEquationsList \[Rule] {{lhs1,rhs1},{lhs2,rhs2},{0,rhs3}} is one of the arguments of an MHDSystem object. The lhs1 == rhs1, lhs2 == rhs2, and 0 == rhs3 form the 3 fundamental PDEs of the MHDSystem.";
MHDEquations::usage="MHDEquations[mm_MHDSystem] returns a List of the 3 fundamental partial differential equations of the MHDSystem mm.";
MHDMaxwellStressTensor::usage="MHDMaxwellStressTensor \[Rule] \!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[EM\!\(\*SubscriptBox[\(]\), \(\[Mu]\[Nu]\)]\) is one of the arguments of an MHDSystem object. It contains the rank-2 Tensor object describing electromagnetic energy-momentum-shear-stress of the MHDSystem.";
MHDPlasmaStressTensor::usage="MHDPlasmaStressTensor \[Rule] \!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[Plasma\!\(\*SubscriptBox[\(]\), \(\[Mu]\[Nu]\)]\) is one of the arguments of an MHDSystem object. It contains the rank-2 Tensor object describing plasma energy-momentum-shear-stress of the MHDSystem.";
MHDTotalStressTensor::usage="MHDTotalStressTensor \[Rule] \!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[Total\!\(\*SubscriptBox[\(]\), \(\[Mu]\[Nu]\)]\) is one of the arguments of an MHDSystem object. It contains the rank-2 Tensor object describing the total plasma + Maxwell photon energy-momentum-shear-stress of the MHDSystem.";
MHDLagrangianDensity::usage="MHDLagrangianDensity \[Rule] L is one of the arguments of a MHDSystem object, where L is the Lagrangian density of the MHDSystem";
MHDPlasmaEnergyDensityOperator::usage="MHDPlasmaEnergyDensityOperator \[Rule] \!\(\*
StyleBox[\"op\",\nFontSlant->\"Italic\"]\) is one of the arguments of a MHDSystem object, where \!\(\*
StyleBox[\"op\",\nFontSlant->\"Italic\"]\) provides the function describing the energy density of the plasma.";
MHDPlasmaEnergyDensity::usage="MHDPlasmaEnergyDensity[mm_MHDSystem] returns the plasma energy density function of the MHDSystem mm.";
MHDLagrangian::usage="MHDLagrangian[mm_MHDSystem] returns the (coordinate scalar) Lagrangian density of the MHDSystem mm.";
MHDEnergyMomentumShearStress::usage="MHDEnergyMomentumShearStress[\[Mu]T_,\[Nu]T_,ss_String,mm_MHDSystem], for ss = Maxwell, returns the rank-2 Tensor object describing electromagnetic energy-momentum-shear-stress of the MHDSystem mm. MHDEnergyMomentumShearStress[\[Mu]T_,\[Nu]T_,ss_String,mm_MHDSystem], for ss = Plasma, returns the rank-2 Tensor object describing plasma energy-momentum-shear-stress of the MHDSystem mm. MHDEnergyMomentumShearStress[\[Mu]T_,\[Nu]T_,ss_String,mm_MHDSystem], for ss = Total, returns the rank-2 Tensor object describing the total plasma + Maxwell photon energy-momentum-shear-stress of the MHDSystem mm.";
MHDMetricTensor::usage="MHDMetricTensor \[Rule] \!\(\*SubscriptBox[
StyleBox[\"g\",\nFontSlant->\"Italic\"], \(\[Mu]\[Nu]\)]\) is one of the arguments of an MHDSystem object. It contains the rank-2 Tensor object describing background spacetime geometry of the MHDSystem.";
MHDOperator::usage="MHDOperator \[Rule] op is an optional argument when entering a MHDSystem. Default value for op is Simplify.";
MetricSignature::usage="MetricSignature \[Rule] op_String specifies whether the user is employing the `Mostly minus' or `Mostly plus' metric signature; in (1+1) spacetime dimensions `Mostly minus' means \!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu]\[Nu]\)]\) \[Congruent] diag[1,-1] and `Mostly plus' means \!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu]\[Nu]\)]\) \[Congruent] diag[-1,1]. MetricSignature occurs, for e.g., as an Optional argument in MHDSystem. Whenever relevant, the default is `Mostly minus'.";


(*NewCode: public declaration for RankNumber*)
(*This piece is supposed to not inside the official version.*)
RankNumber::usage=
"Please ignore it's, it's only public in Wei-Hao version.";
(*NewCode: ComponentRankNumber*)
ComponentRankNumber::usage=
"Please ignore it's, it's only public in Wei-Hao version.";
(*NewCode: public declaration for TooltipDisplayCheckwithComponents*)
(*This piece is supposed to not inside the official version.*)
(*TooltipDisplayCheckwithComponents::usage=
"Please ignore it. It's only public in Wei-Hao version.";*)
Sgn::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestIndices::usage=
"Please ignore it. It's only public in Wei-Hao version.";
RemoveRepeatedUnderBarredIndices::usage=
"Please ignore it. It's only public in Wei-Hao version.";
RemoveUnderBarredIndices::usage=
"Please ignore it. It's only public in Wei-Hao version.";
OverHatSgn::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestDifferentialVector::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestDifferentialForm::usage=
"Please ignore it. It's only public in Wei-Hao version.";
ZeroTensor::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestExpressionForm::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestMetricTensor::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestScalarTensor::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestTensorIsFullyAntiSymmetric::usage=
"Please ignore it. It's only public in Wei-Hao version.";
StartIndexNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TensorNameNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TensorTypeNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TooltipDisplayNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TooltipStyleNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
CoordinatesNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TensorComponentsNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
IndicesNoPart::usage=
"Please ignore it. It's only public in Wei-Hao version.";
CoordinatesDimension::usage=
"Please ignore it. It's only public in Wei-Hao version.";
(*ContainOnlyScalarTensor::usage=
"Please ignore it. It's only public in Wei-Hao version.";*)
TestMoveOnlyOneType::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TimesScalarTensorName::usage=
"Please ignore it. It's only public in Wei-Hao version.";
(*TensorPlusName::usage=
"Please ignore it. It's only public in Wei-Hao version.";*)
TestOneVector::usage=
"Please ignore it. It's only public in Wei-Hao version.";
ReplaceIndex::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestSymmetricTensorExpressionForm::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestTensorTensor::usage=
"Please ignore it. It's only public in Wei-Hao version.";
NotAbstractIndex::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestRepeatedIndices::usage=
"Please ignore it. It's only public in Wei-Hao version.";
BasisSgn::usage=
"Please ignore it. It's only public in Wei-Hao version.";
TestFormVectorIndices::usage=
"Please ignore it. It's only public in Wei-Hao version.";


(* ::Input::Initialization:: *)
(* Tensor properties/options *)
SetAttributes[Tensor,Orderless];
SetAttributes[MHDSystem,Orderless];
(*NewCode: TensorPlusOrderless*)
(*SetAttributes[TensorPlus,Orderless];
SetAttributes[TensorPlusName,Orderless];*)
(*NewCode: Attributes for ContractTensor*)
(*SetAttributes[TensorsProduct,HoldAll];*)
Options[Metric]={CoordinateSystem->{},TensorName->"\!\(\*
StyleBox[\"g\",\nFontSlant->\"Italic\"]\)",StartIndex->0,(*NewCode: MetricOperator*)MetricOperator->Simplify,ChristoffelOperator->Simplify,RiemannOperator->Simplify,RicciOperator->Simplify,RicciScalarOperator->Simplify,(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null,(*NewCode: OrthonormalFrameField*)FlatMetric->Null,OrthonormalFrameField->Null,InverseOrthonormalFrameField->Null,OrthonormalFrameFieldOperator->Simplify,TestOrthonormalFrameField->False,OrthonormalFrameFieldIndices->Null,(*NewCode: TensorOperator*)TensorOperator->Simplify,(*NewCode: TensorAssumption*)TensorAssumption-> {}};
Options[Christoffel]={(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->TensorComponents};
Options[Riemann]={(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null};
Options[Ricci]={(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null};
Options[Einstein]={EinsteinOperator->Simplify,(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null};
Options[Weyl]={WeylOperator->Simplify,(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null};
(*NewCode: OrthonormalFrameField*)
Options[OrthonormalFrameField]={OrthonormalFrameFieldOperator->Simplify,TestOrthonormalFrameField->False,OrthonormalFrameField->Null,InverseOrthonormalFrameField->Null,OrthonormalFrameFieldIndices->Null};
Options[NonMetricTensor]={StartIndex->0,TooltipDisplay->Null,TensorType->Null,(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},(*NewCode: TensorOperator*)TensorOperator-> Simplify,(*NewCode: TensorAssumption*)TensorAssumption-> {}};
Options[MHDSystem]={MHDOperator->Simplify,MetricSignature->"Mostly minus"};
Options[GeodesicSystem]={AffineParameter->Unique[\[CapitalTHacek]],NonAffineParameter->Unique[\[CapitalLSlash]]};
Options[GeodesicLagrangians]={AffineParameter->Unique[\[CapitalTHacek]],NonAffineParameter->Unique[\[CapitalLSlash]]};
(*NewCode: Options for CoordinateTransformation*)
(*Indices and TensorName are new parts w/ default value*)
Options[CoordinateTransformation]={CoordinateTransformationOperator->Simplify,StartIndex->\[Alpha]\[Beta]\[Gamma]\[Theta]\[Phi],Indices->{},TensorName->1234,(*NewCode: Options for Tooltip*)TooltipStyle->{(*Small*)},TooltipDisplay->Null};
(*NewCode: LieDerivative*)
Options[LieDerivative]={LieDerivativeOperator->Simplify,TooltipStyle->{(*Small*)},TooltipDisplay->Null,Indices->Null};
(*NewCode: LieBracket*)
Options[LieBracket]={LieDerivativeOperator->Simplify,LieBracketOperator->Simplify,TooltipStyle->{(*Small*)},TooltipDisplay->Null,Indices->Null};
(*NewCode: SphericalHarmonicYTensor*)
Options[SphericalHarmonicYTensor]={TooltipStyle->{},TooltipDisplay->Null};
(*NewCode: VectorSphericalHarmonic*)
Options[VectorSphericalHarmonic]={Normalize-> True,TooltipStyle->{},TooltipDisplay->Null};
(*NewCode: SymmetrizeIndices*)
Options[SymmetrizeIndices]={SymmetrizeIndicesOperator->(*Simplify*)(#&)};
(*NewCode: AntiSymmetrizeIndices*)
Options[AntiSymmetrizeIndices]={AntiSymmetrizeIndicesOperator->(*Simplify*)(#&)};
(*NewCode: TensorIsZeroOperator*)
Options[TensorIsZero]={TensorIsZeroOperator-> Simplify};
(*NewCode: TensorDivision*)
Options[TensorDivision]={TensorDivisionOperator-> Simplify};
(*NewCode: PotentialForm*)
Options[PotentialForm]={TensorName->"\!\(\*
StyleBox[\"\[Beta]\",\nFontSlant->\"Italic\"]\)"};
(* MMA Packages *)
Needs["VariationalMethods`"];
(*Block[{Notation`AutoLoadNotationPalette=False},Needs["Notation`"]];*)
(*NewCode: ToTensorComponents*)
Options[ToTensorComponents]={CoordinateSystem-> {}};
Options[ElectromagneticStressEnergyTensor]={MetricSignature->"Mostly minus"};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
(* check if \[Mu] is an index *)
(*TestIndices[\[Mu]_]:=MatchQ[\[Mu],SuperMinus[_Integer]]||MatchQ[\[Mu],SuperMinus[_Symbol]]||MatchQ[\[Mu],SubMinus[_Integer]]||MatchQ[\[Mu],SubMinus[_Symbol]];*)

(*NewCode: TestIndices with OverHat*)
(*NewCode: Message*)
TestIndices::TestIndicesFalse="The index `1` isn't in a proper form.";

(*TestIndices[\[Mu]_]:=If[(MatchQ[\[Mu],SuperMinus[_Integer]|SuperMinus[_Symbol]|SubMinus[_Integer]|SubMinus[_Symbol]|SuperMinus[OverHat[_Integer]]|SuperMinus[OverHat[_Symbol]]|SubMinus[OverHat[_Integer]]|SubMinus[OverHat[_Symbol]]]),True,Message[TestIndices::TestIndicesFalse,\[Mu]];False];*)

TestIndices[\[Mu]_]:=MatchQ[\[Mu],SuperMinus[_Integer]|SuperMinus[_Symbol]|SubMinus[_Integer]|SubMinus[_Symbol]|SuperMinus[OverHat[_Integer]]|SuperMinus[OverHat[_Symbol]]|SubMinus[OverHat[_Integer]]|SubMinus[OverHat[_Symbol]]];

(* \[Mu]^- gives +1 and Subscript[\[Mu], -] gives -1 *)
Sgn[\[Mu]_]:=Which[
(* upper index *)
MatchQ[\[Mu],SuperMinus[_]],1,
(* lower index *)
MatchQ[\[Mu],SubMinus[_]],-1
]/;TestIndices[\[Mu]];
(* \[Mu]^- or Subscript[\[Mu], -] returns \[Mu] *)
IndexNumber[\[Mu]_]:=\[Mu][[1]]/;TestIndices[\[Mu]];
(* \[Mu]^- returns Column[{\[Mu],Null}], i.e. upper index *)
(* Subscript[\[Mu], -] returns Column[{Null,\[Mu]}], i.e. lower index *)
UpOrDown[\[Mu]_]:=Which[
(* lower index *)
MatchQ[\[Mu],SubMinus[_]],Column[{Null,\[Mu][[1]]}],
(* upper index *)
MatchQ[\[Mu],SuperMinus[_]],Column[{\[Mu][[1]],Null}]
];
(* ReplaceIndex: takes in \[Nu] and (\[Mu]^- or Subscript[\[Mu], -]), and returns (\[Nu]^- or Subscript[\[Nu], -]) *)
(*ReplaceIndex[\[Nu]_/;((Head[\[Nu]]===Symbol)||(Head[\[Nu]]===Integer)),\[Mu]_/;TestIndices[\[Mu]]]:=Which[
(* upper index *)
MatchQ[\[Mu],SuperMinus[_]],SuperMinus[\[Nu]],
(* lower index *)
MatchQ[\[Mu],SubMinus[_]],SubMinus[\[Nu]]
];*)

(*NewCode: ReplaceIndex*)
ReplaceIndex[\[Nu]_/;((Head[\[Nu]]===Symbol)||(Head[\[Nu]]===Integer)),\[Mu]_/;TestIndices[\[Mu]]]:=\[Nu]//\[Mu][[0]];

(*NewCode: ReplaceIndex*)
ReplaceIndex[\[Nu]_/;TestIndices[\[Nu]],\[Mu]_/;TestIndices[\[Mu]]]:=(\[Nu][[1]]//\[Mu][[0]]);

(* returns #^- or Subscript[#, -] given coordinates cooo and StartIndex st, where # is the appropriate index number *)
(* if the \[Mu]I is just a Symbol w/o any other meaning, it will be returned as is. *)
NumericIndex[\[Mu]I_/;TestIndices[\[Mu]I],cooo_List,st_]:=Which[
(* if it's already an Integer then just return itself *)
Head[\[Mu]I[[1]]]===Integer,\[Mu]I,
(* if it is one of the coordinates return the Position *)
Intersection[{\[Mu]I[[1]]},cooo]==={\[Mu]I[[1]]},
	ReplaceIndex[((Flatten[Position[cooo,\[Mu]I[[1]]]])[[1]]-1+st),\[Mu]I],
(* if neither then just return original stuff *)
True,\[Mu]I
];
(* RaiseLower[\[Mu],\[Nu],\[Tau]] gives KroneckerDelta if \[Mu] and \[Nu] have the same Sgn and otherwise g^{\[Mu]\[Nu]} or g_{\[Mu]\[Nu]} *)
(* right index is the index on the Tensor *)
(* left index is what we want *)
(* if they are both upper or lower, then we need to return \[Delta] *)
(* if ud, then return g^{-1} *)
(* if du, then return g *)
(*NewCode: ExtractFunctions*)
RaiseLower[\[Mu]_/;TestIndices[\[Mu]],\[Nu]_/;TestIndices[\[Nu]],\[Tau]_Tensor]/;(*NewCode: ExtractFunctions*)((TensorTypeNoPart[\[Tau]]==={"Metric"})&&(MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SuperMinus[_],SuperMinus[_]}]||MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SubMinus[_],SubMinus[_]}])):=Module[
{si,MetricM},
si=StartIndex[\[Tau]];
(* read in the metric *)
MetricM=TensorComponents[\[Tau]];
Which[
(* same sign *)
Sgn[\[Mu]]Sgn[\[Nu]]===1,
	KroneckerDelta[IndexNumber[\[Mu]],IndexNumber[\[Nu]]],
(* \[Mu] positive, \[Nu] negative *)
(* g^{\[Mu] \[Nu]} *)
(* extract inverse metric *)
(Sgn[\[Mu]]===1)&&(Sgn[\[Nu]]===-1),
	Which[
		(* inverse metric *)
		MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SuperMinus[_],SuperMinus[_]}],
		MetricM,
		(* metric *)
		MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SubMinus[_],SubMinus[_]}],
		Inverse[MetricM]
	][[IndexNumber[\[Mu]]-si+1,IndexNumber[\[Nu]]-si+1]],
(* \[Mu] negative, \[Nu] positive *)
(* g_{\[Mu] \[Nu]} *)
(* extract metric *)
(Sgn[\[Mu]]==-1)&&(Sgn[\[Nu]]==1),
	Which[
		(* inverse metric *)
		MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SuperMinus[_],SuperMinus[_]}],
		Inverse[MetricM],
		(* metric *)
		MatchQ[Flatten[IndicesNoPart[\[Tau]]],{SubMinus[_],SubMinus[_]}],
		MetricM
	][[IndexNumber[\[Mu]]-si+1,IndexNumber[\[Nu]]-si+1]]
]
];
(* TestQuadratic checks that the metric expression *)
(* is quadratic in the differentials of the coordinates *)
(*NewCode: TestQuadratic*)
(*NewCode: Message*)
TestQuadratic::TestQuadraticFalse="The expression form of metric `1` isn't quadratic or consistent with metric's indices.";

TestQuadratic[ss_,cc_List,judge_Integer/;((judge===1)||(judge===-1))]:=Module[
{dx,delx,newss,\[Epsilon],\[Epsilon]2,out},
(* introduce power counting rule *)
dx=((\[DifferentialD]#->\[Epsilon] \[DifferentialD]#)& /@cc);
delx=((\[Del]#->\[Epsilon]2 \[Del]#)& /@cc);
newss=(ss/.dx)/.delx;
Which[
(judge===-1),
out=FullSimplify[D[newss,\[Epsilon]]/(ss \[Epsilon]),{\[Epsilon]>0}];
If[(out===2),True,Message[TestQuadratic::TestQuadraticFalse,ss];False],
(judge===+1),
out=FullSimplify[D[newss,\[Epsilon]2]/(ss \[Epsilon]2),{\[Epsilon]2>0}];
If[(out===2),True,Message[TestQuadratic::TestQuadraticFalse,ss];False]
]
];

(*NewCode: TestQuadraticInverse*)
(*NewCode: Message*)
(*TestQuadraticInverse::TestQuadraticInverseFalse="The expression form of inverse metric `1` isn't quadratic.";

TestQuadraticInverse[ss_,cc_List]:=Module[
{delx,\[Epsilon],out},
(* introduce power counting rule *)
delx=((\[Del]#\[Rule]\[Epsilon] \[Del]#)& /@cc);
out=FullSimplify[D[(ss/.delx),\[Epsilon]]/(ss \[Epsilon]),{\[Epsilon]>0}];
If[(out===2),True,Message[TestQuadraticInverse::TestQuadraticInverseFalse,ss];False]
];*)

(* TestMetricTensor checks that m is a Tensor of the type Metric *)
(*NewCode: Message*)
TestMetricTensor::TestMetricTensorFalse="The tensor `1` isn't a metric tensor.";

TestMetricTensor[m_Tensor]:=Module[{tt},(*NewCode: ExtractFunctions*)If[(TensorTypeNoPart[m]==={"Metric"}),True,Message[TestMetricTensor::TestMetricTensorFalse,m];False]];
(* CollectRepeatedIndices takes in two or more Lists of Indices and returns all repeated ones *)
CollectRepeatedIndices[ll__List]/;(Union[TestIndices/@Join[ll]]==={True}):=Cases[Split[Sort[(#[[1]]&/@Join[ll])]],{ss_Symbol,ss_Symbol}->ss];
(* NotAbstractIndex takes in an index \[Mu], a List of coordinates cooo, and start index si, and returns True if the index is not abstract and False otherwise *)
(* Note: start index is needed because sometimes the Index is given as an Integer^- or Subscript[Integer, -] *)
(* The index can be UnderBarred or not *)
NotAbstractIndex[\[Mu]_,cooo_List,si_Integer]:=((TestIndices[\[Mu]]&&((Intersection[{NumericIndex[\[Mu],cooo,si][[1]]},Range[si,Length[cooo]+si-1]]==={NumericIndex[\[Mu],cooo,si][[1]]})||NumericQ[\[Mu][[1]]])));
(* TestScalarTensor reads in a Tensor and determines whether it is a scalar by checking *)
(* (1) If Indices are empty {} (2) if all Indices are UnderBarred *)
(* returns True if Tensor is scalar and False otherwise *)
TestScalarTensor[m_Tensor]:=(Indices[m]==={})||MatchQ[Indices[m],{(SuperMinus|SubMinus)[UnderBar[_]]..}];

TestScalarTensor[m_/;TestExpressionForm[m]]:=False;

TestScalarTensor[(m_Times|m_Plus)/;!TestExpressionForm[m]]:=Which[(Cases[m,(Indices-> idx_)-> idx,Infinity]==={{}}),True,True,False];

(*NewCode: TestTensorTensor*)
TestTensorTensor[t_]:=((!TestExpressionForm[t])&&(!TestScalarTensor[t])&&(RemoveUnderBarredIndices[Flatten[Cases[{(t)},((Indices->(idx_/;(idx=!={})))-> idx ),Infinity]]]=!={}));
(* RemoveUnderBarredIndices remove all UnderBarred Indices *)
RemoveUnderBarredIndices[\[Mu]T_List]:=Module[{xx1,xx2},DeleteCases[\[Mu]T,SuperMinus[UnderBar[xx1_]]|SubMinus[UnderBar[xx2_]]]];

(*NewCode: RemoveUnderBarredIndices for Tensor*)
RemoveUnderBarredIndices[t_Tensor]:=Indices[t,RemoveUnderBarredIndices[Indices[t]]];

(* RemoveRepeatedUnderBarredIndices remove all repeated UnderBarred Indices *)
RemoveRepeatedUnderBarredIndices[\[Mu]T_List]:=Module[{\[Mu],i1,i2,i3},(\[Mu]T//.{i1___,SuperMinus[UnderBar[\[Mu]_]],i2___,SubMinus[UnderBar[\[Mu]_]],i3___}->{i1,i2,i3})//.{i1___,SubMinus[UnderBar[\[Mu]_]],i2___,SuperMinus[UnderBar[\[Mu]_]],i3___}->{i1,i2,i3}];

(*NewCode: RemoveRepeatedUnderBarredIndices for Tensor*)
RemoveRepeatedUnderBarredIndices[t_Tensor]:=Indices[t,RemoveRepeatedUnderBarredIndices[Indices[t]]];

(* NestedDel takes in an express of the form Del[...Del[stuff]] and returns {# of Dels, stuff} *)
(* By stuff we simply mean the remainder after the outer most Del's are peeled away; there could still be Del's hidden in output *)
NestedDel[dd_Del]:=Module[{stuff,idx},
stuff=dd;idx=0;
While[
Head[stuff]===Del,
(* strip off outer most Del's *)
stuff=stuff[[1]];idx=idx+1;
];
{idx,stuff}
];
(* FormatTensorName formats the TensorName of a Tensor object *)
FormatTensorName[name_]:=Which[
MatchQ[Head[name],((* If it is a TensorProduct/CovariantD/Times we put a parenthesis around it *)TensorProduct|Del|Times|Row)],MatrixForm[{name}],
True,name];
(*NewCode: Internal Function: RankNumber*)
(*You can input as a Tensor or list (CoordinateSystem). The output will be the rank of tensor.*)
RankNumber[t_Tensor]:=Length[RemoveUnderBarredIndices[Indices[t]]];
RankNumber[\[Mu]_List]:=Length[RemoveUnderBarredIndices[\[Mu]]];
RankNumber[expr_/;TestExpressionForm[expr]]:=0;
(*NewCode: CoordinatesDimension*)
CoordinatesDimension[t_Tensor]:=Length[Coordinates[t]];
(*NewCode: ComponentRankNumber*)
ComponentRankNumber[t_Tensor]/;!TestExpressionForm[TensorComponents[t]]:=Length[Dimensions[TensorComponents[t]]];
ComponentRankNumber[t_Tensor]/;TestExpressionForm[TensorComponents[t]]:=0;
ComponentRankNumber[\[Mu]_List]:=Length[Dimensions[\[Mu]]];
ComponentRankNumber[\[Mu]_/;TestExpressionForm[\[Mu]]]:=0;
(*NewCode: Internal Function: TooltipDisplayCheckwithComponents*)
(*This function is to check if the TooltipDisplay coincide w/ TensorComponents. We can input with a Tensor, or two lists (Tooltipdisplay List and TensorComponents).*)
(*Now, this is only for Christoffel.*)
(*TooltipDisplayCheckwithComponents[disp_List,cps_List]:=Module[{lgth,toollist,complist},
toollist=#\[LeftDoubleBracket]2\[RightDoubleBracket]&/@Flatten[disp];
complist=Select[Flatten[cps],(#=!=0)&];
toollist=Sort[toollist];
complist=Sort[complist];
complist===toollist
];*)

(*MoveIndicesDoNotInvolveOverHatQ[tt_Tensor,idx_List]:=(Cases[Indices[tt],(SubMinus[OverHat[_]]|SuperMinus[OverHat[_]])]==={})&&(Cases[idx,(SubMinus[OverHat[_]]|SuperMinus[OverHat[_]])]==={});*)
(*NewCode: OrthonormalFrameField*)
TestMoveOnlyOneType[tt_Tensor,idx_List]:=Module[{list={},i,ttidx},ttidx=Indices[tt];Do[Which[Head[idx[[i]]]=!=Head[ttidx[[i]]],list=Append[list,Head[idx[[i,1]]]]],{i,Sequence@@Dimensions[idx]}];
(*Dimensions[Union[list]]==={1}*)MatchQ[Dimensions[(Union[list]/.{Integer-> Nothing})],({0}|{1})]];

OverHatSgn[\[Mu]_]:=Which[((Head[\[Mu][[1]]])===Symbol),-1,((Head[\[Mu][[1]]])===OverHat),1,((Head[\[Mu][[1]]])===Integer),-1]


(*Abondoned code: Start*)
(*TooltipDisplayCheckwithComponents[t_Tensor]:=Module[{lgth,toollist,complist},
(*Extract the TooltipDisplay*)
toollist=Flatten[Cases[t,(TooltipDisplay\[Rule]td_)\[Rule]td]];
(*The number of non-zero components in TooltipDisplay*)
lgth=Length[toollist];
(*Extract every rhs of the rules.*)
toollist=Table[toollist\[LeftDoubleBracket]a\[RightDoubleBracket]\[LeftDoubleBracket]2\[RightDoubleBracket],{a,1,lgth}];
(*Extract the non-zero components in TensorComponents*)
complist=Select[Flatten[t//TensorComponents],(#=!=0)&];
(*Sometimes, the order will be different. We should sort them before match them.*)(*For example, the order will be different for a Christoffel Symbols after coordinate transformation.*)
toollist=Sort[toollist];
complist=Sort[complist];
complist===toollist
];*)
(*Abondoned code: End*)

(*Abondoned code: Start*)
(*AddCurlyBrackets[idx_List]:=Module[{break,lgth,output},lgth=Length[idx];
Do[Which[!MatchQ[idx\[LeftDoubleBracket]i\[RightDoubleBracket],(SuperMinus|SubMinus)[UnderBar[_]]],output=Insert[idx,UnderBar["{"]//idx\[LeftDoubleBracket]i,0\[RightDoubleBracket],i];break=True];If[break===True,Break[]],{i,1,lgth}];
break=False;
Do[Which[!MatchQ[output\[LeftDoubleBracket]lgth+2-i\[RightDoubleBracket],(SuperMinus|SubMinus)[UnderBar[_]]],output=Insert[output,UnderBar["}"]//output\[LeftDoubleBracket]lgth+2-i,0\[RightDoubleBracket],lgth+3-i];break=True];If[break===True,Break[]],{i,1,lgth+1}];
output
];*)
(*Abondoned code: End*)

(*NewCode: NonZeroTensorComponents*)
NonZeroTensorComponents[name_,
\[Mu]T_List,
ttM_,
coords_List]:=Module[{collist={},rank=RankNumber[\[Mu]T],dim=Length[coords],symboltemp,symbollist={},range,replacementlist,newdisp},
(*Prepare the lhs (column list)*)
Do[
collist=Append[collist,UpOrDown [\[Mu]T[[i]]]],{i,1,rank}];
(*First step. Haven't specified any index.*)
newdisp={(Row[{FormatTensorName[name],Sequence@@collist}]->ttM)};
(*2nd, 3rd steps, and so on. Start to specified from first index until every index is specified.*)
Do[newdisp=Table[Cases[newdisp,Rule[a_,b_]:> Rule[a/.(\[Mu]T[[idxnumber]][[1]]->coords[[coordnumber]]),b[[coordnumber]]],Infinity],{coordnumber,1,dim}],{idxnumber,1,rank}];
(*Select non-zero comp.*)
Select[newdisp//Flatten,(Flatten[Cases[{#},(Row[__]->cc_)->cc]][[1]]=!=0)&]
];

(*NewCode: TestDifferentialForm*)
(*NewCode: Message*)
TestDifferentialForm::AntiSymmetricOrVectorOrScalar="The argument `1` might not have anti-symmetric TensorComponent, or it is not a vector nor scalar.";
(*TestDifferentialForm::TestIndicesFalse="The argument `1` does not have indices in correct format.";*)
TestDifferentialForm::AllLowerIndicesFalse="The argument `1` does not have all lower indices.";

TestDifferentialForm[t_Tensor]:=(If[((*check t is a fully anti-symm tensor*)(TensorSymmetry[t][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])||(*Or t should be a scalar*)(TestScalarTensor[t])||(*Or t should be a vector*)(RankNumber[t]===1)),True,Message[TestDifferentialForm::AntiSymmetricOrVectorOrScalar,t];False]&&(*Check indices in t are OK or no index (scalar).*)(*If[*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}|{}](*,True,Message[TestDifferentialForm::TestIndicesFalse,t];False]*)&&(*All of them should be lower indices or no index.*)If[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{-1}|{}],True,Message[TestDifferentialForm::AllLowerIndicesFalse,t];False])

TestDifferentialForm[t_Tensor,m_Tensor/;TestMetricTensor[m]]:=(If[((*check t is a fully anti-symm tensor*)(TensorSymmetry[LowerAllIndices[t,m]][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])||(*Or t should be a scalar*)(TestScalarTensor[t])||(*Or t should be a vector*)(RankNumber[t]===1)),True,Message[TestDifferentialForm::AntiSymmetricOrVectorOrScalar,t];False]&&(*Check indices in t are OK or no index (scalar).*)(*If[*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}|{}](*,True,Message[TestDifferentialForm::TestIndicesFalse,t];False]*)(*Shouldn't check all of them be lower indices or no index.*))

(*NewCode: TestDifferentialVector*)
(*NewCode: Message*)
TestDifferentialVector::AntiSymmetricOrVectorOrScalar="The argument `1` might not have anti-symmetric TensorComponent, or it is not a vector nor scalar.";
(*TestDifferentialVector::TestIndicesFalse="The argument `1` does not have indices in correct format.";*)
TestDifferentialVector::AllUpperIndicesFalse="The argument `1` does not have all upper indices.";

TestDifferentialVector[t_Tensor]:=(If[((*check t is a fully anti-symm tensor*)(TensorSymmetry[t][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])||(*Or t should be a scalar*)(TestScalarTensor[t])||(*Or t should be a vector*)(RankNumber[t]===1)),True,Message[TestDifferentialVector::AntiSymmetricOrVectorOrScalar,t];False]&&(*Check indices in t are OK or no index (scalar).*)(*If[*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}|{}](*,True,Message[TestDifferentialVector::TestIndicesFalse,t];False]*)&&(*All of them should be upper indices or no index.*)If[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{1}|{}],True,Message[TestDifferentialVector::AllUpperIndicesFalse,t];False])

TestDifferentialVector[t_Tensor,m_Tensor/;TestMetricTensor[m]]:=(If[((*check t is a fully anti-symm tensor*)(TensorSymmetry[RaiseAllIndices[t,m]][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])||(*Or t should be a scalar*)(TestScalarTensor[t])||(*Or t should be a vector*)(RankNumber[t]===1)),True,Message[TestDifferentialVector::AntiSymmetricOrVectorOrScalar,t];False]&&(*Check indices in t are OK or no index (scalar).*)(*If[*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}|{}](*,True,Message[TestDifferentialVector::TestIndicesFalse,t];False]*)(*Shouldn't check all of them be upper indices or no index.*))

(*NewCode: TestTensorIsFullyAntiSymmetric*)
TestTensorIsFullyAntiSymmetric[t_Tensor]:=(((*check t is a fully anti-symm tensor*)(TensorSymmetry[t][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])&&(RankNumber[t]>1))&&(*Check indices in t are OK.*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}]&&(*All of them should be upper indices or lower indices.*)MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{1}|{-1}])

TestTensorIsFullyAntiSymmetric[t_Tensor,m_Tensor/;TestMetricTensor[m]]:=(((*check t is a fully anti-symm tensor*)(TensorSymmetry[LowerAllIndices[t,m]][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[t]]]]])&&(RankNumber[t]>1))&&(*Check indices in t are OK.*)MatchQ[(Union[TestIndices[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{True}](*Shouldn't check all of them be upper indices or lower indices.*))

(*NewCode: ZeroTensor*)
ZeroTensor[indices_List,cs_List]:=NonMetricTensor[indices,Normal[SymmetrizedArray[{},Table[Length[cs],{j,1,RankNumber[indices]}],ZeroSymmetric[All]]],"0",CoordinateSystem->cs]

(*NewCode: TestExpressionForm*)
TestExpressionForm[stuff_]:=((Union[Cases[{stuff},Tensor[xx___],\[Infinity]]]==={})&&(Head[stuff]=!=List))

(*ContainOnlyScalarTensor[stuff_]:=((Union[TestScalarTensor[#]&/@Cases[{stuff},_Tensor,Infinity]])==={True})*)

(*NewCode: TensorPlusName*)
(*TensorPlusName[(LHSt_Tensor|LHSt_Times(*|LHSt_Plus*))+(RHSt_Tensor|RHSt_Times|RHSt_Plus)]/;(*(Cases[LHSt,Tensor[___],{0,Infinity}]=!={})*)(!TestExpressionForm[LHSt])&&(*(Cases[RHSt,Tensor[___],{0,Infinity}]=!={})*)(!TestExpressionForm[RHSt]):=Module[{LHSttemp=TensorName[LHSt],RHSttemp=TensorName[RHSt]},
Which[(Head[LHSt]===Times),LHSttemp=TimesScalarTensorName[LHSt]];
Which[(Head[RHSt]===Times),RHSttemp=TimesScalarTensorName[RHSt]];
Which[(Head[RHSt]===Plus),
RHSttemp=TensorPlusName[RHSt]];
Row[{LHSttemp,"+",RHSttemp}]
];*)

(*NewCode: TimesScalarTensorName*)
(*TimesScalarTensorName[Times[scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),t_Tensor]]:=Times[TensorName[scalar],TensorName[t]];*)
(*TimesScalarTensorName[Times[scalar___/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),t___Tensor]]:=(Times@@(TensorName[#]&/@{scalar}))TensorName[t];*)
(*TimesScalarTensorName[Times[scalar___/;(Head[scalar]=!=Tensor),t___Tensor]]:=(Times@@(TensorName[#]&/@{scalar}))TensorName[(Times@@{t})];*)

(*NewCode: TestOneVector*)
(*NewCode: Message*)
TestOneVector::TestOneVectorFalse="The argument `1` isn't a 1-vector tensor.";

TestOneVector[\[Xi]_Tensor]:=If[(MatchQ[Indices[\[Xi]],{SuperMinus[_]}]),True,Message[TestOneVector::TestOneVectorFalse,\[Xi]];False];

(*NewCode: WedgeProductExpand*)
WedgeProductExpand[tw_TensorWedge]:=Module[{dlist,Permutelist,sgnlist,lgth,result,ii},
dlist=tw/.{TensorWedge[xxx___]-> {xxx}};
Permutelist=Permutations[dlist];
sgnlist=Signature[#]&/@Permutelist;
lgth=Length[Permutelist];
result=Apply[Plus,sgnlist[[1]]Table[sgnlist[[ii]] TensorProduct[Sequence@@Permutelist[[ii]]],{ii,1,lgth}]]
];

(*NewCode: TestSymmetricTensorExpressionForm*)
TestSymmetricTensorExpressionForm[stuff_]:=Module[{tep,liststuff},
tep=stuff//Expand;
Which[Head[tep]===Plus,liststuff=Apply[List,tep]];
Which[Head[tep]===Times,liststuff={tep}];
((Cases[liststuff,((\[Del]_)|(\[Del]_)^power_|Times[x1___/;(Cases[{x1},(\[DifferentialD]_|\[Del]_),Infinity]==={}),xxx___/;(MatchQ[{xxx},{((\[Del]_)|(\[Del]_)^power_)..}]&&(Length[{xxx}]===1)),x2___/;(Cases[{x2},(\[DifferentialD]_|\[Del]_),Infinity]==={})]),{1}]=!={})||
(Cases[liststuff,((\[DifferentialD]_)|(\[DifferentialD]_)^power_|Times[x1___/;(Cases[{x1},(\[DifferentialD]_|\[Del]_),Infinity]==={}),xxx___/;(MatchQ[{xxx},{((\[DifferentialD]_)|(\[DifferentialD]_)^power_)..}]&&(Length[{xxx}]===1)),x2___/;(Cases[{x2},(\[DifferentialD]_|\[Del]_),Infinity]==={})]),{1}]=!={})||
(Cases[liststuff,Times[x1___/;(Cases[{x1},(\[DifferentialD]_|\[Del]_),Infinity]==={}),xxx___/;(MatchQ[{xxx},{((\[DifferentialD]_)|(\[DifferentialD]_)^power_)..}]&&(Length[{xxx}]=!=1)),x2___/;(Cases[{x2},(\[DifferentialD]_|\[Del]_),Infinity]==={})],{1}]=!={})||
(Cases[liststuff,Times[x1___/;(Cases[{x1},(\[DifferentialD]_|\[Del]_),Infinity]==={}),xxx___/;(MatchQ[{xxx},{(\[Del]_|(\[Del]_)^power_)..}]&&(Length[{xxx}]=!=1)),x2___/;(Cases[{x2},(\[DifferentialD]_|\[Del]_),Infinity]==={})],{1}]=!={})||MatchQ[tep,((\[DifferentialD]_)|(\[DifferentialD]_)^power_|\[Del]_|(\[Del]_)^power_)])];

(*NewCode: New ContractTensors*)
TestRepeatedIndices::TestRepeatedIndicesFalse="Didn't detect any repeated indices.";

TestRepeatedIndices[wholeBunchOfStuff_]:=Module[{AllTensor,FirstTensor,cooo,si,idx},
AllTensor=Cases[{wholeBunchOfStuff},_Tensor,Infinity];
FirstTensor=AllTensor[[1]];
cooo=Coordinates[FirstTensor];
si=StartIndex[FirstTensor];
MatchQ[Flatten[Cases[{wholeBunchOfStuff},(Indices-> idx_)-> idx,Infinity]],(({i1___,\[Mu]1T_,i2___,\[Mu]2T_,i3___}/;(((* check repeated indices *)\[Mu]1T[[1]]===\[Mu]2T[[1]])&&((* check one index up and one down *)Sgn[\[Mu]1T]Sgn[\[Mu]2T]===-1)&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]1T,cooo,si])&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]2T,cooo,si])&&TestIndices[\[Mu]1T]&&TestIndices[\[Mu]2T]))|{i1___,\[Mu]1T_,i2___,\[Mu]2T_,i3___}/;(((* check repeated indices *)\[Mu]1T[[1]]===\[Mu]2T[[1]])&&((* check one index up and one down *)Sgn[\[Mu]1T]Sgn[\[Mu]2T]===-1)&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]1T,cooo,si])&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]2T,cooo,si])&&TestIndices[\[Mu]1T]&&TestIndices[\[Mu]2T]))]];

(*NewCode: BasisSgn*)
BasisSgn[stuff_]:=Which[MatchQ[stuff,\[DifferentialD]_],-1,MatchQ[stuff,\[Del]_],1];

(*NewCode: TestFormVectorIndices*)
TestFormVectorIndices[t_Tensor]:=MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[t]]]),{1}|{-1}|{}];

(*NewCode: TestFormVectorIndices*)
TestFormVectorIndices[indices_List]:=MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[indices]]),{1}|{-1}|{}];


(* ::Input::Initialization:: *)
(* Metric *)
(* this is how we are going to input a metric and compute geometric objects *)
(*NewCode: Redundant TagSetDelay*)
(*There are more TagSetDelay can be cancelled out.*)
Tensor[
TensorType->"Metric",
TensorName->name_,
StartIndex->si_Integer/;si>=0,
Indices->{\[Mu]T_/;(TestIndices[\[Mu]T]&&(Head[\[Mu]T[[1]]]===Symbol)),\[Nu]T_/;(TestIndices[\[Nu]T]&&(Head[\[Nu]T[[1]]]===Symbol))},
CoordinateSystem->coords_List/;MatchQ[Dimensions[coords],{_Integer}],
TensorComponents->matrix_/;MatchQ[Dimensions[matrix],{nn_,nn_}],
ChristoffelOperator->ChrisOp_,
RiemannOperator->RiemannOp_,
RicciOperator->RicciOp_,
RicciScalarOperator->RicciSOp_,
(*NewCode: TooltipDisplay for metric*)
TooltipDisplay->ttdisplay_,
(*NewCode: TooltipStyle for metric*)
TooltipStyle->ttstyle_,
(*NewCode: OrthonormalFrameField*)
FlatMetric->fm_,
OrthonormalFrameField->onffuser_,
InverseOrthonormalFrameField->invonffuser_,
OrthonormalFrameFieldOperator->onffop_,
TestOrthonormalFrameField->checkonff_,
OrthonormalFrameFieldIndices->onffidx_,
(*NewCode: TensorAssumption*)
TensorAssumption->TA_,
(*NewCode: TensorOperator*)
TensorOperator-> Top_
]/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SubMinus[_]}]||MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SuperMinus[_]}]):=Module[
{Detg,MetricT,MetricM,Ch,RiemannP,Riemann,RicciT,RicciS,Metric,MetricInv,
	\[Alpha],\[Beta],\[Mu],\[Nu],d,\[Lambda],\[Sigma],coord,gInv,
	RiemannRules,RicciTensorRules,RicciScalarRule,ChristoffelRules},
(*Print["T"];*)
(* "load" the metric *)
MetricM=Which[
(* lower indices *)
MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SubMinus[_]}],
matrix,
(* upper indices *)
MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SuperMinus[_]}],
Inverse[matrix]
];
d=Length[coords];
(* for internal computation here, we set StartIndex \[Rule] 0 *)
coord[\[Alpha]_]:=coords[[\[Alpha]+1]];
(* tools to compute tensor components *)
Detg=Simplify[Det[MetricM]];
Metric[\[Mu]_,\[Nu]_]:=MetricM[[\[Mu]+1,\[Nu]+1]];
MetricInv[\[Mu]_,\[Nu]_]:=Inverse[MetricM][[\[Mu]+1,\[Nu]+1]];
Ch[\[Mu]_,\[Alpha]_,\[Beta]_]:=(1/2)Sum[MetricInv[\[Mu],\[Lambda]](D[Metric[\[Beta],\[Lambda]],coord[\[Alpha]]]+D[Metric[\[Alpha],\[Lambda]],coord[\[Beta]]]-D[Metric[\[Alpha],\[Beta]],coord[\[Lambda]]]),{\[Lambda],0,d-1}];
RiemannP[\[Alpha]_,\[Beta]_,\[Mu]_,\[Nu]_]:=D[Ch[\[Alpha],\[Beta],\[Nu]],coord[\[Mu]]]+Sum[Ch[\[Alpha],\[Mu],\[Sigma]]Ch[\[Sigma],\[Beta],\[Nu]],{\[Sigma],0,d-1}];
Riemann[\[Alpha]_,\[Beta]_,\[Mu]_,\[Nu]_]:=RiemannP[\[Alpha],\[Beta],\[Mu],\[Nu]]-RiemannP[\[Alpha],\[Beta],\[Nu],\[Mu]];
RicciT[\[Beta]_,\[Nu]_]:=Sum[Riemann[\[Mu],\[Beta],\[Mu],\[Nu]],{\[Mu],0,d-1}];RicciS:=Sum[MetricInv[\[Beta],\[Nu]]RicciT[\[Beta],\[Nu]],{\[Beta],0,d-1},{\[Nu],0,d-1}];
(* start from the empty List *)
RiemannRules={};RicciTensorRules={};ChristoffelRules={};
(* "Do" the computation and save as rules *)
Do[Metric[\[Mu],\[Nu]]=Metric[\[Mu],\[Nu]],{\[Mu],0,d-1},{\[Nu],0,d-1}];
Do[MetricInv[\[Mu],\[Nu]]=MetricInv[\[Mu],\[Nu]],{\[Mu],0,d-1},{\[Nu],0,d-1}];
Do[Ch[\[Mu],\[Alpha],\[Beta]]=ChrisOp[Ch[\[Mu],\[Alpha],\[Beta]]];ChristoffelRules=Append[ChristoffelRules,{ChristoffelComponents[SuperMinus[(si+\[Mu])],SubMinus[(si+\[Alpha])],SubMinus[(si+\[Beta])]]->Ch[\[Mu],\[Alpha],\[Beta]]}],
{\[Mu],0,d-1},{\[Alpha],0,d-1},{\[Beta],0,d-1}];
	Do[
Riemann[\[Alpha],\[Beta],\[Mu],\[Nu]]=RiemannOp[Riemann[\[Alpha],\[Beta],\[Mu],\[Nu]]];
RiemannRules=Append[RiemannRules,{RiemannComponents[SuperMinus[(si+\[Alpha])],SubMinus[(si+\[Beta])],SubMinus[(si+\[Mu])],SubMinus[(si+\[Nu])]]->Riemann[\[Alpha],\[Beta],\[Mu],\[Nu]]}],
{\[Mu],0,d-1},{\[Nu],0,d-1},{\[Alpha],0,d-1},{\[Beta],0,d-1}];
	Do[
RicciT[\[Beta],\[Nu]]=RicciOp[RicciT[\[Beta],\[Nu]]];
RicciTensorRules=Append[RicciTensorRules,{RicciComponents[SubMinus[(si+\[Beta])],SubMinus[(si+\[Nu])]]->RicciT[\[Beta],\[Nu]]}],
{\[Beta],0,d-1},{\[Nu],0,d-1}];
	RicciS=RicciSOp[RicciS];
RicciScalarRule={RicciScalar->RicciS};
Tensor[
TensorType->"Metric",
TensorName->name,
StartIndex->si,
Indices->{\[Mu]T,\[Nu]T},
CoordinateSystem->coords,
TensorComponents->matrix,
MetricDeterminant->Detg,
ChristoffelComponents->Flatten[ChristoffelRules],
RiemannComponents->Flatten[RiemannRules],
RicciComponents->Flatten[RicciTensorRules],
RicciScalarInvariant->Flatten[RicciScalarRule],
(*NewCode: TooltipDisplay for metric*)
TooltipDisplay->ttdisplay,
TooltipStyle->ttstyle,
(*NewCode: OrthonormalFrameField*)
FlatMetric->fm,
OrthonormalFrameField->onffuser,
InverseOrthonormalFrameField->invonffuser,
OrthonormalFrameFieldOperator->onffop,
TestOrthonormalFrameField->checkonff,
OrthonormalFrameFieldIndices->onffidx,
(*NewCode: TensorAssumption*)
TensorAssumption->TA,
(*NewCode: TensorOperator*)
TensorOperator-> Top
]
];
(* Metric: If one up and one down index TensorName is changed to \[Delta] *)
(* this is also good reminder that going to one up one down indices throws away info on the metric itself *)
Tensor[
xx___,
TensorType->"Metric",
Indices->{i1_,i2_}/;((* one up and one down *)Sgn[i1]Sgn[i2]===-1),
TensorName->name_/;((name=!="\!\(\*
StyleBox[\"\[Delta]\",\nFontSlant->\"Italic\"]\)")&&(name=!="\[Delta]"))
]:=Tensor[xx,TensorType->"Metric",Indices->{i1,i2},TensorName->"\[Delta]"];


(* ::Input::Initialization:: *)
(*NewCode: Second strategy of ONFF*)
Tensor/:Eigensystem[t_Tensor]:=Eigensystem[TensorComponents[t]];


(* ::Input::Initialization:: *)
(*NewCode: OrthonormalFrameField*)
(*OrthonormalFrameField Tensor part*)
Tensor[
(*The pattern check here take care of pattern checking efficiency.*)
xx__/;((*Check ChristoffelComponents is to ensure we finished all basic metric calculation.*)
(Cases[{xx},(ChristoffelComponents->cc_)->cc,1]=!={})&&
(IndicesNoPart[{xx}]=!={})&&(Cases[{xx},(TensorComponents->tc_)->tc,1]=!={})&&(TensorTypeNoPart[{xx}]==={"Metric"})&&
(*FlatMetric should be not Null and a Rank-1 list. We will diagnalize it and make it become a Rank-2 matrix so that it won't macth the pattern again.*)
(Cases[{xx},(FlatMetric->fm_)->fm,1]=!={Null})&&(ComponentRankNumber[Cases[{xx},(FlatMetric->fm_)->fm,1][[1]]]===1)&&
(*OrthonormalFrameFieldOperator shouldn't be Null. Its defualt value is Simplify. We will make it becomes Null at the end.*)
(Cases[{xx},(OrthonormalFrameFieldOperator->onffop_)->onffop,1]=!={Null})&&
(*TestOrthonormalFrameField should only be True or False. Its defualt value is False. We will make it becomes Null at the end.*)MatchQ[(Flatten[Cases[{xx},(TestOrthonormalFrameField->conff_)->conff,1]]),({True}|{False})])
]:=Module[{eigens,Flatmetric,g,ginv,d,rotm,valuesqrt,ONFFm,ONFFinvm,output,onff,invonff,idx,matrix,onffop,fm,cc,checkonff,tempm,ONFFt,ONFFinvt,\[Alpha],\[Mu],coord,onffidx,ONFFtidx,ONFFinvtidx,i},
(*Extract arguments*)
idx=Indices[{xx}];
matrix=TensorComponents[{xx}];
fm=Cases[{xx},(FlatMetric->cc_)->cc,\[Infinity]][[1]];
d=Length[fm];
onff=Cases[{xx},(OrthonormalFrameField->cc_)->cc,\[Infinity]][[1]];
invonff=Cases[{xx},(InverseOrthonormalFrameField->cc_)->cc,\[Infinity]][[1]];
onffop=Cases[{xx},(OrthonormalFrameFieldOperator->cc_)->cc,\[Infinity]][[1]];
checkonff=Cases[{xx},(TestOrthonormalFrameField->cc_)->cc,\[Infinity]][[1]];
coord=Coordinates[{xx}];
onffidx=Cases[{xx},(OrthonormalFrameFieldIndices->cc_)->cc,\[Infinity]][[1]];
(*If we have Subscript[g, ab], we should calculate g^ab. vice versa, if we have g^ab, we should calculate Subscript[g, ab]. it shares same operator w/ OrthonormalFrameField.*)
Which[MatchQ[idx,{SubMinus[_],SubMinus[_]}],g=matrix;ginv=(Inverse[matrix]//onffop),MatchQ[idx,{SuperMinus[_],SuperMinus[_]}],ginv=matrix;g=(Inverse[matrix]//onffop)];
(*DiagonalMatrix on FlatMetric*)
Flatmetric=DiagonalMatrix[fm];
Which[DiagonalMatrixQ[g],ONFFm=DiagonalMatrix[Table[(Sqrt[fm[[i]] g[[i,i]]](*//onffop*)),{i,1,d}]];
ONFFinvm=DiagonalMatrix[Table[(Sqrt[fm[[i]] ginv[[i,i]]](*//onffop*)),{i,1,d}]],(!DiagonalMatrixQ[g]),
Which[(onff===Null)&&(invonff===Null),
(*If user don't offer OrthonormalFrameField and InverseOrthonormalFrameField, we should use Eigensystem to calculate both of them.*)
	eigens=Eigensystem[g];
	rotm=Table[(Normalize[eigens[[2,i]]]//onffop),{i,1,d}];
	valuesqrt=(Sqrt[#]&/@(Flatmetric . eigens[[1]]))//onffop;
	ONFFm=(Table[valuesqrt[[i]] rotm[[i]],{i,1,d}]);
	ONFFinvm=Flatmetric . ONFFm . ginv,
(*If user offer at least one, we utilize it to get the other.*)
(onff=!=Null)&&(invonff===Null),
	ONFFm=onff;
(*Subscript[\[CurlyEpsilon], Overscript[a, ^]]^b=Subscript[\[Eta], ad]Subscript[\[CurlyEpsilon]^Overscript[d, ^], c]g^cb*)
	ONFFinvm=Flatmetric . onff . ginv,
(onff===Null)&&(invonff=!=Null),ONFFinvm=invonff;
(*Subscript[\[CurlyEpsilon]^Overscript[d, ^], c]=\[Eta]^daSubscript[\[CurlyEpsilon], Overscript[a, ^]]^bSubscript[g, bc]*)
	ONFFm=Flatmetric . invonff . g,
(*If user offer both of them, we use them.*)
(onff=!=Null)&&(invonff=!=Null),ONFFm=onff;ONFFinvm=invonff];
];
ONFFm=(ONFFm//onffop);
ONFFinvm=(ONFFinvm//onffop);
(*Declare OrthonormalFrameField as a Tensor object.*)
ONFFtidx=Which[(onffidx=!=Null)&&((Head[#]&/@onffidx)==={Symbol,Symbol}),{SuperMinus[\!\(\*OverscriptBox[\(onffidx\[LeftDoubleBracket]1\[RightDoubleBracket]\), \(^\)]\)],SubMinus[onffidx[[2]]]},True,{SuperMinus[\!\(\*OverscriptBox[\(\[Alpha]\), \(^\)]\)],SubMinus[\[Mu]]}];
ONFFinvtidx=Which[(onffidx=!=Null)&&((Head[#]&/@onffidx)==={Symbol,Symbol}),{SubMinus[(\!\(\*OverscriptBox[\(onffidx\[LeftDoubleBracket]1\[RightDoubleBracket]\), \(^\)]\))],SuperMinus[onffidx[[2]]]},True,{SubMinus[\!\(\*OverscriptBox[\(\[Alpha]\), \(^\)]\)],SuperMinus[\[Mu]]}];
(*ONFFt={
xx
}/.{(FlatMetric\[Rule]fm_)\[Rule](FlatMetric\[Rule]Flatmetric),(*(OrthonormalFrameField\[Rule]onf_)\[Rule]Nothing,(InverseOrthonormalFrameField\[Rule]ionf_)\[Rule]Nothing,(OrthonormalFrameFieldOperator\[Rule]oop_)\[Rule]Nothing,(TestOrthonormalFrameField\[Rule]conf_)\[Rule]Nothing,*)(TensorType\[Rule]tt_)\[Rule] Nothing,
(TensorName\[Rule]tn_)\[Rule](TensorName\[Rule]"\[CurlyEpsilon]") ,
(Indices\[Rule]idxx_)\[Rule] (Indices\[Rule]ONFFtidx),
(TensorComponents\[Rule]tc_)\[Rule] (TensorComponents\[Rule]ONFFm)(*,
(MetricDeterminant\[Rule]md_)\[Rule]Nothing ,
(ChristoffelComponents\[Rule]ccc_)\[Rule]Nothing ,
(RiemannComponents\[Rule]rc_)\[Rule]Nothing ,
(RicciComponents\[Rule]ric_)\[Rule]Nothing ,
(RicciScalarInvariant\[Rule]rsi_)\[Rule]Nothing ,
(OrthonormalFrameFieldIndices\[Rule]onffidxxx_)\[Rule]Nothing *)};*)
ONFFt={
xx
}/.{(FlatMetric->fm_)->Nothing,(OrthonormalFrameField->onf_)->Nothing,(InverseOrthonormalFrameField->ionf_)->Nothing,(OrthonormalFrameFieldOperator->oop_)->Nothing,(TestOrthonormalFrameField->conf_)->Nothing,(TensorType->tt_)-> Nothing,
(TensorName->tn_)->(TensorName->"\[CurlyEpsilon]") ,
(Indices->idxx_)-> (Indices->ONFFtidx),
(TensorComponents->tc_)-> (TensorComponents->ONFFm),
(MetricDeterminant->md_)->Nothing ,
(ChristoffelComponents->ccc_)->Nothing ,
(RiemannComponents->rc_)->Nothing ,
(RicciComponents->ric_)->Nothing ,
(RicciScalarInvariant->rsi_)->Nothing ,
(OrthonormalFrameFieldIndices->onffidxxx_)->Nothing };
ONFFinvt=ONFFt/.{(Indices->idxx_)-> (Indices->ONFFinvtidx),
(TensorComponents->tc_)-> (TensorComponents->ONFFinvm)
};
ONFFt=Apply[Tensor,ONFFt];
ONFFinvt=Apply[Tensor,ONFFinvt];
(*ONFFt=NonMetricTensor[ONFFtidx,
ONFFm,"\[CurlyEpsilon]",CoordinateSystem\[Rule]coord];
ONFFinvt=NonMetricTensor[ONFFinvtidx,
ONFFinvm,"\[CurlyEpsilon]",CoordinateSystem\[Rule]coord];*)
(*Replace w/ calculation result.*)
tempm=ReleaseHold[(*Hold first and replace. To avoid trigger initial pattern and create infinte loop.*)Hold[Tensor[
xx
]]/.{(FlatMetric->fm_)->(FlatMetric->Flatmetric),(OrthonormalFrameField->onf_)->(OrthonormalFrameField->ONFFt),(InverseOrthonormalFrameField->ionf_)->(InverseOrthonormalFrameField->ONFFinvt),(OrthonormalFrameFieldOperator->oop_)->(OrthonormalFrameFieldOperator->Null),(TestOrthonormalFrameField->conf_)->(TestOrthonormalFrameField->Null)}];
output={ONFFt,ONFFinvt,tempm};
Which[checkonff===True,output=Append[Append[output,
(*Subscript[g, cd]=Subscript[\[CurlyEpsilon]^Overscript[a, ^], c]Subscript[\[Eta], ab]Subscript[\[CurlyEpsilon]^Overscript[b, ^], d]*)
(Transpose[ONFFm] . Flatmetric . ONFFm==g)//onffop],
(*Subscript[\[Eta], cd]=Subscript[\[CurlyEpsilon], Overscript[c, ^]]^aSubscript[g, ab]Subscript[\[CurlyEpsilon], Overscript[d, ^]]^b*)
((ONFFinvm . g . Transpose[ONFFinvm]==Flatmetric)//onffop)]];
output
];

(*Abondoned code: Start*)
(*Bad pattern matching slow down dramatically.*)
(*Tensor[
xx___,
Indices\[Rule]idx_,
TensorComponents\[Rule]matrix_,
TensorType\[Rule]"Metric",
ChristoffelComponents\[Rule]cc_,
FlatMetric\[Rule]fm_/;((fm=!=Null)&&(ComponentRankNumber[fm]===1)),
OrthonormalFrameField\[Rule]Null,
InverseOrthonormalFrameField\[Rule]Null,
(*OrthonormalFrameField\[Rule]onff_/;(onff===Null),
InverseOrthonormalFrameField\[Rule]invonff_/;(invonff===Null),*)
OrthonormalFrameFieldOperator\[Rule]onffop_/;(onffop=!=Null),
TestOrthonormalFrameField\[Rule]checkonff_/;(MatchQ[checkonff,(True|False)])
]:=Module[{eigens,Flatmetric,g,ginv,d,rotm,valuesqrt,ONFFm,ONFFinvm,output},Which[MatchQ[idx,{SubMinus[_],SubMinus[_]}],g=matrix;ginv=(Inverse[matrix]//onffop),MatchQ[idx,{SuperMinus[_],SuperMinus[_]}],ginv=matrix;g=(Inverse[matrix]//onffop)];
Flatmetric=DiagonalMatrix[fm];
eigens=Eigensystem[g];
d=Length[fm];
rotm=Table[(Normalize[eigens\[LeftDoubleBracket]2,i\[RightDoubleBracket]]//onffop),{i,1,d}];
valuesqrt=(Sqrt[#]&/@(Flatmetric.eigens\[LeftDoubleBracket]1\[RightDoubleBracket]))//onffop;
ONFFm=(Table[valuesqrt\[LeftDoubleBracket]i\[RightDoubleBracket] rotm\[LeftDoubleBracket]i\[RightDoubleBracket],{i,1,d}]//onffop);
ONFFinvm=Flatmetric.ONFFm.ginv;
output={ONFFm,ONFFinvm,Tensor[
xx,
Indices\[Rule]idx,
TensorComponents\[Rule]matrix,
TensorType\[Rule]"Metric",
ChristoffelComponents\[Rule]cc,
(*FlatMetric\[Rule]fm,*)
FlatMetric\[Rule]Flatmetric,
OrthonormalFrameField\[Rule]ONFFm,
InverseOrthonormalFrameField\[Rule]ONFFinvm,
OrthonormalFrameFieldOperator\[Rule]Null,
TestOrthonormalFrameField\[Rule]Null
]};
Which[checkonff===True,output=Append[Append[output,(Transpose[ONFFm].Flatmetric.ONFFm\[Equal]g)//onffop],(ONFFm.ginv.Transpose[ONFFm]\[Equal]Flatmetric)//onffop]];
output
];*)
(*
Tensor[
xx___,
Indices\[Rule]idx_,
TensorComponents\[Rule]matrix_,
TensorType\[Rule]"Metric",
ChristoffelComponents\[Rule]cc_,
FlatMetric\[Rule]fm_/;((fm=!=Null)&&(ComponentRankNumber[fm]===1)),
OrthonormalFrameField\[Rule]onff_,
InverseOrthonormalFrameField\[Rule]invonff_,
OrthonormalFrameFieldOperator\[Rule]onffop_,
TestOrthonormalFrameField\[Rule]checkonff_/;(MatchQ[checkonff,(True|False)])
]:=Module[{Flatmetric,g,ginv,rotm,valuesqrt,ONFFm,ONFFinvm,output},Which[MatchQ[idx,{SubMinus[_],SubMinus[_]}],g=matrix;ginv=(Inverse[matrix]//onffop),MatchQ[idx,{SuperMinus[_],SuperMinus[_]}],ginv=matrix;g=(Inverse[matrix]//onffop)];
Flatmetric=DiagonalMatrix[fm];
Which[(onff=!=Null)&&(invonff===Null),ONFFm=onff;
ONFFinvm=Flatmetric.onff.ginv,(onff===Null)&&(invonff=!=Null),ONFFinvm=invonff;
ONFFm=Flatmetric.invonff.g,(onff=!=Null)&&(invonff=!=Null),ONFFm=onff;ONFFinvm=invonff];
output={ONFFm,ONFFinvm,Tensor[
xx,
Indices\[Rule]idx,
TensorComponents\[Rule]matrix,
TensorType\[Rule]"Metric",
ChristoffelComponents\[Rule]cc,
FlatMetric\[Rule]Flatmetric,
OrthonormalFrameField\[Rule]ONFFm,
InverseOrthonormalFrameField\[Rule]ONFFinvm,
OrthonormalFrameFieldOperator\[Rule]Null,
TestOrthonormalFrameField\[Rule]Null
]};Which[checkonff===True,output=Append[Append[output,(Transpose[ONFFm].Flatmetric.ONFFm\[Equal]g)//onffop],(ONFFm.ginv.Transpose[ONFFm]\[Equal]Flatmetric)//onffop]];
output
]/;(!((onffop===Null)&&(invonff===Null)));*)
(*Abondoned code: End*)


(* ::Input::Initialization:: *)
(* Series expansion on geometric quantities; Normal is applied to get rid of the O sign *)
(* Need to remember to apply Series on Tooltipdisplay stuff too. *)
(* Metric related *)
Tensor/:Series[Tensor[
xx___,
TensorType->"Metric",
TensorComponents->matrix_,
MetricDeterminant->Detg_,
ChristoffelComponents->ChrisRules_,
RiemannComponents->RiemRules_,
RicciComponents->RicRules_,
RicciScalarInvariant->RRule_,
OrthonormalFrameField->onffuser_,
InverseOrthonormalFrameField->invonffuser_
],\[Epsilon]__List]:=Tensor[
xx,
TensorType->"Metric",
TensorComponents->Normal[Series[matrix,\[Epsilon]]],
MetricDeterminant->Normal[Series[Detg,\[Epsilon]]],
ChristoffelComponents->ChrisRules/.(ChristoffelComponents[chx__]->rhs_):>(ChristoffelComponents[chx]->Normal[Series[rhs,\[Epsilon]]]),
RiemannComponents->RiemRules/.(RiemannComponents[riex__]->rhs_):>(RiemannComponents[riex]->Normal[Series[rhs,\[Epsilon]]]),
RicciComponents->RicRules/.(RicciComponents[ricx__]->rhs_):>(RicciComponents[ricx]->Normal[Series[rhs,\[Epsilon]]]),
RicciScalarInvariant->RRule/.(RicciScalar->rhs_):>(RicciScalar->Normal[Series[rhs,\[Epsilon]]]),OrthonormalFrameField->Normal[Series[onffuser,\[Epsilon]]],
InverseOrthonormalFrameField->Normal[Series[invonffuser,\[Epsilon]]]
];
(* Non-Metric, Does not contain TooltipDisplay *)
(*Tensor/:Series[Tensor[
xx___/;(Cases[{xx},TooltipDisplay,\[Infinity]]==={}),
TensorType\[Rule]type_/;type=!="Metric",
TensorComponents\[Rule]matrix_
],\[Epsilon]__List]:=Tensor[
xx,
TensorType\[Rule]type,
TensorComponents\[Rule]Normal[Series[matrix,\[Epsilon]]]
];
(* Non-Metric, Contains TooltipDisplay *)
Tensor/:Series[Tensor[
xx___,
TensorType\[Rule]type_/;type=!="Metric",
TensorComponents\[Rule]matrix_,
TooltipDisplay\[Rule]disp_
],\[Epsilon]__List]:=Module[{},
Tensor[
xx,
TensorType\[Rule]type,
TensorComponents\[Rule]Normal[Series[matrix,\[Epsilon]]],
TooltipDisplay\[Rule](disp/.Rule[lhs_,rhs_]\[RuleDelayed]Rule[lhs,Normal[Series[rhs,\[Epsilon]]]])
]
];*)

(* Series expansion on geometric quantities; Normal is applied to get rid of the O sign *)
(* Need to remember to apply Series on Tooltipdisplay stuff too. *)
(* Metric related *)
(*Tensor/:Series[t_Tensor/;(Cases[t,TensorType,\[Infinity]]==={"Metric"}),\[Epsilon]__List]:=(t/.{((TensorComponents\[Rule]matrix_)\[RuleDelayed](TensorComponents\[Rule]Normal[Series[matrix,\[Epsilon]]])),(MetricDeterminant\[Rule]Detg_)\[RuleDelayed](MetricDeterminant\[Rule]Normal[Series[Detg,\[Epsilon]]]),((ChristoffelComponents\[Rule]ChrisRules_)\[RuleDelayed](ChristoffelComponents\[Rule](ChrisRules/.((ChristoffelComponents[chx__]\[Rule]rhs_)\[RuleDelayed](ChristoffelComponents[chx]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RiemannComponents\[Rule]RiemRules_)\[RuleDelayed](RiemannComponents\[Rule](RiemRules/.((RiemannComponents[riex__]\[Rule]rhs_)\[RuleDelayed](ChristoffelComponents[riex]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RicciComponents\[Rule]RicRules_)\[RuleDelayed](RicciComponents\[Rule](RicRules/.((RicciComponents[ricx__]\[Rule]rhs_)\[RuleDelayed](RicciComponents[ricx]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RicciScalarInvariant\[Rule]RRule_)\[RuleDelayed](RicciScalarInvariant\[Rule](RRule/.((RicciScalar\[Rule]rhs_)\[RuleDelayed](RicciScalar\[Rule]Normal[Series[rhs,\[Epsilon]]])))))
});*)

(*Tensor/:Series[t_Tensor/;(Cases[t,TensorType,\[Infinity]]==={"Metric"}),\[Epsilon]__List]:=Module[{matrix=Cases[t,TensorComponents,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],Detg=Cases[t,MetricDeterminant,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],ChrisRules=Cases[t,ChristoffelComponents,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],RiemRules=Cases[t,RiemannComponents,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],RicRules=Cases[t,RicciComponents,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],RRule=Cases[t,RicciScalarInvariant,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]},(t/.{((TensorComponents\[Rule]a_)\[Rule] (TensorComponents\[Rule]Normal[Series[matrix,\[Epsilon]]])),(MetricDeterminant\[Rule]b_)\[Rule] (MetricDeterminant\[Rule]Normal[Series[Detg,\[Epsilon]]]),((ChristoffelComponents\[Rule]c_)\[Rule] (ChristoffelComponents\[Rule](ChrisRules/.((ChristoffelComponents[chx__]\[Rule]rhs_)\[RuleDelayed](ChristoffelComponents[chx]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RiemannComponents\[Rule]d_)\[Rule] (RiemannComponents\[Rule](RiemRules/.((RiemannComponents[riex__]\[Rule]rhs_)\[RuleDelayed](ChristoffelComponents[riex]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RicciComponents\[Rule]e_)\[Rule] (RicciComponents\[Rule](RicRules/.((RicciComponents[ricx__]\[Rule]rhs_)\[RuleDelayed](RicciComponents[ricx]\[Rule]Normal[Series[rhs,\[Epsilon]]]))))),((RicciScalarInvariant\[Rule]f_)\[Rule] (RicciScalarInvariant\[Rule](RRule/.((RicciScalar\[Rule]rhs_)\[RuleDelayed](RicciScalar\[Rule]Normal[Series[rhs,\[Epsilon]]])))))
})];*)
(* Non-Metric, Does not contain TooltipDisplay *)
(*NewCode: TagSetDelay w/t_Tensor*)
(*NewCode: ExtractFunctions*)
Tensor/:Series[t_Tensor/;((TooltipDisplayNoPart[t]==={})&&(TensorTypeNoPart[t]=!={"Metric"})),\[Epsilon]__List]:=t/.{((TensorComponents->mx_):>(TensorComponents->Normal[Series[mx,\[Epsilon]]]))};

(* Non-Metric, Contains TooltipDisplay *)
Tensor/:Series[t_Tensor/;((TooltipDisplayNoPart[t]=!={})&&(TensorTypeNoPart[t]=!={"Metric"})),\[Epsilon]__List]:=t/.{(TensorComponents->mx_):>(TensorComponents->Normal[Series[mx,\[Epsilon]]]),
(TooltipDisplay->disp_):>(TooltipDisplay->(disp/.(Rule[lhs_,rhs_]:>Rule[lhs,Normal[Series[rhs,\[Epsilon]]]])))};


(* ::Input::Initialization:: *)
(* Dimensions of Tensors *)
(*NewCode: TagSetDelay w/t_Tensor*)
Tensor/:Dimensions[t_Tensor]:=Dimensions[TensorComponents[t]];


(* ::Input::Initialization:: *)
Tensor/:Normal[t_Tensor]:=t/.{(TensorComponents-> comp_):> (TensorComponents-> Normal[comp])};


(* ::Input::Initialization:: *)
Tensor/:Conjugate[t_Tensor]:=t/.{(TensorComponents-> comp_):> (TensorComponents-> Conjugate[comp]),(TensorName-> name_):> (TensorName->Which[(Head[name]===OverBar),name[[1]],True, OverBar[name]])};


(* ::Input::Initialization:: *)
(*D*)
(*NewCode: Derivative for Tensor*)
Tensor/:PD[
t_Tensor(*/;((TensorComponentsNoPart[t]=!={})&&(TensorNameNoPart[t]=!={}))*)
,stuff_(*/;This check is for not to conflict w/ short-hand of PartialD.*)(*!(Head[stuff]===SubMinus)*)]:=(*re-declare a new Tensor w/ add "\[PartialD]" in front if TensorName and take a derivative on all the TensorComponents.*)t/.{
(TensorName->tc_)->(TensorName->Subscript["\[PartialD]",stuff][TensorName[t]]),
(TensorComponents->cc_)->(TensorComponents->D[TensorComponents[t],stuff])};
(*Abondoned code: Start*)

(*Tensor/:PD[Tensor[
xx___/;((Cases[{xx},(TensorComponents\[Rule]cc_)\[Rule]cc,\[Infinity]]=!={})&&(Cases[{xx},(TensorName\[Rule]cc_)\[Rule]cc,\[Infinity]]=!={}))
],stuff_/;(*This check is for not to conflict w/ short-hand of PartialD*)!(Head[stuff]===SubMinus)]:=(*re-declare a new Tensor w/ add "\[PartialD]" in front if TensorName and take a derivative on all the TensorComponents.*)Tensor[
xx
]/.{
(TensorName\[Rule]tc_)\[Rule](TensorName\[Rule]Subscript["\[PartialD]",stuff][Cases[{xx},(TensorName\[Rule]cc_)\[Rule]cc,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]]),
(TensorComponents\[Rule]cc_)\[Rule](TensorComponents\[Rule]D[Cases[{xx},(TensorComponents\[Rule]cc_)\[Rule]cc,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],stuff])};*)

(*See also: Short-hand for PartialD*)
(*Tensor/:D[Tensor[
xx___,
TensorComponents\[Rule]matrix_,
TensorName\[Rule]nnn_
],stuff_/;(*This check is for not to conflict w/ short-hand of PartialD*)!(Head[stuff]===SubMinus)]:=(*re-declare a new Tensor w/ add "\[PartialD]" in front if TensorName and take a derivative on all the TensorComponents.*)Tensor[
xx,
TensorName\[Rule]Subscript["\[PartialD]",stuff][nnn],
TensorComponents\[Rule]D[matrix,stuff]
];*)

(*Tensor/:D[Tensor[
xx___,
TensorComponents\[Rule]matrix_,
TensorName\[Rule]nnn_
],stuff_/;(*This check is for not to conflict w/ short-hand of PartialD*)!(Head[stuff]===SubMinus)]:=(*re-declare a new Tensor w/ add "\[PartialD]" in front if TensorName and take a derivative on all the TensorComponents.*)Module[{},
Print["D"];
Tensor[
xx,
TensorName\[Rule]Subscript["\[PartialD]",stuff][nnn],
TensorComponents\[Rule]D[matrix,stuff]
]];*)

(*Tensor/:D[Tensor[
xx___,
TensorComponents\[Rule]matrix_,
TensorName\[Rule]nnn_,
TooltipDisplay\[Rule]disp_/;(MatchQ[disp,{Repeated[Rule[_,_]]}])
],stuff_Symbol]:=Module[{newdisp},
newdisp=(disp/.Rule[lhs_(*Row[__]*),rhs_]\[RuleDelayed]Rule[Row[{Subscript["\[PartialD]",stuff],lhs}],D[rhs,stuff]]);
newdisp=Select[newdisp,(Flatten[Cases[{#},(Row[__]\[Rule]cc_)\[Rule]cc]]\[LeftDoubleBracket]1\[RightDoubleBracket]=!=0)&];
Tensor[
xx,
TensorName\[Rule]Subscript["\[PartialD]",stuff][nnn],
TensorComponents\[Rule]D[matrix,stuff],
TooltipDisplay\[Rule]newdisp
]
];*)
(*Abondoned code: End*)

(*Tensor/:D[Tensor[stuff___],\[Mu]T_Symbol]:=PD[Tensor[stuff],\[Mu]T]*)


(* ::Input::Initialization:: *)
Tensor/:Simplify[t_Tensor(*(t_/;((Head[t]===Tensor)||TestTensorTensor[t]||!TestExpressionForm[t]))*)]:=
Module[{TA=TensorAssumption[t]},
(*Which[(TA==={}),t/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule] Simplify[comp])},(TA=!={}),t/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule] Simplify[comp,TA])}]*)
Simplify[t,TA]
];


(* ::Input::Initialization:: *)
Tensor/:FullSimplify[t_Tensor]:=
Module[{TA=TensorAssumption[t]},
(*Which[(TA==={}),t/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule] FullSimplify[comp])},(TA=!={}),t/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule] FullSimplify[comp,TA])}]*)
FullSimplify[t,TA]
];


(* ::Input::Initialization:: *)
(*NewCode: TensorSymmetry*)
(* TensorSymmetry of Tensors *)
Tensor/:TensorSymmetry[t_Tensor]:=Module[{ts},ts=TensorSymmetry[TensorComponents[t]];
Which[(Cases[t,(TensorSymmetry->tss_)->tss]==={}),{ts,Append[t,TensorSymmetry->ts]},True,{ts,t/.(TensorSymmetry->oldts_)->(TensorSymmetry->ts)}]]


(*(*NewCode: TensorSymmetry*)
(* TensorSymmetry of Tensors *)
Tensor/:TensorSymmetry[t_Tensor]:=Module[{ts,indices,newts,lgth},ts=TensorSymmetry[TensorComponents[t]];
(*We should remove those under bar square/curly bracket in the indices list first.*)indices=RemoveUnderBarredIndices[Indices[t]];
(*Convert MMA output in our prefer way.*)
(*To understand this block, you can refer to Wei-Hao's notebook.*)
Which[Head[ts]===ZeroSymmetric,newts="Zero Tensor",ts==={},newts="No Symmetry",Head[ts]===Antisymmetric,newts=Antisymmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@ts\[LeftDoubleBracket]1\[RightDoubleBracket]],Head[ts]===Symmetric,newts=Symmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@ts\[LeftDoubleBracket]1\[RightDoubleBracket]],Cases[ts,Cycles[_List],Infinity]\[NotEqual]{},lgth=Length[ts];newts=Table[Which[Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]===1&&ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]===-1,Antisymmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@Flatten[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]],Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]===1&&ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]===1,Symmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@Flatten[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]],Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]\[NotEqual]1&&ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]===-1,Antisymmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]],Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]\[NotEqual]1&&ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]===1,Symmetric[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]],((ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]=!=+1||ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]=!=-1)&&((ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket] Conjugate[ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket] ])===1)&&(Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]===1)),newts={Cycles[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@Flatten[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]],ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]},((ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]=!=+1||ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]=!=-1)&&((ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket] Conjugate[ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket] ])===1)&&(Length[ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]]!=1)),newts={Cycles[indices\[LeftDoubleBracket]#\[RightDoubleBracket]&/@ts\[LeftDoubleBracket]ii,1,1\[RightDoubleBracket]],ts\[LeftDoubleBracket]ii,2\[RightDoubleBracket]}],{ii,1,lgth}]];
(*If there is no TensorSymmetry in original Tensor, Append one. If there is, replace to be the new one.*)
(*The output will be a "Timing" function like List. User can directly see the symmetry property in part one of the List. They can also extract the tensor w/TensorSymmetry by using part 2.*)
Which[(Cases[t,(TensorSymmetry\[Rule]ts_)\[Rule]ts]==={}),{newts,Append[t,TensorSymmetry\[Rule]newts]},True,{newts,t/.(TensorSymmetry\[Rule]oldts_)\[Rule](TensorSymmetry\[Rule]newts)}]]*)


(* ::Input::Initialization:: *)
(* Evaluating abstract indices at specific coordinates/values *)
(* IofII: If all Indices are either Integers or Coordinates we return the component *)
(* we need to include the possibility that there may be an UnderBar applied to some of the indices *)
(* No UnderBarred Indices *)
Tensor[
xxx___,
CoordinateSystem->cooo_List,
StartIndex->si_Integer,
Indices->\[Mu]T_List,
TensorComponents->matrix_
]:=matrix[[Sequence@@((NumericIndex[#,cooo,si][[1]]-si+1)&/@\[Mu]T)]]/;(Union[NotAbstractIndex[#,cooo,si]&/@\[Mu]T]==={True});
(* If there are more than 1 UnderBarred Indices and all Indices are not abstract then all those indices not UnderBarred are subject to the operations in IIofII below, until all indices are UnderBarred *)
(* So what remains is to deal with a Tensor with all UnderBarred Indices *)
(* All UnderBarred Indices *)
(*NewCode: Redundant TagSetDelay*)
Tensor[
xxx___,
CoordinateSystem->cooo_List,
StartIndex->si_Integer,
Indices->\[Mu]T_List/;MatchQ[\[Mu]T,{(SuperMinus|SubMinus)[UnderBar[_]]..}],
TensorComponents->matrix_
]:=(* if all Indices are UnderBarred there should be only one component *)Which[Head[matrix]===List,matrix[[1]],True,matrix]/;(((* first remove repeated indices then remove all UnderBar's to first check no indices are abstract ones *)Union[NotAbstractIndex[#/.UnderBar[aa_]->aa,cooo,si]&/@RemoveUnderBarredIndices[\[Mu]T]]==={True})||(RemoveUnderBarredIndices[\[Mu]T]==={}));
(* IIofII: If one or more Indices -- but not all of them -- are Integer or coordinates we reduce the rank of the Tensor accordingly *)
(*NewCode: Redundant TagSetDelay*)
Tensor[
xxx___,
CoordinateSystem->cooo_List,
StartIndex->si_Integer,
Indices->{i1___,\[Mu]T_,i2___},
TensorComponents->matrix_
]:=Module[{mtx,ni,VectorJ,ix,leftidx},
(* contract with Subscript[\[Delta]^\[Mu], ni] or Subscript[\[Delta], \[Mu] ni] *)
ni=NumericIndex[\[Mu]T,cooo,si][[1]];
(* Subscript[\[Delta]^\[Mu], ni] or Subscript[\[Delta], \[Mu] ni] *)
VectorJ=Table[Which[ni===ix,1,True,0],{ix,si,Length[cooo]+si-1}];
(* we are going to contract Tensor with Subscript[\[Delta]^\[Mu], ni] or Subscript[\[Delta], \[Mu] ni] *)
mtx=TensorProduct[VectorJ,matrix];
(* ... do not include indices that do not pass TestIndices ensuring that sequential Tensor reduction is OK -- i.e., no infinite recursion occurs -- as long as the UnderBar is applied to the said index after TensorContract is applied *)
leftidx=DeleteCases[{i1},xx_/;TestIndices[xx]===False];
mtx=TensorContract[mtx,{{1,Length[leftidx]+2}}];
(* return the Tensor w/ everything the same except the TensorComponents and the index \[Mu]T *)
Tensor[
xxx,
CoordinateSystem->cooo,
StartIndex->si,
Indices->{i1,UnderBar/@\[Mu]T,i2},
TensorComponents->mtx
]
]/;(TestIndices[\[Mu]T]&&(* check the index is not abstract *)NotAbstractIndex[\[Mu]T,cooo,si]);


(* ::Input::Initialization:: *)
(* Einstein summation: Repeated indices are summed over *)
(* w/ Tooltipdisplay*)
Tensor[
xxx___,
TooltipDisplay->ttdd_,
CoordinateSystem->cooo_List,
StartIndex->si_Integer,
Indices->{i1___,\[Mu]1T_,i2___,\[Mu]2T_,i3___},
TensorComponents->matrix_
]:=Module[{mtx,MJ,ix1,ix2,leftidx1,leftidx2},
(* Remember to remove underbarred indices because they are no longer part of the active index structue *)
mtx=TensorContract[matrix,{{Length[RemoveUnderBarredIndices[{i1}]]+1,Length[RemoveUnderBarredIndices[{i1}]]+1+Length[RemoveUnderBarredIndices[{i2}]]+1}}];
(* return the Tensor w/ everything the same except the TensorComponents and the indics \[Mu]1T and \[Mu]2T *)
Tensor[
xxx,
CoordinateSystem->cooo,
StartIndex->si,
Indices->{i1,UnderBar/@\[Mu]1T,i2,UnderBar/@\[Mu]2T,i3},
TensorComponents->mtx,
TooltipDisplay->Which[Cases[ttdd,matrix,\[Infinity]]==={},ttdd,True,ttdd/.matrix->mtx]]]/;(((* check repeated indices *)\[Mu]1T[[1]]===\[Mu]2T[[1]])&&((* check one index up and one down *)Sgn[\[Mu]1T]Sgn[\[Mu]2T]===-1)&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]1T,cooo,si])&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]2T,cooo,si])&&TestIndices[\[Mu]1T]&&TestIndices[\[Mu]2T]);
(* w/o Tooltipdisplay*)
Tensor[
xxx___/;Union[Flatten[TooltipDisplayNoPart[{xxx}]]]==={},
CoordinateSystem->cooo_List,
StartIndex->si_Integer,
Indices->{i1___,\[Mu]1T_,i2___,\[Mu]2T_,i3___},
TensorComponents->matrix_
]:=Module[{mtx,MJ,ix1,ix2,leftidx1,leftidx2},
(* Remember to remove underbarred indices because they are no longer part of the active index structue *)
mtx=TensorContract[matrix,{{Length[RemoveUnderBarredIndices[{i1}]]+1,Length[RemoveUnderBarredIndices[{i1}]]+1+Length[RemoveUnderBarredIndices[{i2}]]+1}}];
(* return the Tensor w/ everything the same except the TensorComponents and the indics \[Mu]1T and \[Mu]2T *)
Tensor[
xxx,
CoordinateSystem->cooo,
StartIndex->si,
Indices->{i1,UnderBar/@\[Mu]1T,i2,UnderBar/@\[Mu]2T,i3},
TensorComponents->mtx]]/;(((* check repeated indices *)\[Mu]1T[[1]]===\[Mu]2T[[1]])&&((* check one index up and one down *)Sgn[\[Mu]1T]Sgn[\[Mu]2T]===-1)&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]1T,cooo,si])&&((* check that both indices are abstract *)!NotAbstractIndex[\[Mu]2T,cooo,si])&&TestIndices[\[Mu]1T]&&TestIndices[\[Mu]2T]);


(* ::Input::Initialization:: *)
(* Appearance of Metric Tensor *)
(* Jan 2014: we have decided to display the metric as any other rank 2 tensor i.e. Subscript[g, \[Mu]\[Nu]] or g^\[Mu]\[Nu] or Subscript[\[Delta]^\[Mu], \[Nu]] (if TensorName is g). TensorComponents are displayed by hovering mouse cursor over Subscript[g, \[Mu]\[Nu]]. *)
(* Tensor/:Format[Tensor[
TensorType\[Rule]"Metric",
TensorName\[Rule]name_,
StartIndex\[Rule]si_Integer(*/;si\[GreaterEqual]0*),
Indices\[Rule]{\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T]},
CoordinateSystem\[Rule]coords_,
TensorComponents\[Rule]matrix_,
ChristoffelComponents\[Rule]ChrisRules_,
RiemannComponents\[Rule]RiemRules_,
RicciComponents\[Rule]RicRules_,
RicciScalarInvariant\[Rule]RRules_,
xx___
]]:=Tensor[
xx,
"Coordinates"\[Rule]coords,
Row[{name,UpOrDown[\[Mu]T],UpOrDown[\[Nu]T]}]\[Rule]matrix,
StartIndex\[Rule]si,
(ChrisRules/.{ChristoffelComponents[SuperMinus[\[Mu]s_],SubMinus[\[Alpha]s_],SubMinus[\[Beta]s_]]\[RuleDelayed]Row[{"\[CapitalGamma]",Column[{coords\[LeftDoubleBracket]\[Mu]s-si+1\[RightDoubleBracket],Null}],Column[{Null,coords\[LeftDoubleBracket]\[Alpha]s-si+1\[RightDoubleBracket]}],Column[{Null,coords\[LeftDoubleBracket]\[Beta]s-si+1\[RightDoubleBracket]}]}]}),
(RiemRules/.{RiemannComponents[SuperMinus[\[Mu]s_],SubMinus[\[Nu]s_],SubMinus[\[Alpha]s_],SubMinus[\[Beta]s_]]\[RuleDelayed]Row[{"R",Column[{coords\[LeftDoubleBracket]\[Mu]s-si+1\[RightDoubleBracket],Null}],Column[{Null,coords\[LeftDoubleBracket]\[Nu]s-si+1\[RightDoubleBracket]}],Column[{Null,coords\[LeftDoubleBracket]\[Alpha]s-si+1\[RightDoubleBracket]}],Column[{Null,coords\[LeftDoubleBracket]\[Beta]s-si+1\[RightDoubleBracket]}]}]}),
RicRules/.{RicciComponents[SubMinus[\[Nu]s_],SubMinus[\[Beta]s_]]\[RuleDelayed]Row[{"R",Column[{Null,coords\[LeftDoubleBracket]\[Nu]s-si+1\[RightDoubleBracket]}],Column[{Null,coords\[LeftDoubleBracket]\[Beta]s-si+1\[RightDoubleBracket]}]}]},
RRules/.{RicciScalar\[Rule]"R"}
]; *)


(* ::Input::Initialization:: *)
(* Format: *)
(* we display the TensorName and associated indices *)
(* w/ TooltipDisplay *)
(*NewCode: Redundant TagSetDelay*)
(*NewCode: ExtractFunctions*)
Format[Tensor[
xxx___,
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName->name_,
Indices->\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TooltipDisplay->display_/;(display=!=Null)(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(display=!=TensorComponents)
]]:=
(*NewCode: TooltipStyle*)Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],Which[Head[display]===List,Flatten[display],True,display],Sequence@@Which[((TooltipStyleNoPart[{xxx}])==={}),{},((TooltipStyleNoPart[{xxx}])=!={}),{TooltipStyle->(TooltipStyle[{xxx}])}]]

(*/;(Cases[{name},Del[_],\[Infinity]]==={})*)
(* w/o TooltipDisplay I of II *)
(* Scalars, vectors and rank-2 tensors *)
(*NewCode: Redundant TagSetDelay*)
(*NewCode: ExtractFunctions*)
Format[Tensor[
xxx___/;(*NewCode: Delete Redundent Union*)(((Flatten[TooltipDisplayNoPart[{xxx}]]==={})||(Flatten[TooltipDisplayNoPart[{xxx}]]==={Null}))(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(TooltipDisplayNoPart[{xxx}]=!={TensorComponents}))(*&&((Union[Flatten[Cases[{xxx},TensorSymmetry\[Rule]ts_,\[Infinity]]]]==={})||(Union[Flatten[Cases[{xxx},(TensorSymmetry\[Rule]ts_)\[Rule]ts,\[Infinity]]]]==={Null}))*),
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName->name_,
Indices->\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents->ttM_,
CoordinateSystem->coords_List
]/;((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=(*NewCode: TooltipStyle*)Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],{MatrixForm[ttM],"Coordinates"->coords},Sequence@@Which[((TooltipStyleNoPart[{xxx}])==={}),{},(TooltipStyleNoPart[{xxx}])=!={},{TooltipStyle->(TooltipStyle[{xxx}])}]]
(* w/o TooltipDisplay II of II *)
(* everything else *)
(*NewCode: Redundant TagSetDelay*)
(*NewCode: ExtractFunctions*)
Format[Tensor[
xxx___/;((Flatten[TooltipDisplayNoPart[{xxx}]]==={})||(Flatten[TooltipDisplayNoPart[{xxx}]]==={Null})(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(TooltipDisplayNoPart[{xxx}]=!={TensorComponents})),
TensorName->name_,
Indices->\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents->ttM_,
CoordinateSystem->coords_List
]/;!((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}];

(*NewCode: TooltipDisplay\[Rule]TensorComponents*)
(*NewCode: ExtractFunctions*)
Format[
Tensor[
xxx___(*/;(Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]==={TensorComponents})*),
TooltipDisplay->TensorComponents,
TensorName->name_,
Indices->\[Mu]T_List,
TensorComponents->ttM_,
CoordinateSystem->coords_List
]]:=
Which[(Flatten[TooltipStyleNoPart[{xxx}]]==={}),
Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],NonZeroTensorComponents[name,
\[Mu]T,
ttM,
coords]],
(Flatten[TooltipStyleNoPart[{xxx}]]=!={}),
Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],NonZeroTensorComponents[name,
\[Mu]T,
ttM,
coords],TooltipStyle->TooltipStyle[{xxx}]]
];

(*Abondoned code: Start*)
(*(* Format: *)
(* we display the TensorName and associated indices *)
(* w/ TooltipDisplay *)
(*NewCode: Redundant TagSetDelay*)

Format[Tensor[
xxx___,
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TooltipDisplay\[Rule]display_/;(display=!=Null)(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(display=!=TensorComponents)
]]:=
(*NewCode: TooltipStyle*)Module[{ttstyle},ttstyle=Flatten[Cases[{xxx},(TooltipStyle\[Rule]tt_)\[Rule]tt,\[Infinity]]];Which[(ttstyle==={}),Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],Which[Head[display]===List,Flatten[display],True,display]],(ttstyle=!={}),Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],Which[Head[display]===List,Flatten[display],True,display],TooltipStyle\[Rule]ttstyle]]]

(*/;(Cases[{name},Del[_],\[Infinity]]==={})*)
(* w/o TooltipDisplay I of II *)
(* Scalars, vectors and rank-2 tensors *)
(*NewCode: Redundant TagSetDelay*)
Format[Tensor[
xxx___/;(*NewCode: Delete Redundent Union*)(((Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]==={})||(Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]==={Null}))(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]=!=TensorComponents))(*&&((Union[Flatten[Cases[{xxx},TensorSymmetry\[Rule]ts_,\[Infinity]]]]==={})||(Union[Flatten[Cases[{xxx},(TensorSymmetry\[Rule]ts_)\[Rule]ts,\[Infinity]]]]==={Null}))*),
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents\[Rule]ttM_,
CoordinateSystem\[Rule]coords_List
]/;((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=(*NewCode: TooltipStyle*)Module[{ttstyle},ttstyle=Flatten[Cases[{xxx},(TooltipStyle\[Rule]tt_)\[Rule]tt,\[Infinity]]];Which[(ttstyle==={}),Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],{MatrixForm[ttM],"Coordinates"\[Rule]coords}],(ttstyle=!={}),Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],{MatrixForm[ttM],"Coordinates"\[Rule]coords},TooltipStyle\[Rule]ttstyle]]]

(* w/o TooltipDisplay II of II *)
(* everything else *)
(*NewCode: Redundant TagSetDelay*)
Format[Tensor[
xxx___/;(((Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]==={})||(Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]==={Null}))(*NewCode: TooltipDisplay\[Rule]TensorComponents*)&&(Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]=!=TensorComponents))(*&&((Union[Flatten[Cases[{xxx},TensorSymmetry\[Rule]ts_,\[Infinity]]]]==={})||(Union[Flatten[Cases[{xxx},(TensorSymmetry\[Rule]ts_)\[Rule]ts,\[Infinity]]]]==={Null}))*),
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents\[Rule]ttM_,
CoordinateSystem\[Rule]coords_List
]/;!((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}];*)
(*Abondoned code: End*)

(*Abondoned code: Start*)
(*(*With Tensor Symmetry*)
Tensor/:Format[Tensor[
xxx___/;((Union[Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]]==={})||(Union[Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]]==={Null})),
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents\[Rule]ttM_,
CoordinateSystem\[Rule]coords_List,
TensorSymmetry\[Rule]ts_
]/;((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],
{MatrixForm[ttM],"Coordinates"\[Rule]coords,"TensorSymmetry"\[Rule]ts}];
(* w/o TooltipDisplay II of II *)
(* everything else *)
 Tensor/:Format[Tensor[
xxx___/;((Union[Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]]==={})||(Union[Flatten[Cases[{xxx},(TooltipDisplay\[Rule]mmm_)\[Rule]mmm,\[Infinity]]]]==={Null})),
(* TensorType\[Rule]type_/;(type=!="Metric")*)
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TensorComponents\[Rule]ttM_,
CoordinateSystem\[Rule]coords_List,
TensorSymmetry\[Rule]ts_
]/;!((* scalar, vector or rank 2 tensor *)(RemoveUnderBarredIndices[\[Mu]T]==={})||MatchQ[Dimensions[ttM],{Length[coords]}|{Length[coords],Length[coords]}])]:=Tooltip[Row[{FormatTensorName[name],Sequence@@(UpOrDown[#]&/@\[Mu]T)}],
{"TensorSymmetry"\[Rule]ts}];*)
(*Abondoned code: End*)


(* ::Input::Initialization:: *)
(* Format: Appearance of non-Metric Tensor w/ Del[...Del[stuff w/o Del's]]: to do! *)
(* we display the TensorName and associated indices *)
(* w/ TooltipDisplay *)
(* Tensor/:Format[Tensor[
xxx___,
TensorType\[Rule]type_/;type=!="Metric",
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*),
TooltipDisplay\[Rule]display_
]]:=Module[{stuff,output,idx},
Tooltip[Row[{name,Sequence@@(UpOrDown[#]&/@\[Mu]T)}],Which[Head[display]===List,Flatten[display],True,display](*,LabelStyle\[Rule]{Large}*)]
]/;((Head[name]===Del));
(* w/o TooltipDisplay *)
Tensor/:Format[Tensor[
xxx___/;(Union[Flatten[Cases[{xxx},TooltipDisplay\[Rule]mmm_,\[Infinity]]]]==={}),
TensorType\[Rule]type_/;type=!="Metric",
TensorName\[Rule]name_,
Indices\[Rule]\[Mu]T_List(*/;(Union[(TestIndices[#]&&MatchQ[#\[LeftDoubleBracket]1\[RightDoubleBracket],_Symbol])&/@\[Mu]T]==={True})*)
]]:=Row[{name,Sequence@@(UpOrDown[#]&/@\[Mu]T)}]/;((Head[name]===Del)); *)
(* TensorProduct of Tensors *)
(* It is not possible to do something like Tensor/:TensorProduct[Times[t1___,mm_,t2___]]/;Head[mm]=!=Tensor:=... *)
(* So we create TensorsProduct below *)

(* Format: *)
(* we display the TensorName and associated indices *)
(* w/ TooltipDisplay *)
(*NewCode: Redundant TagSetDelay*)


(* ::Input::Initialization:: *)
(*NewCode: TooltipDisplay for Christoffel after acting PartialD,CovariantD,Derivative,etc. *)
(*Tensor[
xxx___,
TensorType\[Rule]"ChristoffelSymbols"(*Only works for "Christoffel"*),
TooltipDisplay\[Rule]disp_,
TensorName\[Rule]name_/;!(name==="\[CapitalGamma]")(*Not always be triggered. Only trigger when the name of Christoffel is changed.*),
Indices\[Rule]\[Mu]T_List,
TensorComponents\[Rule]ttM_,
CoordinateSystem\[Rule]coords_List
]/;!TooltipDisplayCheckwithComponents[disp,ttM](*Check if the TooltipDisplay does not match w/ TensorComponents*)(*If the display and components consist w/ each other, we don't need to trigger this code.*):=
Tensor[
xxx,
TensorType\[Rule]"ChristoffelSymbols",
TooltipDisplay\[Rule] NonZeroTensorComponents[name,
\[Mu]T,
ttM,
coords],
TensorName\[Rule]name,
Indices\[Rule]\[Mu]T,
TensorComponents\[Rule]ttM,
CoordinateSystem\[Rule]coords
];*)


(* ::Input::Initialization:: *)
(*NewCode: TensorWedge*)
Tensor/:TensorWedge[t1_Tensor/;(RankNumber[t1]>0)(*((TestTensorIsFullyAntiSymmetric[t1]||RankNumber[t1]===1))*),t2_Tensor/;(RankNumber[t2]>0)(*((TestTensorIsFullyAntiSymmetric[t2]||RankNumber[t2]===1))*)]/;((TestFormVectorIndices[Join[Indices[t1],Indices[t2]]])&&(Coordinates[t1]===Coordinates[t2])):=t1/.{(Indices->idx_)->(Indices->Join[Indices[t1],Indices[t2]]),(TensorComponents->tc_)->(TensorComponents->Normal[TensorComponents[t1]\[TensorWedge]TensorComponents[t2]]),
(TensorName->tn_)->(TensorName->TensorWedge[Sequence@@(TensorName[#]&/@{t1,t2})])}


(* ::Input::Initialization:: *)
(*NewCode: SymmetrizedArray*)
Tensor/:SymmetrizedArray[t_Tensor]:=Module[{output,newts,tc,sa},
tc=TensorComponents[t];
sa=SymmetrizedArray[tc];
output=t/.{(TensorComponents->xxx___)->(TensorComponents->sa)};
newts=TensorSymmetry[sa];
Which[(Cases[t,(TensorSymmetry->ts_)->ts]==={}),Append[output,TensorSymmetry->newts],True,output/.(TensorSymmetry->oldts_)->(TensorSymmetry->newts)]]


(* ::Input::Initialization:: *)
(*NewCode: TensorProduct and TensorComponents*)
TensorComponents[(m_Tensor|m_List/;(Cases[m,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Cases[m,(TensorComponents->mmm_):>mmm,(*NewCode: TensorComponent one layer*)(*\[Infinity]*)1][[1]];
(*NewCode: ExtractFunctions*)
TensorComponentsNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Cases[t,(TensorComponents->mmm_):>mmm,1];
(* If there are no Tensor's then just return the same object *)
(*TensorComponent[m_(*NewCode: TestExpressionForm*)/;(TestExpressionForm[m])]:=m;*)
TensorComponentsNoPart[m_/;TestExpressionForm[m]]:={m};
(*TensorComponents[t_Tensor,tc_List]:=t/.(TensorComponents\[Rule]mmm_)\[Rule](TensorComponents\[Rule]tc)*)


(* ::Input::Initialization:: *)
(*(*NewCode: Redundant TagSetDelay*)
(* One Tensor *)
TensorComponents[(m_Tensor|m_List)]:=Cases[m,(TensorComponents\[Rule]mmm_)\[RuleDelayed]mmm,(*NewCode: TensorComponent one layer*)(*\[Infinity]*)1]\[LeftDoubleBracket]1\[RightDoubleBracket];
(*NewCode: ExtractFunctions*)
TensorComponentsNoPart[(t_Tensor|t_List)]:=Cases[t,(TensorComponents\[Rule]mmm_)\[RuleDelayed]mmm,1];
(* If there are no Tensor's then just return the same object *)
TensorComponents[m_(*NewCode: TestExpressionForm*)/;TestExpressionForm[m]]:=m;
TensorComponentsNoPart[m_/;TestExpressionForm[m]]:={m};

TensorComponents[t_Tensor,tc_List]:=t/.(TensorComponents\[Rule]mmm_)\[Rule](TensorComponents\[Rule]tc)
(* Thread over Plus automatically *)
(*TensorComponents[mm_]:=(TensorComponents/@mm)/;(Head[mm]===Plus);*)
(* Use TensorsProduct to take care of TensorProduct's *)
(*TensorComponents[mm_]:=Module[{allTensors,therest},
allTensors=Times@@Cases[(List@@mm),_Tensor];
therest=Times@@DeleteCases[(List@@mm),_Tensor];
therest TensorComponents[TensorsProduct[allTensors]]
]/;(Head[mm]===Times);*)
(*NewCode: TensorComponents for Times[scalar, Plus[t1,t2]]*)
(*TensorComponents/:TensorComponents[mm_Times]:=Module[{allTensors,therest,therestpower,therestscalar},
allTensors=Times@@Cases[(List@@mm),(_Tensor|(*Not only Tensor, but also a Plus including Tensor inside it. We need to truly check that there is at least one Tensor inside Plus.*)Plus[Tensor[___],___])];
therest=Times@@DeleteCases[(List@@mm),(_Tensor|Plus[Tensor[___],___]|Power[Tensor[___],___])];
therestscalar=Times@@DeleteCases[(List@@therest),(Power[Tensor[___],___])];
therestpower=Times@@Cases[(List@@therest),(Power[Tensor[___],___])];
therestscalar TensorComponents[therestpower] TensorComponents[TensorsProduct[allTensors]]
];*)

(*TensorComponents/:TensorComponents[mm_]:=Module[{allTensors,therest},
allTensors=Times@@Cases[(List@@mm),(_Tensor|(*Not only Tensor, but also a Plus including Tensor inside it. We need to truly check that there is at least one Tensor inside Plus.*)Plus[Tensor[___],___])];
therest=Times@@DeleteCases[(List@@mm),(_Tensor|Plus[Tensor[___],___])];
therest TensorComponents[TensorsProduct[allTensors]]
]/;(Head[mm]===Times);*)

(*NewCode: TensorComponents and TensorsProduct*)
TensorComponents/:TensorComponents[mm_Times]:=Module[{listmm=Apply[List,mm],allTensors,therest,scalartensor,ttt,allTensorsPlus,expressionscalar,a,aaa,tttt},
allTensors=Cases[listmm,((aaa_Tensor/;(!TestScalarTensor[aaa]))|(*Not only Tensor, but also a Plus including Tensor inside it. We need to truly check that there is at least one Tensor inside Plus.*)Plus[tttt_/;(!TestExpressionForm[tttt]),___]),1];
allTensorsPlus=Cases[(allTensors),(Plus[tttt_/;(!TestExpressionForm[tttt]),___]),1];
allTensors=DeleteCases[(allTensors),(Plus[tttt_/;(!TestExpressionForm[tttt]),___]),1];
therest=DeleteCases[listmm,((aaa_Tensor/;(!TestScalarTensor[aaa]))|Plus[tttt_/;(!TestExpressionForm[tttt]),___]),1];
scalartensor=Cases[therest,ttt_/;ContainOnlyScalarTensor[ttt]];
scalartensor=Times@@(TensorComponents[#]&/@scalartensor);
expressionscalar=Times@@DeleteCases[therest,ttt_/;ContainOnlyScalarTensor[ttt]];
expressionscalar scalartensor TensorComponents[TensorsProduct[allTensors]] Which[(allTensorsPlus==={}),1,(allTensorsPlus=!={}),TensorComponents[TensorsProduct[allTensorsPlus]]]
];

(*TensorComponents[t_Power/;(TestScalarTensor[t\[LeftDoubleBracket]1\[RightDoubleBracket]])]:=Power[TensorComponents[t\[LeftDoubleBracket]1\[RightDoubleBracket]],t\[LeftDoubleBracket]2\[RightDoubleBracket]]*)

(*TensorComponents[func_[leftargs___,t_Tensor/;(TestScalarTensor[t]),rightargs___]/;(Head[func]=!=Plus)&&(Head[func]=!=Times)]:=func/.{t\[RuleDelayed]TensorComponents[t]};*)

(*NewCode: TensorComponents and TensorsProduct*)
TensorComponents[func_/;((Head[func]=!=Tensor)&&(Head[func]=!=Plus)&&(Head[func]=!=Times)&&(Union[TestScalarTensor[#]&/@Cases[func,_Tensor,Infinity]]==={True}))]:=func/.{t_Tensor\[RuleDelayed]TensorComponents[t]};*)


(* ::Input::Initialization:: *)
Coordinates[t_(*/;!TestExpressionForm[t]*)]:=Module[{mmm},Cases[t,(CoordinateSystem->mmm_)->mmm,(*NewCode: Coordinates one layer*)(*\[Infinity]*)1][[1]]]
(*NewCode: ExtractFunctions*)
CoordinatesNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm},Cases[t,(CoordinateSystem->mmm_)->mmm,1]]
(*Coordinates[stuff_/;TestExpressionForm[stuff]]:={};*)
CoordinatesNoPart[stuff_/;TestExpressionForm[stuff]]:={{}};

Coordinates[t_Tensor,coords_List]:=t/.(CoordinateSystem->mmm_)->(CoordinateSystem->coords)


(* ::Input::Initialization:: *)
Indices[t_/;(!TestExpressionForm[t])]:=Cases[t,(Indices->mmm_)->mmm,(*NewCode: Indices one layer*)(*\[Infinity]*)1][[1]]

(*NewCode: Indices for ExpressionForm*)
Indices[stuff_]/;((*TestScalarTensor[stuff]||*)(*Scalar Expression Form*)TestExpressionForm[stuff]):={}

(*Indices[(t_Tensor|t_List)]:=Cases[t,(Indices\[Rule]mmm_)\[Rule]mmm,(*NewCode: Indices one layer*)(*\[Infinity]*)1]\[LeftDoubleBracket]1\[RightDoubleBracket]*)

(*NewCode: ExtractFunctions*)
IndicesNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Cases[t,(Indices->mmm_)->mmm,1]

IndicesNoPart[stuff_]/;((*TestScalarTensor[stuff]||*)(*Scalar Expression Form*)TestExpressionForm[stuff]):={{}}

Indices[t_Tensor,indices_List]:=t/.(Indices->mmm_)->(Indices->indices)


(* ::Input::Initialization:: *)
StartIndex[t_Tensor]:=Module[{mmm},Cases[t,(StartIndex->mmm_)->mmm,1][[1]]]
StartIndexNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm},Cases[t,(StartIndex->mmm_)->mmm,1]]
StartIndex[stuff_/;TestExpressionForm[stuff]]:=0;
StartIndexNoPart[stuff_/;TestExpressionForm[stuff]]:={0};

StartIndex[t_Tensor,si_Integer]:=t/.(StartIndex->mmm_)->(StartIndex->si)


(* ::Input::Initialization:: *)
TensorName[t_Tensor]:=Module[{mmm},Cases[t,(TensorName->mmm_)->mmm,1][[1]]];
TensorNameNoPart[(t_Tensor|t_List)]:=Module[{mmm},Cases[t,(TensorName->mmm_)->mmm,1]];
TensorName[stuff_/;TestExpressionForm[stuff]]:=ToString[stuff,InputForm];
TensorNameNoPart[stuff_/;TestExpressionForm[stuff]]:={ToString[stuff,InputForm]};
TensorName[t_Tensor,tn_]:=t/.(TensorName->mmm_)->(TensorName->tn);
TensorName[(t_List)]:=Module[{},Apply[TensorProduct,t/.{ttt_Tensor:>TensorName[ttt] }]];
(*TensorName[(t_Times|t_Plus)]:=Module[{},(t/.{Times[(aaat___/;(MatchQ[Union[(TestScalarTensor[#]&/@{aaat})],({}|{True})])),(aaa___/;(MatchQ[Union[(TestExpressionForm[#]&/@{aaa})],({}|{True})])),(tt___/;(MatchQ[Union[(TestTensorTensor[#]&/@{tt})],({}|{True})]))]\[RuleDelayed]Apply[Times,{aaa}] Apply[Times,(TensorName[#]&/@{aaat})] Apply[TensorProduct,(TensorName[#]&/@{tt})] })/.{ttt_Tensor\[RuleDelayed]TensorName[ttt] }];*)
TensorName[(t_Times|t_Plus)]:=Module[{},t/.{ttt_Tensor:>TensorName[ttt] }];


(* ::Input::Initialization:: *)
(*TensorName[t_Tensor]:=Module[{mmm},Cases[t,(TensorName\[Rule]mmm_)\[Rule]mmm,1]\[LeftDoubleBracket]1\[RightDoubleBracket]];
TensorNameNoPart[(t_Tensor|t_List/;(Cases[t,(a_\[Rule] b_)\[Rule] (a\[Rule] b),{1}]=!={}))]:=Module[{mmm},Cases[t,(TensorName\[Rule]mmm_)\[Rule]mmm,1]];
TensorName[stuff_/;TestExpressionForm[stuff]]:=ToString[stuff,InputForm];
TensorNameNoPart[stuff_/;TestExpressionForm[stuff]]:={ToString[stuff,InputForm]};

TensorName[t_Tensor,tn_]:=t/.(TensorName\[Rule]mmm_)\[Rule](TensorName\[Rule]tn)

TensorName[t_Plus]:=TensorPlusName[t];

TensorName[(t_Times/;((!MatchQ[t,Times[scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),_Tensor]])&&((Union[Head/@(List@@t)]==={Tensor})||(Union[Head/@(List@@t)]==={Tensor,Plus})||(Union[Head/@(List@@t)]==={Plus})||(Union[Head/@(List@@t)]==={Plus,Tensor}))))]:=TensorProduct[Sequence@@(TensorName[#]&/@(Apply[List,t]))];

TensorName[(t_List/;((!MatchQ[t,{scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),_Tensor}])&&((Union[Head/@(t)]==={Tensor})||(Union[Head/@(t)]==={Tensor,Plus})||(Union[Head/@(t)]==={Plus})||(Union[Head/@(t)]==={Plus,Tensor}))&&(*Avoid infinite loop*)(Length[t]=!=1)))]:=TensorProduct[Sequence@@(TensorName[#]&/@t)];

TensorName[Times[scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),t_Tensor]]:=Row[{TensorName[scalar],TensorName[t]}];

TensorName[({scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),t_Tensor}(*|{t_Tensor,scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar])}*))]:=Row[{TensorName[scalar],TensorName[t]}];*)


(* ::Input::Initialization:: *)
TensorType[t_Tensor]:=Module[{mmm},Cases[t,(TensorType->mmm_)->mmm,1][[1]]]
TensorTypeNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm},Cases[t,(TensorType->mmm_)->mmm,1]]
TensorType[stuff_/;TestExpressionForm[stuff]]:=Null;
TensorTypeNoPart[stuff_/;TestExpressionForm[stuff]]:={Null};

TensorType[t_Tensor,tt_(*String*)]:=Module[{mmm},Which[(Cases[t,(TensorType->mmm_)->mmm]==={}),Append[t,TensorType->tt],True,t/.(TensorType->mmm_)->(TensorType->tt)]]


(* ::Input::Initialization:: *)
TooltipDisplay[t_Tensor]:=Module[{mmm},Cases[t,(TooltipDisplay->mmm_)->mmm,1][[1]]]
TooltipDisplayNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm},Cases[t,(TooltipDisplay->mmm_)->mmm,1]]
TooltipDisplay[stuff_/;TestExpressionForm[stuff]]:=Null;
TooltipDisplayNoPart[stuff_/;TestExpressionForm[stuff]]:={Null};

TooltipDisplay[t_Tensor,disp_]:=Module[{mmm},Which[(Cases[t,(TooltipDisplay->mmm_)->mmm]==={}),Append[t,TooltipDisplay->disp],True,t/.(TooltipDisplay->mmm_)->(TooltipDisplay->disp)]]


(* ::Input::Initialization:: *)
Tensor/:TooltipStyle[t_Tensor]:=Module[{mmm},Cases[t,(TooltipStyle->mmm_)->mmm,1][[1]]];

Unprotect[TooltipStyle];
TooltipStyle[stuff_/;(TestExpressionForm[stuff]&&(Head[stuff]=!=List))]:={};
TooltipStyle[t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={})]:=Module[{mmm},Cases[t,(TooltipStyle->mmm_)->mmm,1][[1]]];
Protect[TooltipStyle];

TooltipStyleNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm},Cases[t,(TooltipStyle->mmm_)->mmm,1]];
TooltipStyleNoPart[stuff_/;TestExpressionForm[stuff]]:={{}};

Tensor/:TooltipStyle[t_Tensor,style_]:=Module[{mmm},Which[(Cases[t,(TooltipStyle->mmm_)->mmm]==={}),Append[t,TooltipStyle->style],True,t/.(TooltipStyle->mmm_)->(TooltipStyle->style)]]


(* ::Input::Initialization:: *)
(*NewCode: TensorAssumption*)
TensorAssumption[t_]:=Module[{mmm,result},result=Cases[t,(TensorAssumption->mmm_)->mmm,1];
Which[(result==={}),{},True,result[[1]]]
];
TensorAssumptionNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm,result},result=Cases[t,(TensorAssumption->mmm_)->mmm,1];
Which[(result==={}),{{}},True,result]
];

TensorAssumptionNoPart[stuff_]/;((*TestScalarTensor[stuff]||*)(*Scalar Expression Form*)TestExpressionForm[stuff]):={{}}

TensorAssumption[t_Tensor,SL_]:=Module[{mmm},Which[(Cases[t,(TensorAssumption->mmm_)->mmm]==={}),Append[t,TensorAssumption->SL],True,t/.(TensorAssumption->mmm_)->(TensorAssumption->SL)]]


(* ::Input::Initialization:: *)
(*NewCode: TensorOperator*)
TensorOperator[(t_Tensor|t_Times|t_Plus)]:=Module[{mmm,result},result=Cases[t,(TensorOperator->mmm_)->mmm,Infinity];
Which[(result==={}),Simplify,True,result[[1]]]
];
TensorOperatorNoPart[(t_Tensor|t_List/;(Cases[t,(a_-> b_)-> (a-> b),{1}]=!={}))]:=Module[{mmm,result},result=Cases[t,(TensorOperator->mmm_)->mmm,1];
Which[(result==={}),{Simplify},True,result]
];
TensorOperator[stuff_/;TestExpressionForm[stuff]]:=Simplify;
TensorOperatorNoPart[stuff_/;TestExpressionForm[stuff]]:={Simplify};

TensorOperator[t_Tensor,top_]:=Module[{mmm},Which[(Cases[t,(TensorOperator->mmm_)->mmm]==={}),Append[t,TensorOperator->top],True,t/.(TensorOperator->mmm_)->(TensorOperator->top)]]


(* ::Input::Initialization:: *)
(*NewCode: TensorPlus*)
(*TensorPlus[(LHSt_Tensor|LHSt_Times(*|LHSt_Plus*))+(RHSt_Tensor|RHSt_Times|RHSt_Plus)]/;(*(Cases[LHSt,Tensor[___],{0,Infinity}]=!={})*)(!TestExpressionForm[LHSt])&&(*(Cases[RHSt,Tensor[___],{0,Infinity}]=!={})*)(!TestExpressionForm[RHSt]):=Union[Cases[{LHSt},Tensor[xx___],\[Infinity]]]\[LeftDoubleBracket]1\[RightDoubleBracket]/.{(TensorComponents\[Rule]LHStc_)\[RuleDelayed]   (TensorComponents\[Rule]TensorComponents[LHSt+RHSt])
,(TensorName\[Rule]LHStn_)\[RuleDelayed]   (TensorName\[Rule]TensorPlusName[LHSt+RHSt])}*)


(* ::Input::Initialization:: *)
OperatorNullList[a_(*Function Name*)]:=a[x1___,{},x2___/;(Cases[{x2},Tensor,{1}]==={})]:=1
OperatorNullList[TensorsProduct]
OperatorNullList[TensorComponents]


(* ::Input::Initialization:: *)
OperatorDistributeOverPlus[a_(*Function Name*)]:=a[x1___,t_Plus,x2___/;(Cases[{x2},Tensor,{1}]==={})]:=Apply[Plus,(a[Sequence@@{x1,#,x2}]&/@(Apply[List,t]))];
OperatorDistributeOverPlus[TensorsProduct]
OperatorDistributeOverPlus[TensorComponents]
OperatorDistributeOverPlus[PartialD];
OperatorDistributeOverPlus[CovariantD];
OperatorDistributeOverPlus[LieDerivative];
OperatorDistributeOverPlus[LieBracket];
OperatorDistributeOverPlus[ExteriorD];
Unprotect[Conjugate];
OperatorDistributeOverPlus[Conjugate];
Protect[Conjugate];


(* ::Input::Initialization:: *)
OperatorDistributeOverPlus[LT]
OperatorExpansion[a_(*Function Name*)]:=Module[{},a[x1___,(t_Times(*|t_List/;(t=!={})*)),x2___/;(Cases[{x2},Tensor,{1}]==={})]/;(Cases[Apply[List,t],Plus[tt_/;!TestExpressionForm[tt],___],{1}]=!={}):=a[x1,Expand[t],x2];

a[x1___,(t_List/;((t=!={})&&(Cases[t,_Tensor,Infinity]=!={}))),x2___/;(Cases[{x2},Tensor,{1}]==={})]/;(Cases[t,Plus[tt_/;!TestExpressionForm[tt],___],{1}]=!={}):=Module[{LTttt,output1},
LTttt=Apply[LT,t];
output1=a[x1,LTttt,x2];
output1=output1/.{LT-> List}
];
];
OperatorExpansion[TensorsProduct]
OperatorExpansion[TensorComponents]


(* ::Input::Initialization:: *)
OperatorFactorOutScalar[a_(*Function Name*)]:=Module[{t},a[x1___,(t_Times(*|t_List/;(t=!={})*)),x2___/;(Cases[{x2},Tensor,{1}]==={})]/;(!(Cases[Apply[List,t],Plus[tt_/;!TestExpressionForm[tt],___],{1}]=!={}))&&(Union[(TestTensorTensor/@(Apply[List,t]))]=!={True}):=Module[{allTensors,scalarexpr,scalartensor,FunctionOfScalarTensor,Listmm=(Apply[List,t]),FunctionOfTensorTensor},
scalarexpr=Cases[Listmm,(se_/;TestExpressionForm[se]),{1}];
scalartensor=Cases[Listmm,(st_/;TestScalarTensor[st]),{1}];
FunctionOfScalarTensor=Cases[Listmm,(func_/;((Head[func]=!=Tensor)&&(Head[func]=!=Plus)&&(Head[func]=!=Times)&&(Union[TestScalarTensor[#]&/@Cases[func,_Tensor,Infinity]]==={True}))),{1}];
FunctionOfTensorTensor=Cases[Listmm,(fott_/;((Head[fott]=!=Tensor)&&(Head[fott]=!=Plus)&&(Head[fott]=!=Times)&&!(Union[TestScalarTensor[#]&/@Cases[fott,_Tensor,Infinity]]==={True})&&!TestExpressionForm[fott])),{1}];
allTensors=Complement[Listmm,scalarexpr,scalartensor,FunctionOfScalarTensor,FunctionOfTensorTensor];
(Times@@(a[x1,#,x2]&/@scalarexpr)) (Times@@(a[x1,#,x2]&/@scalartensor))(Times@@(a[x1,#,x2]&/@FunctionOfScalarTensor)) (Times@@(a[x1,#,x2]&/@FunctionOfTensorTensor)) a[x1,TensorsProduct[(Times@@allTensors)],x2]
 ];

a[x1___,(t_List/;((t=!={})&&(Cases[t,_Tensor,Infinity]=!={}))),x2___/;(Cases[{x2},Tensor,{1}]==={})]/;(!(Cases[t,Plus[tt_/;!TestExpressionForm[tt],___],{1}]=!={}))&&((Union[(TestTensorTensor/@(Apply[List,t]))]=!={True})&&!(MatchQ[t,{___,TensorsProduct[___,Tensor],___}])):=Module[{allTensors,scalarexpr,scalartensor,FunctionOfScalarTensor,FunctionOfTensorTensor,TimesScalarTensor,TimesScalarTensorR},
scalarexpr=Cases[t,(se_/;TestExpressionForm[se]),{1}];
scalartensor=Cases[t,(st_/;TestScalarTensor[st]),{1}];
FunctionOfScalarTensor=Cases[t,(func_/;((Head[func]=!=Tensor)&&(Head[func]=!=Plus)&&(Head[func]=!=Times)&&(Union[TestScalarTensor[#]&/@Cases[func,_Tensor,Infinity]]==={True}))),{1}];
FunctionOfTensorTensor=Cases[t,(fott_/;((Head[fott]=!=Tensor)&&(Head[fott]=!=Plus)&&(Head[fott]=!=Times)&&!(Union[TestScalarTensor[#]&/@Cases[fott,_Tensor,Infinity]]==={True})&&!TestExpressionForm[fott])),{1}];
allTensors=Replace[t,((#-> Nothing)&/@scalarexpr),{1}];
allTensors=Replace[allTensors,((#-> Nothing)&/@scalartensor),{1}];
allTensors=Replace[allTensors,((#-> Nothing)&/@FunctionOfScalarTensor),{1}];
allTensors=Replace[allTensors,((#-> Nothing)&/@FunctionOfTensorTensor),{1}];
(Times@@scalarexpr) (Times@@(a/@scalartensor))(Times@@(a[x1,#,x2]&/@FunctionOfScalarTensor)) (Times@@(a[x1,#,x2]&/@FunctionOfTensorTensor)) a[x1,allTensors,x2];
TimesScalarTensor=Cases[allTensors,_Times,{1}];
TimesScalarTensorR=Table[(TimesScalarTensor[[i]]-> TensorsProduct[(*x1,*)TimesScalarTensor[[i]](*,x2*),Tensor]),{i,Length[TimesScalarTensor]}];
(Times@@(a[x1,#,x2]&/@scalarexpr)) (Times@@(a[x1,#,x2]&/@scalartensor))(Times@@(a[x1,#,x2]&/@FunctionOfScalarTensor)) (Times@@(a[x1,#,x2]&/@FunctionOfTensorTensor)) a[x1,TensorsProduct[Which[(TimesScalarTensor==={}),allTensors,True,Replace[allTensors,TimesScalarTensorR,{1}]]],x2]
 ];
];
OperatorFactorOutScalar[TensorsProduct]
OperatorFactorOutScalar[TensorComponents]


(* ::Input::Initialization:: *)
OperatorRemoveSingleComponentList[a_(*Function Name*)]:=a[x1___,{t_Tensor/;(t=!=Tensor)},x2___/;(Cases[{x2},Tensor,{1}]==={})]:=a[x1,t,x2];
OperatorRemoveSingleComponentList[TensorsProduct]
OperatorRemoveSingleComponentList[TensorComponents]


(* ::Input::Initialization:: *)
OperatorThreadThroughFunction[a_(*Function Name*)]:=a[x1___,func_/;((Head[func]=!=LT)&&(Head[func]=!=a)&&(Head[func]=!=List)&&(Head[func]=!=Tensor)&&(Head[func]=!=Plus)&&(Head[func]=!=Times)&&(Union[TestScalarTensor[#]&/@Cases[func,_Tensor,Infinity]]==={True})),x2___/;(Cases[{x2},Tensor,{1}]==={})]:=func/.{t_Tensor:>a[x1,t,x2]};
OperatorThreadThroughFunction[TensorsProduct]
OperatorThreadThroughFunction[TensorComponents]


(* ::Input::Initialization:: *)
OperatorTensorReturnItself[a_(*Function Name*)]:=a[(*x1___,*)(t_Tensor/;(t=!=Tensor))(*,x2___/;(Cases[{x2},Tensor,{1}]==={})*)]:=t;
OperatorTensorReturnItself[TensorsProduct]


(* ::Input::Initialization:: *)
OperatorExpressionFormReturnItself[a_(*Function Name*)]:=a[(*x1___,*)(t_/;TestExpressionForm[t]&&(t=!=Tensor))(*,(x2___/;(Cases[{x2},Tensor,{1}]==={}))*)]:=t;
OperatorExpressionFormReturnItself[TensorsProduct]
OperatorExpressionFormReturnItself[TensorComponents]


(* ::Input::Initialization:: *)
OperatorTensorsProduct[a_(*Function Name*)]:=a[x1___,(t_Times|t_List/;((t=!={})&&(Cases[t,_Tensor,Infinity]=!={}))),x2___/;(Cases[{x2},Tensor,{1}]==={})]/;((* check tensor product *)(* everybody is a Tensor *)(Union[Head/@(Apply[List,t])]==={Tensor})&&(* all coordinate systems are the same *)(Length[Union[Coordinates/@Cases[Apply[List,t],Tensor[___]]]]===1)&&(Cases[(Apply[List,t]),(st_/;TestScalarTensor[st]),{1}]==={})&&(Length[Apply[List,t]]=!=1)):=Module[
{tensorproduct,allindices,tensornames,listt=Apply[List,t],ii},
(* perform a tensor product *)
tensorproduct=TensorProduct[Sequence@@(TensorComponents/@listt)];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@listt)];
(* Tensor all the names *)
(*tensornames=TensorProduct[Sequence@@(*NewCode: ExtractFunctions*)(TensorName[#]&/@(List@@tt))];*)
tensornames=TensorName[listt];
(* output Tensor will inherit properties of the first Tensor *)
a[x1,((listt)[[1]]/.{
(TensorName->xxx_)->(TensorName->tensornames),
(Indices->xxx_)->(Indices->allindices),
(TensorComponents->xxxxx_)->(TensorComponents->tensorproduct)}),x2]
];
OperatorTensorsProduct[TensorsProduct]
OperatorTensorsProduct[TensorComponents]


(* ::Input::Initialization:: *)
OperatorContractThroughFunction[a_(*Function Name*)]:=a[x1___,func_/;((Head[func]=!=TensorsProduct)&&(Head[func]=!=LT)&&(Head[func]=!=a)&&(Head[func]=!=List)&&(Head[func]=!=Tensor)&&(Head[func]=!=Plus)&&(Head[func]=!=Times)&&!(Union[TestScalarTensor[#]&/@Cases[func,_Tensor,Infinity]]==={True})&&!TestExpressionForm[func]),x2___/;(Cases[{x2},Tensor,{1}]==={})]:=Replace[func,ContentWithTensor_/;(!TestExpressionForm[ContentWithTensor]):>a[x1,TensorsProduct[ContentWithTensor],x2],{1}];
OperatorContractThroughFunction[TensorsProduct]
OperatorContractThroughFunction[TensorComponents]


(* ::Input::Initialization:: *)
OutputBecomesOneTensor[a_(*Function Name*),namerule_/;(Cases[{namerule},TensorName,Infinity]=!={})]:=Module[{},
a[x1___,wholeBunchOfStuff_/;!TestExpressionForm[wholeBunchOfStuff],x2___,Tensor]:=Module[{FirstOutput,AllTensor,FirstTensor,output,name,indices},
FirstOutput=a[x1,wholeBunchOfStuff,x2];
AllTensor=Cases[{wholeBunchOfStuff},_Tensor,Infinity];
FirstTensor=AllTensor[[1]];
Which[(Cases[{FirstOutput},(t_/;TestTensorTensor[t]),Infinity]==={}),
indices={},
True,
indices=Cases[{FirstOutput},((Indices->(idx_/;(idx=!={})))-> idx ),Infinity][[1]]];
name=namerule/.{(TensorName-> TensorName[wholeBunchOfStuff])};
Which[TestExpressionForm[FirstOutput],
output=Indices[FirstTensor,indices];
output=TensorName[output,name];
output=output/.{(TensorComponents->mx_)->(TensorComponents->FirstOutput)},
True,
output=TensorName[FirstTensor,name];
output=output/.{(TensorComponents->mx_)->(TensorComponents->TensorComponents[FirstOutput])};
output=Indices[output,indices]
(*Replace[output,(Indices\[Rule]mmm_)\[Rule](Indices\[Rule]indices),{1}]*)
]
];

a[x1___,wholeBunchOfStuff_/;!TestExpressionForm[wholeBunchOfStuff],x2___,Tensor,TensorName-> username_]:=Module[{FirstOutput,AllTensor,FirstTensor,output,name,indices},
FirstOutput=a[x1,wholeBunchOfStuff,x2];
AllTensor=Cases[{wholeBunchOfStuff},_Tensor,Infinity];
FirstTensor=AllTensor[[1]];
Which[(Cases[{FirstOutput},(t_/;TestTensorTensor[t]),Infinity]==={}),
indices={},
True,
indices=Cases[{FirstOutput},((Indices->(idx_/;(idx=!={})))-> idx ),Infinity][[1]]];
Which[TestExpressionForm[FirstOutput],
output=Indices[FirstTensor,{}];
output=TensorName[output,username];
output=output/.{(TensorComponents->mx_)->(TensorComponents->FirstOutput)},
True,
output=TensorName[FirstTensor,username];
output=output/.{(TensorComponents->mx_)->(TensorComponents->TensorComponents[FirstOutput])};
output=Indices[output,indices]
(*Replace[output,(Indices\[Rule]mmm_)\[Rule](Indices\[Rule]indices),{1}]*)
]
];
];
OutputBecomesOneTensor[TensorsProduct,TensorName];


(* ::Input::Initialization:: *)
(*NewCode: OperatorProductRule*)
OperatorProductRule[a_(*Function Name*)]:=
Module[{},
a[x1___,t_Times/;((Union[(Head/@(List@@t))]=!={Tensor})&&(!TestExpressionForm[t])),x2___]:=Module[{allTensors,therest,part1,part2},
allTensors=Apply[Times,Cases[(Apply[List,t]),tt_/;TestTensorTensor[tt]]];
therest=Apply[Times,DeleteCases[(Apply[List,t]),tt_/;TestTensorTensor[tt]]];
part1=a[Sequence@@{x1,allTensors,x2}];
part2=a[Sequence@@{x1,therest,x2}];
part1=Which[TensorIsZero[part1],0,True,part1];
part2=Which[TensorIsZero[part2],0,True,part2];
therest part1+TensorsProduct[allTensors part2]];

a[x1___,t_Times/;(Union[(Head/@(Apply[List,t]))]==={Tensor}),x2___]:=a[Sequence@@{x1,TensorsProduct[t,Tensor],x2}];]

OperatorProductRule[PartialD];
OperatorProductRule[CovariantD];
OperatorProductRule[LieDerivative];
OperatorProductRule[LieBracket];
OperatorProductRule[ExteriorD];

(*OperatorProductRule[a_(*Function Name*)]:=
Module[{},
a[Sequence@@{x1___,t_Times,x2___}]:=Module[{allTensors,therest},
allTensors=Times@@Cases[(List@@t),_Tensor];
therest=Times@@DeleteCases[(List@@t),_Tensor];
therest a[Sequence@@{x1,allTensors,x2}]+allTensors Which[TensorIsZero[a[Sequence@@{x1,therest,x2}]],0,True,a[Sequence@@{x1,therest,x2}]]]/;(Union[(Head/@(List@@t))]=!={Tensor});

a[Sequence@@{x1___,t_Times,x2___}]:=a[Sequence@@{x1,TensorsProduct[t],x2}]/;(Union[(Head/@(List@@t))]==={Tensor});]*)


(* ::Input::Initialization:: *)
OperatorThreadThroughTimes[a_(*Function Name*)]:=a[x1___,(t_Times(*|t_List/;(t=!={})*)),x2___/;(Cases[{x2},Tensor,{1}]==={})]:=Times@@(a[x1,#,x2]&/@(Apply[List,t]));

Unprotect[Conjugate];
OperatorThreadThroughTimes[Conjugate];
Protect[Conjugate];


(* ::Input::Initialization:: *)
TensorComponentsManipulation[name_]:=(Tensor/:name[t_Tensor]:=t/.{(TensorComponents-> comp_):> (TensorComponents-> name[comp])});

TensorComponentsManipulation[Expand];
TensorComponentsManipulation[ExpToTrig];
TensorComponentsManipulation[TrigToExp];
TensorComponentsManipulation[TrigReduce];
TensorComponentsManipulation[ComplexExpand];
TensorComponentsManipulation[FunctionExpand];
TensorComponentsManipulation[PowerExpand];


(* ::Input::Initialization:: *)
(*NewCode: ToExpressionForm*)
ToExpressionForm[tt_Tensor]:=Module[{coord,dcoords,delcoords,indices,idxl,mx,mx2,mx2basis,mx2component,output,dim,basislist,ilist,i,j,sequencelist,isequencelist,a,b,sa,IndptElements,indptN,position,indptEleValue,iilistValue,countlist},
coord=Coordinates[tt];
dcoords=(\[DifferentialD]#)&/@coord;
delcoords=(\[Del]#)&/@coord;
indices=RemoveUnderBarredIndices[Indices[tt]];
idxl=RankNumber[indices];
dim=Length[coord];
basislist=Table[Which[Sgn[indices[[i]]]===1,delcoords,Sgn[indices[[i]]]===-1,dcoords],{i,1,idxl}];
ilist=Table[Unique[i],{b,1,idxl}];
sequencelist=Quiet[Table[Part[basislist[[a]],ilist[[a]]],{a,1,idxl}]];
Which[(TensorSymmetry[tt][[1]]===Antisymmetric[Range[Length[RemoveUnderBarredIndices[Indices[tt]]]]]),
sa=SymmetrizedArray[TensorComponents[tt]];
IndptElements=Drop[SymmetrizedArrayRules[sa],-1];
indptN=Length[IndptElements];
position=Table[IndptElements[[i,1]],{i,indptN}];
indptEleValue=Table[IndptElements[[i,2]],{i,indptN}];
iilistValue=Thread[(ilist->#)]&/@position;
Plus@@Table[indptEleValue[[i]] (TensorWedge@@(sequencelist/.iilistValue[[i]])),{i,indptN}]
,(TensorSymmetry[tt][[1]]===Symmetric[Range[Length[RemoveUnderBarredIndices[Indices[tt]]]]]),
sa=SymmetrizedArray[TensorComponents[tt]];
IndptElements=Drop[SymmetrizedArrayRules[sa],-1];
indptN=Length[IndptElements];
position=Table[IndptElements[[i,1]],{i,indptN}];
indptEleValue=Table[IndptElements[[i,2]],{i,indptN}];
iilistValue=Thread[(ilist->#)]&/@position;
Plus@@Table[countlist=Counts[position[[i]]];Multinomial[Sequence@@Table[countlist[[j]],{j,Length[countlist]}]] indptEleValue[[i]] (Times@@(sequencelist/.iilistValue[[i]])),{i,indptN}]
,True,
isequencelist={#,1,dim}&/@ilist;Plus@@Flatten[Table[TensorComponents[tt][[Sequence@@ilist]] TensorProduct[Sequence@@sequencelist],Evaluate[Sequence@@isequencelist]]]]
];


(* ::Input::Initialization:: *)
(*NewCode: ToTensorComponents w/ TensorProduct*)
ToTensorComponents[stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]==={})(*&&(Cases[{stuff},TensorProduct[__],Infinity]=!={})*)&&!TestSymmetricTensorExpressionForm[stuff]),opts:OptionsPattern[]]:=Module[{tpexpand,dcoords,delcoords,idxl,dim,basislist,ilist,sequencelist,isequencelist,output,i,b,a,coord,CasesTP,CasesTPFirstList,basissgn},
coord=OptionValue[CoordinateSystem];
tpexpand=stuff//TensorExpand;
dcoords=(\[DifferentialD]#)&/@coord;
delcoords=(\[Del]#)&/@coord;
CasesTP=Cases[tpexpand,TensorProduct[a_,___]/;MatchQ[a,(\[DifferentialD]__|\[Del]__)],Infinity];
CasesTPFirstList=Apply[List,First[CasesTP]];
basissgn=BasisSgn[#]&/@CasesTPFirstList;
idxl=Length[basissgn];
dim=Length[coord];
basislist=Table[Which[basissgn[[i]]===1,delcoords,basissgn[[i]]===-1,dcoords],{i,1,idxl}];
ilist=Table[Unique[i],{b,1,idxl}];
sequencelist=Quiet[Table[Part[basislist[[a]],ilist[[a]]],{a,1,idxl}]];
isequencelist={#,1,dim}&/@ilist;
output=Table[Coefficient[tpexpand,TensorProduct[Sequence@@sequencelist]],Evaluate[Sequence@@isequencelist]]
];

(*NewCode: ToTensorComponents w/ Times*)
ToTensorComponents[indices_List,stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]==={})(*&&(Cases[{stuff},TensorProduct[__],Infinity]==={})*)&&TestSymmetricTensorExpressionForm[stuff]),opts:OptionsPattern[]]:=Module[{texpand,dcoords,delcoords,idxl,dim,basislist,ilist,sequencelist,isequencelist,output,i,b,a,coord,CasesTP,CasesTPFirstList,basissgn},
coord=OptionValue[CoordinateSystem];
texpand=stuff//Expand;
dcoords=(\[DifferentialD]#)&/@coord;
delcoords=(\[Del]#)&/@coord;
CasesTP=Cases[tpexpand,TensorProduct[a_,___]/;MatchQ[a,(\[DifferentialD]__|\[Del]__)],Infinity];
CasesTPFirstList=Apply[List,First[CasesTP]];
basissgn=BasisSgn[#]&/@CasesTPFirstList;
idxl=Length[basissgn];
dim=Length[coord];
basislist=Table[Which[basissgn[[i]]===1,delcoords,basissgn[[i]]===-1,dcoords],{i,1,idxl}];
ilist=Table[Unique[i],{b,1,idxl}];
sequencelist=Quiet[Table[Part[basislist[[a]],ilist[[a]]],{a,1,idxl}]];
isequencelist={#,1,dim}&/@ilist;
output=Table[1/(Permutations[sequencelist]//Length) Coefficient[texpand,Times[Sequence@@sequencelist]],Evaluate[Sequence@@isequencelist]]
];

ToTensorComponents[indices_List,stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]=!={})),opts:OptionsPattern[]]:=Module[{twteProduct,dcoords,delcoords,idxl,dim,basislist,ilist,sequencelist,isequencelist,output,i,b,a,coord},
twteProduct=(stuff//TensorExpand)//WedgeProductExpand;
ToTensorComponents[indices,twteProduct,CoordinateSystem->OptionValue[CoordinateSystem]]
];

Unprotect[TensorProduct];
TensorProduct[x1___,Times[(\[DifferentialD]coord_),x3___/;(TestExpressionForm[Unique[a][x3]]&&(Cases[{x3},(\[DifferentialD]a_)-> a,Infinity]==={})&&(Cases[{x3},(\[Del]a_)-> a,Infinity]==={}))],x2___]:=(Times@@{x3}) TensorProduct[x1,\[DifferentialD]coord,x2];

TensorProduct[x1___,Times[(\[Del]coord_),x3___/;(TestExpressionForm[Unique[a][x3]]&&(Cases[{x3},(\[DifferentialD]a_)-> a,Infinity]==={})&&(Cases[{x3},(\[Del]a_)-> a,Infinity]==={}))],x2___]:=(Times@@{x3}) TensorProduct[x1,\[Del]coord,x2];
Protect[TensorProduct];


(* ::Input::Initialization:: *)
(*NewCode: WedgeProductExpand*)
WedgeProductExpand[tw_/;((Head[tw]=!=TensorWedge)&&(Cases[{tw},TensorWedge[__],Infinity]=!={}))]:=tw/.{TensorWedge[xxx___]:> WedgeProductExpand[TensorWedge[xxx]]};

Unprotect[TensorWedge];
TensorWedge[x1___,Times[(\[DifferentialD]coord_),x3___/;(TestExpressionForm[Unique[a][x3]]&&(Cases[{x3},(\[DifferentialD]a_)-> a,Infinity]==={})&&(Cases[{x3},(\[Del]a_)-> a,Infinity]==={}))],x2___]:=(Times@@{x3}) TensorWedge[x1,\[DifferentialD]coord,x2];

TensorWedge[x1___,Times[(\[Del]coord_),x3___/;(TestExpressionForm[Unique[a][x3]]&&(Cases[{x3},(\[DifferentialD]a_)-> a,Infinity]==={})&&(Cases[{x3},(\[Del]a_)-> a,Infinity]==={}))],x2___]:=(Times@@{x3}) TensorWedge[x1,\[Del]coord,x2];
Protect[TensorWedge];


(* ::Input::Initialization:: *)
(* Entering a geometry *)
(* I of II: Metric takes in a specific metric and CoordinateSystem, computes Christoffel symbols,Riemann, Ricci tensor and scalar,and returns a Tensor containing these computations. *)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],matrix_/;(MatchQ[Dimensions[matrix],{nn_,nn_}]&&(Head[matrix]===List)),opts:OptionsPattern[]]/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SubMinus[_]}]||MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SuperMinus[_]}]):=Tensor[
TensorType->"Metric",
CoordinateSystem->OptionValue[CoordinateSystem],
TensorName->OptionValue[TensorName],
StartIndex->OptionValue[StartIndex],
ChristoffelOperator->OptionValue[ChristoffelOperator],
RiemannOperator->OptionValue[RiemannOperator],
RicciOperator->OptionValue[RicciOperator],
RicciScalarOperator->OptionValue[RicciScalarOperator],
(*NewCode: TooltipDisplay for metric*)
TooltipDisplay->OptionValue[TooltipDisplay],
(*NewCode: TooltipStyle for metric*)
TooltipStyle->OptionValue[TooltipStyle],
Indices->{\[Mu]T,\[Nu]T},
TensorComponents->(matrix//OptionValue[MetricOperator]),
(*NewCode: OrthonormalFrameField*)
FlatMetric->OptionValue[FlatMetric],
OrthonormalFrameField->OptionValue[OrthonormalFrameField],
InverseOrthonormalFrameField->OptionValue[InverseOrthonormalFrameField],
OrthonormalFrameFieldOperator->OptionValue[OrthonormalFrameFieldOperator],TestOrthonormalFrameField->OptionValue[TestOrthonormalFrameField],
OrthonormalFrameFieldIndices->OptionValue[OrthonormalFrameFieldIndices],
(*NewCode: TensorAssumption*)
TensorAssumption-> OptionValue[TensorAssumption],
(*NewCode: TensorOperator*)
TensorOperator-> OptionValue[TensorOperator]
]/;((Head[OptionValue[StartIndex]]===Integer)&&(OptionValue[StartIndex]>=0));
(* II of II: Same as above, except we allow the metric to be entered in terms of differentials \[DifferentialD]t, \[DifferentialD]x, etc. *)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],matrix_/;TestExpressionForm[matrix],opts:OptionsPattern[]]/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SubMinus[_]}]):=Module[
{MetricM,\[Mu],\[Nu],dcoords,lgth},
(* convert the expression matrix to a dim. x dim. List matrix *)
lgth=Length[OptionValue[CoordinateSystem]];
dcoords=(\[DifferentialD]#)&/@OptionValue[CoordinateSystem];
MetricM=Table[
Which[
	(* off diagonal terms *)
	\[Mu]=!=\[Nu],1/2 Coefficient[Expand[matrix],dcoords[[\[Mu]]]dcoords[[\[Nu]]]],
	(* diagonal terms *)
	\[Mu]===\[Nu],Coefficient[Expand[matrix],dcoords[[\[Mu]]]dcoords[[\[Nu]]]]
],
{\[Mu],1,lgth},{\[Nu],1,lgth}];
(* then feed matrix into the same code as above *)
Tensor[
TensorType->"Metric",
CoordinateSystem->OptionValue[CoordinateSystem],
TensorName->OptionValue[TensorName],
StartIndex->OptionValue[StartIndex],
ChristoffelOperator->OptionValue[ChristoffelOperator],
RiemannOperator->OptionValue[RiemannOperator],
RicciOperator->OptionValue[RicciOperator],
RicciScalarOperator->OptionValue[RicciScalarOperator],
(*NewCode: TooltipDisplay for metric*)
TooltipDisplay->OptionValue[TooltipDisplay],
(*NewCode: TooltipStyle for metric*)
TooltipStyle->OptionValue[TooltipStyle],
Indices->{\[Mu]T,\[Nu]T},
TensorComponents->(*NewCode: MetricOperator*)(MetricM//OptionValue[MetricOperator]),
(*NewCode: OrthonormalFrameField*)
FlatMetric->OptionValue[FlatMetric],
OrthonormalFrameField->OptionValue[OrthonormalFrameField],
InverseOrthonormalFrameField->OptionValue[InverseOrthonormalFrameField],
OrthonormalFrameFieldOperator->OptionValue[OrthonormalFrameFieldOperator],TestOrthonormalFrameField->OptionValue[TestOrthonormalFrameField],
OrthonormalFrameFieldIndices->OptionValue[OrthonormalFrameFieldIndices],
(*NewCode: TensorAssumption*)
TensorAssumption-> OptionValue[TensorAssumption],
(*NewCode: TensorOperator*)
TensorOperator-> OptionValue[TensorOperator]
]
]/;((Head[OptionValue[StartIndex]]===Integer)&&(OptionValue[StartIndex]>=0)&&
(*NewCode: TestQuadratic*)TestQuadratic[matrix,OptionValue[CoordinateSystem],-1]);
(*NewCode: Inverse Metric with quadratic form Try to make user be able to input, e.g., g2cy=Metric[i^-,j^-,(\[Del]r)^2+r^-2*(\[Del]\[Phi])^2,CoordinateSystem\[Rule]{r,\[Phi]},TensorName\[Rule]"g",StartIndex\[Rule]1]*)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],matrix_/;TestExpressionForm[matrix],opts:OptionsPattern[]]/;(MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SuperMinus[_]}]):=Module[
{MetricM,\[Mu],\[Nu],pdcoords,lgth},
(* convert the expression matrix to a dim. x dim. List matrix *)
lgth=Length[OptionValue[CoordinateSystem]];
pdcoords=(\[Del]#)&/@OptionValue[CoordinateSystem];
MetricM=Table[
Which[
	(* off diagonal terms *)
	\[Mu]=!=\[Nu],1/2 Coefficient[Expand[matrix],pdcoords[[\[Mu]]]pdcoords[[\[Nu]]]],
	(* diagonal terms *)
	\[Mu]===\[Nu],Coefficient[Expand[matrix],pdcoords[[\[Mu]]]pdcoords[[\[Nu]]]]
],
{\[Mu],1,lgth},{\[Nu],1,lgth}];
(* then feed matrix into the same code as above *)
Tensor[
TensorType->"Metric",
CoordinateSystem->OptionValue[CoordinateSystem],
TensorName->OptionValue[TensorName],
StartIndex->OptionValue[StartIndex],
ChristoffelOperator->OptionValue[ChristoffelOperator],
RiemannOperator->OptionValue[RiemannOperator],
RicciOperator->OptionValue[RicciOperator],
RicciScalarOperator->OptionValue[RicciScalarOperator],
(*NewCode: TooltipDisplay for metric*)
TooltipDisplay->OptionValue[TooltipDisplay],
(*NewCode: TooltipStyle for metric*)
TooltipStyle->OptionValue[TooltipStyle],
Indices->{\[Mu]T,\[Nu]T},
TensorComponents->(MetricM//OptionValue[MetricOperator]),
(*NewCode: OrthonormalFrameField*)
FlatMetric->OptionValue[FlatMetric],
OrthonormalFrameField->OptionValue[OrthonormalFrameField],
InverseOrthonormalFrameField->OptionValue[InverseOrthonormalFrameField],
OrthonormalFrameFieldOperator->OptionValue[OrthonormalFrameFieldOperator],TestOrthonormalFrameField->OptionValue[TestOrthonormalFrameField],
OrthonormalFrameFieldIndices->OptionValue[OrthonormalFrameFieldIndices],
(*NewCode: TensorAssumption*)
TensorAssumption-> OptionValue[TensorAssumption],
(*NewCode: TensorOperator*)
TensorOperator-> OptionValue[TensorOperator]
]
]/;((Head[OptionValue[StartIndex]]===Integer)&&(OptionValue[StartIndex]>=0)&&TestQuadratic[matrix,OptionValue[CoordinateSystem],+1]);
(* Metric also takes in a Tensor object of type Metric and spits out the components *)
(* aka Raising and lowering of Metric indices *)
(* one up and one down *)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],m_Tensor(*NewCode: TooltipDisplay and TooltipStyle*),opts:OptionsPattern[]]/;((MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SubMinus[_]}]||MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SuperMinus[_]}])(*NewCode: ExtractFunctions*)&&(TestMetricTensor[m])):=Module[{idx,cpts,row,col,l,ix,mx,id,output},
(*NewCode: ExtractFunctions*)
l=Length[Coordinates[m]];
ix=Indices[m];
mx=TensorComponents[m];
id=Table[KroneckerDelta[row,col],{row,1,l},{col,1,l}];
output=m/.{
(Indices->ix)->(Indices->{\[Mu]T,\[Nu]T}),
(TensorComponents->mx)->(TensorComponents->id)
};
(*NewCode: TooltipDisplay and TooltipStyle*)
Which[(OptionValue[TooltipDisplay]=!=Null),output=output/.{(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])}];
Which[(OptionValue[TooltipStyle]=!={(*Small*)}),output=output/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])];
output
];
(* both lower *)
(*NewCode: ExtractFunctions*)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],m_Tensor,(*NewCode: MetricOperator*)opts:OptionsPattern[]]/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SubMinus[_]}](*NewCode: ExtractFunctions*)&&(TestMetricTensor[m])):=Module[{ix,mx,output},
(*NewCode: ExtractFunctions*)
ix=Indices[m];
mx=TensorComponents[m];
output=Which[
(* both lower then just return the Tensor *)
MatchQ[ix,{SubMinus[_],SubMinus[_]}],
m/.(Indices->ix)->(Indices->{\[Mu]T,\[Nu]T}),
(* both upper we have to invert the TensorComponents *)
MatchQ[ix,{SuperMinus[_],SuperMinus[_]}],
m/.{
(Indices->ix)->(Indices->{\[Mu]T,\[Nu]T}),
(TensorComponents->mx):>(TensorComponents->(*NewCode: MetricOperator*)(Inverse[mx]//OptionValue[MetricOperator]))}
];
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,output=output/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])];
Which[OptionValue[TooltipStyle]=!={(*Small*)},output=output/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])];
output
];
(* both upper *)
Metric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],m_Tensor,(*NewCode: MetricOperator*)opts:OptionsPattern[]]/;(MatchQ[{\[Mu]T,\[Nu]T},{SuperMinus[_],SuperMinus[_]}]&&(TestMetricTensor[m])):=Module[{ix,mx,output},
(*NewCode: ExtractFunctions*)
ix=Indices[m];
mx=TensorComponents[m];
output=Which[
(* both upper then just return the Tensor *)
MatchQ[ix,{SuperMinus[_],SuperMinus[_]}],
m/.(Indices->ix)->(Indices->{\[Mu]T,\[Nu]T}),
(* both lower we have to invert the TensorComponents *)
MatchQ[ix,{SubMinus[_],SubMinus[_]}],
m/.{
(Indices->ix)->(Indices->{\[Mu]T,\[Nu]T}),
(TensorComponents->mx):>(TensorComponents->(*NewCode: MetricOperator*)(Inverse[mx]//OptionValue[MetricOperator]))}
];
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,output=output/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])];
Which[OptionValue[TooltipStyle]=!={(*Small*)},output=output/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])];
output
];

(*NewCode: Endow Metric as a property of a Tensor*)
(*Metric[t_Tensor,m_Tensor/;TestMetricTensor[m]]:=Which[(Cases[t,(Metric\[Rule]metric_)\[Rule]metric]==={}),Append[t,Metric\[Rule]m],True,t/.(Metric\[Rule]metric_)\[Rule](Metric\[Rule]m)]*)


(* ::Input::Initialization:: *)
(* Generates a Tensor with components stuff and indices \[Mu]T *)
(* For non-scalar *)
NonMetricTensor[\[Mu]T_List,(stuff_List|stuff_SparseArray|stuff_SymmetrizedArray),exp_,CoordinateSystem->coords_List,opts:OptionsPattern[]]/;(Union[TestIndices/@\[Mu]T]==={True})&&MatchQ[Dimensions[stuff],{nnn_Integer..}]:=Tensor[
Indices->\[Mu]T,
CoordinateSystem->coords,
TensorComponents->stuff,
TensorName->exp,
StartIndex->OptionValue[StartIndex],
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->OptionValue[TooltipStyle],TensorType->OptionValue[TensorType],
(*NewCode: TensorAssumption*)
TensorAssumption-> OptionValue[TensorAssumption],
(*NewCode: TensorOperator*)
TensorOperator-> OptionValue[TensorOperator]
];

(* Generates a Tensor with components stuff and indices \[Mu]T *)
(* For scalar *)
NonMetricTensor[{},stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]==={})&&(Cases[{stuff},(\[Del]a_)-> a,Infinity]==={})(*&&!(Head[stuff]===List)*)),exp_,CoordinateSystem->coords_List,opts:OptionsPattern[]]:=Tensor[
Indices->{},
CoordinateSystem->coords,
TensorComponents->stuff,
TensorName->exp,
StartIndex->OptionValue[StartIndex],
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->OptionValue[TooltipStyle],TensorType->OptionValue[TensorType],
(*NewCode: TensorAssumption*)
TensorAssumption-> OptionValue[TensorAssumption],
(*NewCode: TensorOperator*)
TensorOperator-> OptionValue[TensorOperator]
];

(*NewCode: NonMetricTensor for ExpressionForm (not scalar) with TensorProduct.*)
NonMetricTensor[indices_/;(RankNumber[indices]=!=0),stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]==={})(*&&(Cases[{stuff},TensorProduct[__],Infinity]=!={})*)&&!TestSymmetricTensorExpressionForm[stuff]),exp_,CoordinateSystem->coords_List,opts:OptionsPattern[]]:=NonMetricTensor[indices,ToTensorComponents[indices,stuff,CoordinateSystem->coords],exp,CoordinateSystem->coords ,opts];

(*NewCode: NonMetricTensor for ExpressionForm (not scalar) with TensorWedge.*)
NonMetricTensor[indices_/;(RankNumber[indices]=!=0),stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]=!={})&&!TestSymmetricTensorExpressionForm[stuff]),exp_,CoordinateSystem->coords_List,opts:OptionsPattern[]]:=Module[{twteProduct,m},
twteProduct=(stuff//TensorExpand)//WedgeProductExpand;
m=ToTensorComponents[indices,twteProduct,CoordinateSystem->coords];
NonMetricTensor[indices,m,exp,CoordinateSystem->coords,opts]
];

(*NewCode: Symmetric NonMetricTensor for ExpressionForm (not scalar) with Times.*)
NonMetricTensor[indices_/;(RankNumber[indices]=!=0),stuff_/;(TestExpressionForm[stuff]&&(Cases[{stuff},(\[DifferentialD]a_)-> a,Infinity]=!={}||(Cases[{stuff},(\[Del]a_)-> a,Infinity]=!={}))(*&&!(Head[stuff]===List)*)&&(Cases[{stuff},TensorWedge[__],Infinity]==={})(*&&!(Cases[{stuff},TensorProduct[__],Infinity]=!={})*)&&TestSymmetricTensorExpressionForm[stuff]),exp_,CoordinateSystem->coords_List,opts:OptionsPattern[]]:=NonMetricTensor[indices,ToTensorComponents[indices,stuff,CoordinateSystem->coords],exp,CoordinateSystem->coords ,opts];


(* ::Input::Initialization:: *)
(* either input the coordinates or their corresponding numbers *)
(* Internally we build the Tensor with abstract indices before evaluating it with the specified ones *)
Christoffel[\[Mu]I_/;TestIndices[\[Mu]I],\[Alpha]I_/;TestIndices[\[Alpha]I],\[Beta]I_/;TestIndices[\[Beta]I],m_Tensor,(*NewCode: Tooltip for Christoffel*)opts:OptionsPattern[]]/;((TestMetricTensor[m])&&MatchQ[\[Mu]I,SuperMinus[_]]&&MatchQ[\[Alpha]I,SubMinus[_]]&&MatchQ[\[Beta]I,SubMinus[_]]):=Module[
{\[Mu],\[Alpha],\[Beta],cooo,st,d,mm,Chris,cc,disp},
(*NewCode: ExtractFunctions*)
cooo=Coordinates[m];
d=Length[cooo];
st=StartIndex[m];
(*NewCode: Layer one*)
Chris=Flatten[Cases[m,(ChristoffelComponents->cc_)->cc,1]];
mm=Table[(ChristoffelComponents[SuperMinus[\[Mu]],SubMinus[\[Alpha]],SubMinus[\[Beta]]]/.Chris),{\[Mu],st,st+d-1},{\[Alpha],st,st+d-1},{\[Beta],st,st+d-1}];
(*NewCode: Tooltip for Christoffel*)
(*Which[OptionValue[TooltipDisplay]===Null,(* display only non-zero components *)disp=Select[Chris,(Flatten[Cases[{#},(ChristoffelComponents[__]\[Rule]cc_)\[Rule]cc]]\[LeftDoubleBracket]1\[RightDoubleBracket]=!=0)&];
disp=(disp/.{ChristoffelComponents[SuperMinus[\[Mu]s_],SubMinus[\[Alpha]s_],SubMinus[\[Beta]s_]]\[RuleDelayed]Row[{"\[CapitalGamma]",Column[{cooo\[LeftDoubleBracket]\[Mu]s-st+1\[RightDoubleBracket],Null}],Column[{Null,cooo\[LeftDoubleBracket]\[Alpha]s-st+1\[RightDoubleBracket]}],Column[{Null,cooo\[LeftDoubleBracket]\[Beta]s-st+1\[RightDoubleBracket]}]}]}),True,disp=OptionValue[TooltipDisplay]];*)
Tensor[
TensorType->"ChristoffelSymbols",
TensorName->"\[CapitalGamma]",
CoordinateSystem->cooo,
TensorComponents->mm,
StartIndex->st,
Indices->{\[Mu]I,\[Alpha]I,\[Beta]I},
(*NewCode: Tooltip for Christoffel*)
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->Which[(OptionValue[TooltipStyle]=!={}),OptionValue[TooltipStyle],True, TooltipStyle[m]],
(*NewCode: TensorAssumption*)
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
]
];


(* ::Input::Initialization:: *)
(* either input the coordinates or their corresponding numbers *)
(* Internally we build the Tensor with abstract indices before evaluating it with the specified ones *)
Riemann[\[Mu]I_/;TestIndices[\[Mu]I],\[Nu]I_/;TestIndices[\[Nu]I],\[Alpha]I_/;TestIndices[\[Alpha]I],\[Beta]I_/;TestIndices[\[Beta]I],m_Tensor(*NewCode: Tooltip for Riemann*),opts:OptionsPattern[]](*NewCode: ExtractFunctions*)/;(TestMetricTensor[m]):=Module[
{mm,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,si,cooo,disp,d,cc,Rie,lhs,rhs,RL1,RL2,RL3,RL4,RiemannTemp,\[Tau]},
(*NewCode: ExtractFunctions*)
cooo=Coordinates[m];
d=Length[cooo];
si=StartIndex[m];
(*NewCode: Layer one*)
Rie=Flatten[Cases[m,(RiemannComponents->cc_)->cc,1]];
Do[RL1[\[Mu],\[Mu]1]=RaiseLower[ReplaceIndex[\[Mu],\[Mu]I],SuperMinus[\[Mu]1],m],{\[Mu],si,si+d-1},{\[Mu]1,si,si+d-1}];
Do[RL2[\[Nu],\[Nu]1]=RaiseLower[ReplaceIndex[\[Nu],\[Nu]I],SubMinus[\[Nu]1],m],{\[Nu],si,si+d-1},{\[Nu]1,si,si+d-1}];
Do[RL3[\[Alpha],\[Alpha]1]=RaiseLower[ReplaceIndex[\[Alpha],\[Alpha]I],SubMinus[\[Alpha]1],m],{\[Alpha],si,si+d-1},{\[Alpha]1,si,si+d-1}];
Do[RL4[\[Beta],\[Beta]1]=RaiseLower[ReplaceIndex[\[Beta],\[Beta]I],SubMinus[\[Beta]1],m],{\[Beta],si,si+d-1},{\[Beta]1,si,si+d-1}];
Do[RiemannTemp[\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1]=(RiemannComponents[SuperMinus[\[Mu]1],SubMinus[\[Nu]1],SubMinus[\[Alpha]1],SubMinus[\[Beta]1]]/.Rie),
{\[Mu]1,si,si+d-1},{\[Nu]1,si,si+d-1},{\[Alpha]1,si,si+d-1},{\[Beta]1,si,si+d-1}];
mm=Table[Sum[RL1[\[Mu],\[Mu]1]RL2[\[Nu],\[Nu]1]RL3[\[Alpha],\[Alpha]1]RL4[\[Beta],\[Beta]1]RiemannTemp[\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1],
{\[Mu]1,si,si+d-1},{\[Nu]1,si,si+d-1},{\[Alpha]1,si,si+d-1},{\[Beta]1,si,si+d-1}],
{\[Mu],si,si+d-1},{\[Nu],si,si+d-1},{\[Alpha],si,si+d-1},{\[Beta],si,si+d-1}];
(* Originally we wanted to display Riemann components *)
(* But there are so many components and it slows the whole process down too much *)
(* So we are going to skip this for now *)
(*
disp=Flatten[Table[{Row[{"R",UpOrDown[ReplaceIndex[cooo\[LeftDoubleBracket]\[Mu]\[RightDoubleBracket],\[Mu]I]],UpOrDown[ReplaceIndex[cooo\[LeftDoubleBracket]\[Nu]\[RightDoubleBracket],\[Nu]I]],UpOrDown[ReplaceIndex[cooo\[LeftDoubleBracket]\[Alpha]\[RightDoubleBracket],\[Alpha]I]],UpOrDown[ReplaceIndex[cooo\[LeftDoubleBracket]\[Beta]\[RightDoubleBracket],\[Beta]I]]}]\[Rule]mm\[LeftDoubleBracket]\[Mu],\[Nu],\[Alpha],\[Beta]\[RightDoubleBracket]},
{\[Mu],1,d},{\[Nu],1,d},{\[Alpha],1,d},{\[Beta],1,d}]];
disp=Select[disp,(Flatten[Cases[{#},(Row[{__}]\[Rule]cc_)\[Rule]cc]]\[LeftDoubleBracket]1\[RightDoubleBracket]=!=0)&];
*)
Tensor[
TensorType->"RiemannCurvatureTensor",
TensorName->"\!\(\*
StyleBox[\"R\",\nFontSlant->\"Italic\"]\)",
(*NewCode: ExtractFunctions*)
CoordinateSystem->Coordinates[m],
TensorComponents->mm,
StartIndex->si,
Indices->{\[Mu]I,\[Nu]I,\[Alpha]I,\[Beta]I},
(*NewCode: Tooltip for Riemann*)
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->Which[(OptionValue[TooltipStyle]=!={}),OptionValue[TooltipStyle],True, TooltipStyle[m]](*,
TooltipDisplay\[Rule]"Tidal forces encoded here. \[HappySmiley]"*)
(*NewCode: TensorAssumption*),
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
]
];


(* ::Input::Initialization:: *)
(* either input the coordinates or their corresponding numbers *)
Ricci[\[Nu]I_/;TestIndices[\[Nu]I],\[Beta]I_/;TestIndices[\[Beta]I],m_Tensor(*NewCode: Tooltip for Ricci*),opts:OptionsPattern[]](*NewCode: ExtractFunctions*)/;(TestMetricTensor[m]):=Module[
{mm,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,si,cooo,disp,d,cc,Ric,RL1,RL2,RicciTemp},
(*NewCode: ExtractFunctions*)
cooo=Coordinates[m];
d=Length[cooo];
si=StartIndex[m];
(*NewCode: Layer one*)
Ric=Flatten[Cases[m,(RicciComponents->cc_)->cc,1]];
Do[RL1[\[Nu],\[Nu]1]=RaiseLower[ReplaceIndex[\[Nu],\[Nu]I],SubMinus[\[Nu]1],m],{\[Nu],si,si+d-1},{\[Nu]1,si,si+d-1}];
Do[RL2[\[Beta],\[Beta]1]=RaiseLower[ReplaceIndex[\[Beta],\[Beta]I],SubMinus[\[Beta]1],m],{\[Beta],si,si+d-1},{\[Beta]1,si,si+d-1}];
Do[RicciTemp[\[Nu]1,\[Beta]1]=(RicciComponents[SubMinus[\[Nu]1],SubMinus[\[Beta]1]]/.Ric),
{\[Nu]1,si,si+d-1},{\[Beta]1,si,si+d-1}];
mm=Table[
Sum[RL1[\[Nu],\[Nu]1]RL2[\[Beta],\[Beta]1]RicciTemp[\[Nu]1,\[Beta]1],{\[Nu]1,si,si+d-1},{\[Beta]1,si,si+d-1}],
{\[Nu],si,si+d-1},{\[Beta],si,si+d-1}];
(*NewCode: Delete the format of TooltipDisplay for Ricci Tensor*)
(*disp={Row[{"R",UpOrDown[\[Nu]I],UpOrDown[\[Beta]I]}]\[Rule]mm,"Coordinates"\[Rule]cooo};*)
Tensor[
(*NewCode: Comment out RicciCurvatureTensor*)
(*TensorType\[Rule]"RicciCurvatureTensor",*)
TensorName->"\!\(\*
StyleBox[\"R\",\nFontSlant->\"Italic\"]\)",
(*NewCode: ExtractFunctions*)
CoordinateSystem->Coordinates[m],
TensorComponents->mm,
StartIndex->si,
Indices->{\[Nu]I,\[Beta]I},
(*NewCode: Tooltip for Ricci*)
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->Which[(OptionValue[TooltipStyle]=!={}),OptionValue[TooltipStyle],True, TooltipStyle[m]]
(*,TooltipDisplay\[Rule]disp*),
(*NewCode: TensorAssumption*)
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
]
];


(* ::Input::Initialization:: *)
RicciScalar[m_Tensor](*NewCode: ExtractFunctions*)/;(TestMetricTensor[m]):=(RicciScalar/.Flatten[Cases[m,(RicciScalarInvariant->cc_)->cc(*NewCode: RicciScalar one layer*),1]]);

(*NewCode: TensorForm*)
RicciScalar[m_Tensor,Tensor]/;(TestMetricTensor[m]):=
NonMetricTensor[{},RicciScalar[m],"R",CoordinateSystem->Coordinates[m],StartIndex->StartIndex[m],TooltipDisplay-> Null,TooltipStyle-> TooltipStyle[m],TensorAssumption-> TensorAssumption[m],TensorOperator-> TensorOperator[m]]


(* ::Input::Initialization:: *)
(* either input the coordinates or their corresponding numbers *)
(* Internally we build the Tensor with abstract indices before evaluating it with the specified ones *)
(* d>3 *)
Weyl[\[Alpha]I_/;TestIndices[\[Alpha]I],\[Beta]I_/;TestIndices[\[Beta]I],\[Mu]I_/;TestIndices[\[Mu]I],\[Nu]I_/;TestIndices[\[Nu]I],m_Tensor,opts:OptionsPattern[]]/;(TestMetricTensor[m])&&((* check d>3 *)Union[Dimensions[m]][[1]]>3):=Module[
{mm,W,W0,\[Mu],\[Nu],\[Alpha],\[Beta],si,cooo,d,op},
op=OptionValue[WeylOperator];
(*NewCode: ExtractFunctions*)
cooo=Coordinates[m];
d=Length[cooo];
si=StartIndex[m];
W[\[Alpha]_,\[Beta]_,\[Mu]_,\[Nu]_,mm_Tensor]:=Riemann[\[Alpha],\[Beta],\[Mu],\[Nu],mm]-1/(d-2) ((Ricci[\[Alpha],\[Mu],mm]Metric[\[Nu],\[Beta],mm]-Ricci[\[Alpha],\[Nu],mm]Metric[\[Mu],\[Beta],mm])-(Ricci[\[Beta],\[Mu],mm]Metric[\[Nu],\[Alpha],mm]-Ricci[\[Beta],\[Nu],mm]Metric[\[Mu],\[Alpha],mm]))+RicciScalar[mm]/((d-1)(d-2)) (Metric[\[Alpha],\[Mu],mm]Metric[\[Nu],\[Beta],mm]-Metric[\[Alpha],\[Nu],mm]Metric[\[Mu],\[Beta],mm]);
W0=W[ReplaceIndex[\[Alpha],\[Alpha]I],ReplaceIndex[\[Beta],\[Beta]I],ReplaceIndex[\[Mu],\[Mu]I],ReplaceIndex[\[Nu],\[Nu]I],m];
W0=Table[op[W0],{\[Alpha],si,si+d-1},{\[Beta],si,si+d-1},{\[Mu],si,si+d-1},{\[Nu],si,si+d-1}];
Tensor[
TensorType->"WeylCurvatureTensor",
TensorName->"\!\(\*
StyleBox[\"C\",\nFontSlant->\"Italic\"]\)",
CoordinateSystem->cooo,
TensorComponents->W0,
StartIndex->si,
Indices->{\[Alpha]I,\[Beta]I,\[Mu]I,\[Nu]I},
(*NewCode: Tooltip for Weyl*)
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->Which[(OptionValue[TooltipStyle]=!={}),OptionValue[TooltipStyle],True, TooltipStyle[m]](*,
TooltipDisplay\[Rule]"Weyl is the traceless part of the Riemann tensor."*),
(*NewCode: TensorAssumption*)
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
]
];


(* ::Input::Initialization:: *)
(* d<=3 *)
(* Weyl, defined to be the traceless part of Riemann is zero if d =2 or d = 3. *)
(* For 3D we have done a brute force calculation to prove it. *)
(* For 2D the usual formula for Weyl breaks down; Use fact that einstein tensor is zero and 2D metrics are conformally flat to prove *)
(* Riemann has only 1 independent component in 2D so heuristically that means subtracting its trace should yield zero *)
Weyl[\[Alpha]I_/;TestIndices[\[Alpha]I],\[Beta]I_/;TestIndices[\[Beta]I],\[Mu]I_/;TestIndices[\[Mu]I],\[Nu]I_/;TestIndices[\[Nu]I],m_Tensor,opts:OptionsPattern[]]/;(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&((* check d<=3 *)Union[Dimensions[m]][[1]]<=3):=Module[
{mm,W,W0,\[Mu],\[Nu],\[Alpha],\[Beta],si,cooo,d,op},
(*NewCode: ExtractFunctions*)
cooo=Coordinates[m];
d=Length[cooo];
si=StartIndex[m];
(* generate an array of zeroes *)
W0=ConstantArray[0,{d,d,d,d}];
Tensor[
TensorType->"WeylCurvatureTensor",
TensorName->"C",
CoordinateSystem->cooo,
TensorComponents->W0,
StartIndex->si,
Indices->{\[Alpha]I,\[Beta]I,\[Mu]I,\[Nu]I},
TooltipDisplay->"Weyl, being the traceless part of the Riemann tensor, is zero in 2D and 3D."
]
];


(* ::Input::Initialization:: *)
(* Einstein Tensor *)
(* either input the coordinates or their corresponding numbers *)
Einstein[\[Nu]I_/;TestIndices[\[Nu]I],\[Beta]I_/;TestIndices[\[Beta]I],m_Tensor,opts:OptionsPattern[]]/;(*NewCode: ExtractFunctions*)(TestMetricTensor[m]):=Module[
{mm,cooo,si,disp,RicciScalarT,RicciTensorT,MetricT,op,\[Nu]T,\[Beta]T},
op=OptionValue[EinsteinOperator];
RicciScalarT=RicciScalar[m];
(* we will construct Einstein with abstract indices first... *)
RicciTensorT=TensorComponents[Ricci[ReplaceIndex[\[Nu]T,\[Nu]I],ReplaceIndex[\[Beta]T,\[Beta]I],m]];
MetricT=TensorComponents[Metric[ReplaceIndex[\[Nu]T,\[Nu]I],ReplaceIndex[\[Beta]T,\[Beta]I],m]];
mm=RicciTensorT-(MetricT/2)RicciScalarT;mm=op[mm];
(*NewCode: ExtractFunctions*)
si=StartIndex[m];
cooo=Coordinates[m];
(*NewCode: Delete the format of TooltipDisplay for Einstein Tensor*)
(*disp={Row[{"G",UpOrDown[\[Nu]I],UpOrDown[\[Beta]I]}]\[Rule]mm,"Coordinates"\[Rule]cooo};*)
(* ...then we will evaluate it with specified indices which may be non-abstract *)
Tensor[
TensorType->"EinsteinTensor",
TensorName->"\!\(\*
StyleBox[\"G\",\nFontSlant->\"Italic\"]\)",
CoordinateSystem->cooo,
TensorComponents->mm,
StartIndex->si,
Indices->{\[Nu]I,\[Beta]I},
(*NewCode: Tooltip for Einstein*)
TooltipDisplay->OptionValue[TooltipDisplay],
TooltipStyle->Which[(OptionValue[TooltipStyle]=!={}),OptionValue[TooltipStyle],True, TooltipStyle[m]](*,
TooltipDisplay\[Rule]disp*),
(*NewCode: TensorAssumption*)
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
]
];


(* ::Input::Initialization:: *)
Determinant[m_Tensor]/;(TestMetricTensor[m]):=Cases[m,(MetricDeterminant->mmm_)->mmm(*NewCode: Determinant one layer*),1][[1]]

(*NewCode: TensorForm*)
Determinant[m_Tensor,Tensor]/;(TestMetricTensor[m]):=
NonMetricTensor[{},Determinant[m],Row[{"|",TensorName[m],"|"}],CoordinateSystem->Coordinates[m],StartIndex->StartIndex[m],TooltipDisplay-> Null,TooltipStyle-> TooltipStyle[m],TensorAssumption-> TensorAssumption[m],TensorOperator-> TensorOperator[m]]


(* ::Input::Initialization:: *)
(*NewCode: OrthonormalFrameField*)
(*Extract from a metric*)
OrthonormalFrameField[m_Tensor]/;(TestMetricTensor[m]):=
(*Extract both OrthonormalFrameField and InverseOrthonormalFrameField as a list output.*)
{Cases[m,(OrthonormalFrameField->mmm_)->mmm,1][[1]],Cases[m,(InverseOrthonormalFrameField->mmm_)->mmm,1][[1]]}


(* ::Input::Initialization:: *)
(*NewCode: OrthonormalFrameField*)
(*Declare OrthonormalFrameField as a Tensor object. Input a metric w/ OrthonormalFrameField*)OrthonormalFrameField[\[Mu]1_/;TestIndices[\[Mu]1],\[Mu]2_/;TestIndices[\[Mu]2],m_Tensor/;(TestMetricTensor[m])]:=Module[{Flatmetric,invonfft,onfft,invonffm,onffm},
(*Extract Flatmetric*)
Flatmetric=Cases[m,(FlatMetric->fm_)->fm][[1]];
onfft=Cases[m,(OrthonormalFrameField->onf_)->onf,1][[1]];
invonfft=Cases[m,(InverseOrthonormalFrameField->ionf_)->ionf,1][[1]];
onffm=TensorComponents[onfft];
invonffm=TensorComponents[invonfft];
(*Declare w/ NonMetricTensor*)
NonMetricTensor[(*Add a OverHat for first index.*){OverHat[\[Mu]1[[1]]]//(\[Mu]1[[0]]),\[Mu]2},
(*Its TensorComponent differs w.r.t Subscript[\[CurlyEpsilon]^Overscript[a, ^], b], \[CurlyEpsilon]^(Overscript[a, ^]b), Subscript[Subscript[\[CurlyEpsilon], Overscript[a, ^]], b] or (Subscript[\[CurlyEpsilon], Overscript[a, ^]]^b).*)Which[(Sgn[\[Mu]1]===1&&Sgn[\[Mu]2]===-1),(*Subscript[\[CurlyEpsilon]^Overscript[a, ^], b]*)onffm,(Sgn[\[Mu]1]===-1&&Sgn[\[Mu]2]===-1),(*Subscript[Subscript[\[CurlyEpsilon], Overscript[a, ^]], b]=Subscript[\[Eta], ac]Subscript[\[CurlyEpsilon]^Overscript[c, ^], b]*)Flatmetric . onffm,(Sgn[\[Mu]1]===-1&&Sgn[\[Mu]2]===1),(*Subscript[\[CurlyEpsilon], Overscript[a, ^]]^b*)invonffm,(Sgn[\[Mu]1]===1&&Sgn[\[Mu]2]===1),(*\[CurlyEpsilon]^(Overscript[a, ^]b)=\[Eta]^acSubscript[\[CurlyEpsilon], Overscript[c, ^]]^b*)Flatmetric . invonffm],"\[CurlyEpsilon]",CoordinateSystem->Coordinates[m],TooltipStyle-> TooltipStyle[m]]];


(* ::Input::Initialization:: *)
(*NewCode: OrthonormalFrameField*)
(*Input a metric and FlatMetric*)
OrthonormalFrameField[m_Tensor,fm_List,opts:OptionsPattern[]]/;(TestMetricTensor[m]):=
(*Trigger Tensor code. See: OrthonormalFrameField Tensor part*)m/.{(FlatMetric->fmm_)->(FlatMetric->fm),(OrthonormalFrameField->fmm_)->(OrthonormalFrameField->OptionValue[OrthonormalFrameField]),
(InverseOrthonormalFrameField->fmm_)->(InverseOrthonormalFrameField->OptionValue[InverseOrthonormalFrameField]),((OrthonormalFrameFieldOperator->onffop_)->(OrthonormalFrameFieldOperator->OptionValue[OrthonormalFrameFieldOperator])),((TestOrthonormalFrameField->checkonff_)->(TestOrthonormalFrameField->OptionValue[TestOrthonormalFrameField])),
((OrthonormalFrameFieldIndices->onffidx_)->(OrthonormalFrameFieldIndices->OptionValue[OrthonormalFrameFieldIndices]))};

(*Declare OrthonormalFrameField as a Tensor object. Input a metric w/o OrthonormalFrameField and FlatMetric.*)
OrthonormalFrameField[\[Mu]1_/;TestIndices[\[Mu]1],\[Mu]2_/;TestIndices[\[Mu]2],m_Tensor/;(TestMetricTensor[m]),fm_List,opts:OptionsPattern[]]:=Module[{newm},newm=OrthonormalFrameField[m,fm,OrthonormalFrameFieldOperator->OptionValue[OrthonormalFrameFieldOperator],TestOrthonormalFrameField->OptionValue[TestOrthonormalFrameField],
OrthonormalFrameFieldIndices->OptionValue[OrthonormalFrameFieldIndices]];
Which[OptionValue[TestOrthonormalFrameField]===True,
{OrthonormalFrameField[\[Mu]1,\[Mu]2,newm[[3]]],newm[[4]],newm[[5]]},True,OrthonormalFrameField[\[Mu]1,\[Mu]2,newm[[3]]]]];

(*NewCode: Second strategy of ONFF*)
OrthonormalFrameField[m_Tensor/;TestMetricTensor[m],eigens_List,order_List,FlatMetric-> fm_List,opts:OptionsPattern[]]/;((Dimensions[eigens]==={2,CoordinatesDimension[m]})&&(Length[order]===CoordinatesDimension[m])&&(Length[fm]===CoordinatesDimension[m])):=Module[{Flatmetric,g,ginv,d,rotm,valuesqrt,ONFFm,ONFFinvm,output,onff,invonff,idx,matrix,onffop,cc,checkonff,tempm,ONFFt,ONFFinvt,\[Alpha],\[Mu],coord,onffidx,ONFFtidx,ONFFinvtidx,eigenvalue,eigenvector,i,Listt},
onffop=OptionValue[OrthonormalFrameFieldOperator];
checkonff=OptionValue[TestOrthonormalFrameField];
onffidx=OptionValue[OrthonormalFrameFieldIndices];
idx=Indices[m];
matrix=TensorComponents[m];
coord=Coordinates[m];
Which[MatchQ[idx,{SubMinus[_],SubMinus[_]}],g=matrix;ginv=(Inverse[matrix]//onffop),MatchQ[idx,{SuperMinus[_],SuperMinus[_]}],ginv=matrix;g=(Inverse[matrix]//onffop)];
d=Length[fm];
eigenvalue=Table[eigens[[1,order[[i]]]],{i,1,d}];
eigenvector=Table[eigens[[2,order[[i]]]],{i,1,d}];
Flatmetric=DiagonalMatrix[fm];
rotm=Table[(Normalize[eigenvector[[i]]]//onffop),{i,1,d}];
valuesqrt=(Sqrt[#]&/@(Flatmetric . eigenvalue))//onffop;
ONFFm=(Table[valuesqrt[[i]] rotm[[i]],{i,1,d}])//onffop;
ONFFinvm=(Flatmetric . ONFFm . ginv)//onffop;
Listt=Apply[List,m];
ONFFtidx=Which[(onffidx=!=Null)&&((Head[#]&/@onffidx)==={Symbol,Symbol}),{SuperMinus[\!\(\*OverscriptBox[\(onffidx\[LeftDoubleBracket]1\[RightDoubleBracket]\), \(^\)]\)],SubMinus[onffidx[[2]]]},True,{SuperMinus[\!\(\*OverscriptBox[\(\[Alpha]\), \(^\)]\)],SubMinus[\[Mu]]}];
ONFFinvtidx=Which[(onffidx=!=Null)&&((Head[#]&/@onffidx)==={Symbol,Symbol}),{SubMinus[(\!\(\*OverscriptBox[\(onffidx\[LeftDoubleBracket]1\[RightDoubleBracket]\), \(^\)]\))],SuperMinus[onffidx[[2]]]},True,{SubMinus[\!\(\*OverscriptBox[\(\[Alpha]\), \(^\)]\)],SuperMinus[\[Mu]]}];
ONFFt=Listt/.{(FlatMetric->fmmmm_)->(FlatMetric->Flatmetric),(*(OrthonormalFrameField\[Rule]onf_)\[Rule]Nothing,(InverseOrthonormalFrameField\[Rule]ionf_)\[Rule]Nothing,(OrthonormalFrameFieldOperator\[Rule]oop_)\[Rule]Nothing,(TestOrthonormalFrameField\[Rule]conf_)\[Rule]Nothing,*)(TensorType->tt_)-> Nothing,
(TensorName->tn_)->(TensorName->"\[CurlyEpsilon]") ,
(Indices->idxx_)-> (Indices->ONFFtidx),
(TensorComponents->tc_)-> (TensorComponents->ONFFm)(*,
(MetricDeterminant\[Rule]md_)\[Rule]Nothing ,
(ChristoffelComponents\[Rule]ccc_)\[Rule]Nothing ,
(RiemannComponents\[Rule]rc_)\[Rule]Nothing ,
(RicciComponents\[Rule]ric_)\[Rule]Nothing ,
(RicciScalarInvariant\[Rule]rsi_)\[Rule]Nothing ,
(OrthonormalFrameFieldIndices\[Rule]onffidxxx_)\[Rule]Nothing *)};
ONFFinvt=ONFFt/.{(Indices->idxx_)-> (Indices->ONFFinvtidx),
(TensorComponents->tc_)-> (TensorComponents->ONFFinvm)
};
ONFFt=Apply[Tensor,ONFFt];
ONFFinvt=Apply[Tensor,ONFFinvt];
(*ONFFt=NonMetricTensor[ONFFtidx,
ONFFm,"\[CurlyEpsilon]",CoordinateSystem\[Rule]coord];
ONFFinvt=NonMetricTensor[ONFFinvtidx,
ONFFinvm,"\[CurlyEpsilon]",CoordinateSystem\[Rule]coord];*)
(*Replace w/ calculation result.*)
tempm=Listt/.{(FlatMetric->fmmmm_)->(FlatMetric->Flatmetric),(OrthonormalFrameField->onf_)->(OrthonormalFrameField->ONFFt),(InverseOrthonormalFrameField->ionf_)->(InverseOrthonormalFrameField->ONFFinvt),(OrthonormalFrameFieldOperator->oop_)->(OrthonormalFrameFieldOperator->Null),(TestOrthonormalFrameField->conf_)->(TestOrthonormalFrameField->Null)};
tempm=Apply[Tensor,tempm];
output={ONFFt,ONFFinvt,tempm};
Which[checkonff===True,output=Append[Append[output,
(*Subscript[g, cd]=Subscript[\[CurlyEpsilon]^Overscript[a, ^], c]Subscript[\[Eta], ab]Subscript[\[CurlyEpsilon]^Overscript[b, ^], d]*)
(Transpose[ONFFm] . Flatmetric . ONFFm==g)//onffop],
(*Subscript[\[Eta], cd]=Subscript[\[CurlyEpsilon], Overscript[c, ^]]^aSubscript[g, ab]Subscript[\[CurlyEpsilon], Overscript[d, ^]]^b*)
((ONFFinvm . g . Transpose[ONFFinvm]==Flatmetric)//onffop)]];
output
]

(*OrthonormalFrameField[m_Tensor,fm_List,opts:OptionsPattern[]]/;(Cases[m,(TensorType\[Rule]tt_)\[Rule]tt]==={"Metric"}):=Module[{matrix,idx,eigens,Flatmetric,g,ginv,d,rotm,valuesqrt,ONFFm,ONFFinvm,op,mtemp,fmm,onff},
matrix=m//TensorComponents;
idx=Indices[m];
op=OptionValue[OrthonormalFrameFieldOperator];
Which[MatchQ[idx,{SubMinus[_],SubMinus[_]}],g=matrix;ginv=(Inverse[matrix]//op),MatchQ[idx,{SuperMinus[_],SuperMinus[_]}],ginv=matrix;g=(Inverse[matrix]//op)];
Flatmetric=DiagonalMatrix[fm];
eigens=Eigensystem[g];
d=Length[fm];
rotm=Table[(Normalize[eigens\[LeftDoubleBracket]2,i\[RightDoubleBracket]]//op),{i,1,d}];
valuesqrt=(Sqrt[#]&/@(Flatmetric.eigens\[LeftDoubleBracket]1\[RightDoubleBracket]))//op;
ONFFm=(Table[valuesqrt\[LeftDoubleBracket]i\[RightDoubleBracket] rotm\[LeftDoubleBracket]i\[RightDoubleBracket],{i,1,d}]//op);
ONFFinvm=Flatmetric.ONFFm.ginv;
mtemp=Which[(Cases[m,(FlatMetric\[Rule]fmm_)\[Rule]fmm]==={}),Append[m,FlatMetric\[Rule]Flatmetric],True,m/.{(FlatMetric\[Rule]fmm_)\[Rule](FlatMetric\[Rule]Flatmetric)}];
Which[(Cases[mtemp,(OrthonormalFrameField\[Rule]onff_)\[Rule]onff]==={}),{ONFFm,ONFFinvm,Append[Append[mtemp,OrthonormalFrameField\[Rule]ONFFm],InverseOrthonormalFrameField\[Rule]ONFFinvm]},True,{ONFFm,ONFFinvm,mtemp/.{(OrthonormalFrameField\[Rule]onff_)\[Rule](OrthonormalFrameField\[Rule]ONFFm),(InverseOrthonormalFrameField\[Rule]onffinv_)\[Rule](InverseOrthonormalFrameField\[Rule]ONFFinvm)}}]
];*)


(* ::Input::Initialization:: *)
(*NewCode: New ContractTensors*)
(*ContractTensors[wholeBunchOfStuff_/;If[TestRepeatedIndices[wholeBunchOfStuff],True,Message[TestRepeatedIndices::TestRepeatedIndicesFalse,wholeBunchOfStuff];False]]:=TensorsProduct[wholeBunchOfStuff];*)


(* ::Input::Initialization:: *)
(*(* The main function for ContractTensors to act as a TensorProduct of sorts for Tensor objects *)
(* Note: Assigning upvalues for Tensor involving TensorProduct yields levels too deep for MMA to handle;
that's why we need ContractTensors *)
(* one Tensor *)
(*NewCode: Redundant TagSetDelay*)
ContractTensors[tt_Tensor]:=tt;

ContractTensors[tt_Tensor,Tensor]:=tt;
(*See: Operator Linearity & Operator ProductRule*)

(* Thread over Plus automatically *)
(*ContractTensors[mm_Plus]:=(ContractTensors/@mm); *)
(*NewCode: TensorComponents and ContractTensors*)
ContractTensors[{}]:=1;

(* Pull out non-Tensor objects *)
ContractTensors[(mm_Times|mm_List/;(mm=!={}))]:=Module[{allTensors,therest,tensorplus,Listmm=(Apply[List,mm]),tp},
allTensors=Times@@Cases[Listmm,_Tensor,1];
tensorplus=List@@Expand[Times@@Cases[Listmm,tp_Plus/;(!TestExpressionForm[tp]),1]];
therest=Times@@DeleteCases[Listmm,(_Tensor|tp_Plus/;(!TestExpressionForm[tp])),1];
Which[(tensorplus=!={}),
therest Plus@@(ContractTensors[allTensors #]&/@tensorplus),(tensorplus==={}),
therest ContractTensors[allTensors]
]
 ]/;(Union[(Head/@(List@@mm))]=!={Tensor});

(*NewCode: ContractTensors ExpressionForm*)
ContractTensors[stuff_/;(TestExpressionForm[stuff](*&&(Head[stuff]=!=Plus)&&(Head[stuff]=!=Times)*))]:=stuff;

(* Tensor product of more than one Tensors with same CoordinateSystem *)
(* Case 1: Every Tensor in the product has the same coordinate system *)
(*NewCode: TensorComponents and ContractTensors*)
ContractTensors[(tt_Times|tt_List/;(tt=!={}))]:=Module[
{tensorproduct,allindices,tensornames,scalartensor=1,othertensor=1,listtt=Apply[List,tt],ii,aaa,bbb},
Which[MatchQ[listtt,{aaa_/;TestScalarTensor[aaa],(bbb_/;(Head[bbb]===Tensor)(*||(Head[bbb]===Plus)*))}],
ContractTensors[listtt,Tensor],
MatchQ[listtt,{bbb_Tensor}],
listtt\[LeftDoubleBracket]1\[RightDoubleBracket],
True,
(* perform a tensor product *)
Do[Which[(RemoveUnderBarredIndices[Indices[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]]]==={}),scalartensor=scalartensor TensorComponents[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]],(RemoveUnderBarredIndices[Indices[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]]]=!={}),othertensor=othertensor listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]],{ii,1,Length[listtt]}];
tensorproduct=scalartensor Which[(Head[othertensor]===Times),TensorProduct[Sequence@@(TensorComponents/@(List@@othertensor))],True,TensorComponents[othertensor]];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@(List@@othertensor))];
(* Tensor all the names *)
(*tensornames=TensorProduct[Sequence@@(*NewCode: ExtractFunctions*)(TensorName[#]&/@(List@@tt))];*)
tensornames=TensorName[tt];
(* output Tensor will inherit properties of the first Tensor *)
(listtt)\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)}]
]/;((* check tensor product *)(* everybody is a Tensor *)((Union[Head/@(List@@tt)]==={Tensor})(*||(Union[Head/@(List@@tt)]==={Tensor,Plus})||(Union[Head/@(List@@tt)]==={Plus})||(Union[Head/@(List@@tt)]==={Plus,Tensor})*))&&(* all coordinate systems are the same *)(Length[Union[Coordinates/@Cases[tt,Tensor[___]]]]===1)(*&&((* no Metrics *)Intersection[Union[Cases[{tt},(TensorType\[Rule]xx_)\[Rule]xx,\[Infinity]]],{"Metric"}]==={})*));

(* Case 2: Not All Tensors Have Same Coordinate Systems *)
ContractTensors[tt_Times]:=Module[
{tensorproduct,test,t1,t2},
(* two Tensors are considered the same if their Coordinates are the same *)
(* Coordinates must be exactly the same -- including order *)
test[t1_Tensor,t2_Tensor]:=(Coordinates[t1]===Coordinates[t2]);
(* group Tensors according to whether they have the same Coordinates *)
tensorproduct=Gather[(List@@tt),test];
(* Only ContractTensors on Tensors w the same Coordinates *)
Times@@(ContractTensors[Times@@#]&/@tensorproduct)
]/;((* check tensor product *)(* everybody is a Tensor *)(Union[Head/@(List@@tt)]==={Tensor})&&(* not all coordinate systems are the same *)(Length[Union[Coordinates/@Cases[tt,Tensor[___]]]]>1))

(*Wei Hao's ContractTensors*)
(*ContractTensors[tt_List/;(tt=!={})]:=Module[
{tensorproduct,allindices,tensornames,scalartensor=1,othertensor=1,ii,aaa,bbb},
Which[MatchQ[tt,{aaa_/;TestScalarTensor[aaa],(bbb_/;(Head[bbb]===Tensor)||(Head[bbb]===Plus))}],
ContractTensors[tt,Tensor],
True,
(* perform a tensor product *)
Do[Which[(Indices[tt\[LeftDoubleBracket]ii\[RightDoubleBracket]]==={}),scalartensor=scalartensor tt\[LeftDoubleBracket]ii\[RightDoubleBracket],(Indices[tt\[LeftDoubleBracket]ii\[RightDoubleBracket]]=!={}),othertensor=othertensor tt\[LeftDoubleBracket]ii\[RightDoubleBracket]],{ii,1,Length[tt]}];
tensorproduct=scalartensor Which[(Head[othertensor]===Times),TensorProduct[Sequence@@(TensorComponents/@(List@@othertensor))],True,TensorComponents[othertensor]];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@(tt))];
(* Tensor all the names *)
tensornames=TensorProduct[Sequence@@(*NewCode: ExtractFunctions*)(TensorName[#]&/@(tt))];
(* output Tensor will inherit properties of the first Tensor *)
tt\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)}]
]/;((* check tensor product *)(* everybody is a Tensor *)((Union[Head/@tt]==={Tensor})||(Union[Head/@tt]==={Tensor,Plus})||(Union[Head/@tt]==={Plus})||(Union[Head/@tt]==={Plus,Tensor}))&&(* all coordinate systems are the same *)(Length[Union[Coordinates/@Cases[tt,Tensor[___]]]]===1));*)

(*NewCode: TensorForm*)
ContractTensors[(tt_Times|tt_List),Tensor]:=Module[
{tensorproduct,allindices,tensornames,output,scalartensor=1,othertensor=1,listtt=Apply[List,tt],ii},
(* perform a tensor product *)
Do[Which[(RemoveUnderBarredIndices[Indices[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]]]==={}),scalartensor=scalartensor TensorComponents[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]],(RemoveUnderBarredIndices[Indices[listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]]]=!={}),othertensor=othertensor listtt\[LeftDoubleBracket]ii\[RightDoubleBracket]],{ii,1,Length[listtt]}];
tensorproduct=scalartensor Which[(Head[othertensor]===Times),TensorProduct[Sequence@@(TensorComponents/@(List@@othertensor))],True,TensorComponents[othertensor]];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@(List@@tt))];
(* Tensor all the names *)
(*tensornames=TensorProduct[Sequence@@(*NewCode: ExtractFunctions*)(TensorName[#]&/@(listtt))];*)
tensornames=TensorName[tt];
(* output Tensor will inherit properties of the first Tensor *)
output=(listtt)\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)};
Which[TestExpressionForm[output],((listtt)\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]{}),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]output)}),True,output]
]/;((* check tensor product *)(* everybody is a Tensor *)(Union[Head/@(List@@tt)]==={Tensor})&&(* all coordinate systems are the same *)(Length[Union[Coordinates/@(List@@tt)]]===1)(*&&((* no Metrics *)Intersection[Union[Cases[{tt},(TensorType\[Rule]xx_)\[Rule]xx,\[Infinity]]],{"Metric"}]==={})*)&&(Union[TestScalarTensor/@(List@@tt)]==={False}));

(*NewCode: TensorForm*)
ContractTensors[Times[scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),t_Tensor],Tensor]:=t/.{(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule](TensorComponents[scalar] mx)) (*,(TensorName\[Rule]tn_)\[RuleDelayed](TensorName\[Rule]Which[TensorNameNoPart[scalar]=!={},TensorName[scalar],True,ToString[scalar,InputForm]]<>tn)*),(TensorName\[Rule]tn_)\[RuleDelayed](TensorName\[Rule](*TimesScalar*)TensorName[scalar t](*(TensorName[scalar][tn])*))}

ContractTensors[(List[scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar]),(t_Tensor|t_Plus)]|List[t_Tensor,scalar_/;(TestScalarTensor[scalar])||(TestExpressionForm[scalar])]),Tensor]:=Module[{tp},
Which[(Head[t]===Tensor),t/.{(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule](TensorComponents[scalar] mx)) ,(TensorName\[Rule]tn_)\[RuleDelayed](TensorName\[Rule](*TimesScalar*)TensorName[scalar t])},
(Head[t]===Plus),
tp=TensorPlus[t];
tp/.{(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule](TensorComponents[scalar] mx)) ,(TensorName\[Rule]tn_)\[RuleDelayed](TensorName\[Rule]TimesScalarTensorName[scalar t])}]
]*)


(* ::Input::Initialization:: *)
(*(* The main function for TensorsProduct to act as a TensorProduct of sorts for Tensor objects *)
(* Note: Assigning upvalues for Tensor involving TensorProduct yields levels too deep for MMA to handle;
that's why we need TensorsProduct *)
(* one Tensor *)
TensorsProduct[tt_Tensor]:=ReleaseHold[tt]
(* Thread over Plus automatically *)
TensorsProduct[mm_]:=(TensorsProduct/@ReleaseHold[mm])/;(Head[mm]===Plus); 
(* Pull out non-Tensor objects *)
TensorsProduct[mm_]:=Module[{allTensors,therest,releasem},
releasem=ReleaseHold[mm];
allTensors=Times@@Cases[(List@@releasem),_Tensor];
therest=Times@@DeleteCases[(List@@releasem),_Tensor];
therest TensorsProduct[allTensors]]/;(Head[mm]===Times)&&(Union[(Head/@(List@@mm))]=!={Tensor});
TensorsProduct[1]:=1;
(* Tensor product of more than one Tensors with same CoordinateSystem *)
(* Case 1: Every Tensor in the product has the same coordinate system *)
(*NewCode: TensorsProduct now with order*)
TensorsProduct[tt_]:=Module[
{tensorproduct,allindices,tensornames,ListwithOrder,holdtt,lgth},
(*Unprotect[Times,HoldForm];*)
holdtt=HoldForm[tt];
(*Protect[Times,HoldForm];*)
lgth=Length[holdtt\[LeftDoubleBracket]1\[RightDoubleBracket]/.Times\[Rule]List];
ListwithOrder=Which[lgth===1,ReleaseHold[holdtt],Cases[holdtt,_Symbol]=!={},Table[ReleaseHold[holdtt]\[LeftDoubleBracket]i\[RightDoubleBracket],{i,1,lgth}],lgth>1,Table[holdtt\[LeftDoubleBracket]1,i\[RightDoubleBracket],{i,1,lgth}]];
(* perform a tensor product *)
tensorproduct=TensorProduct[Sequence@@(TensorComponents/@ListwithOrder)];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@ListwithOrder)];
(* Tensor all the names *)
tensornames=TensorProduct[Sequence@@(Cases[#,(TensorName\[Rule]name_)\[RuleDelayed]name,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]&/@(List@@tt))];
(* output Tensor will inherit properties of the first Tensor *)
(List@@tt)\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)}
]/;((* check tensor product *)(Head[tt]===Times)&&(* everybody is a Tensor *)(Union[Head/@(List@@tt)]==={Tensor})&&(* all coordinate systems are the same *)(Length[Union[Coordinates/@(List@@tt)]]===1)(*&&((* no Metrics *)Intersection[Union[Cases[{tt},(TensorType\[Rule]xx_)\[Rule]xx,\[Infinity]]],{"Metric"}]==={})*));
(* Case 2: Not All Tensors Have Same Coordinate Systems *)
TensorsProduct[tt_]:=Module[
{tensorproduct,test,t1,t2},
(* two Tensors are considered the same if their Coordinates are the same *)
(* Coordinates must be exactly the same -- including order *)
test[t1_Tensor,t2_Tensor]:=(Coordinates[t1]===Coordinates[t2]);
(* group Tensors according to whether they have the same Coordinates *)
tensorproduct=Gather[(List@@tt),test];
(* Only TensorsProduct on Tensors w the same Coordinates *)
Times@@(TensorsProduct[Times@@#]&/@tensorproduct)
]/;((* check tensor product *)(Head[tt]===Times)&&(* everybody is a Tensor *)(Union[Head/@(List@@tt)]==={Tensor})&&(* not all coordinate systems are the same *)(Length[Union[Coordinates/@(List@@tt)]]>1))
(*TensorsProduct[tt_List]:=Module[
{tensorproduct,allindices,tensornames,ListwithOrder,holdtt},
(* perform a tensor product *)
tensorproduct=TensorProduct[Sequence@@(TensorComponents/@tt)];
(* Join all indices to form index structure of Tensor Product *)
allindices=Join[Sequence@@(Indices/@tt)];
(* Tensor all the names *)
tensornames=TensorProduct[Sequence@@(Cases[#,(TensorName\[Rule]name_)\[RuleDelayed]name,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]&/@(List@@tt))];
(* output Tensor will inherit properties of the first Tensor *)
(List@@tt)\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(TensorName\[Rule]xxx_)\[Rule](TensorName\[Rule]tensornames),
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)}
]*)*)


(* ::Input::Initialization:: *)
(* Take the product of two or more tensors and sum over repeated indices *)
(* contraction between 2g's, g non-g, or both non-g's *)
(* (I) contract of 2 g's *)
(* TensorsProduct[Times[t1___,m1_,t2___,m2_,t3___]]:=; *)
(* Right now we do not check Dimensions are the same before we do TensorsProduct *)
(* old code
TensorsProduct[Times[tt__]]/;Union[Head/@(List@@Times[tt])]==={Tensor}:=Block[
{tensorproduct,allindices,repeatedindices,ix},
(* first perform a tensor product *)
tensorproduct=TensorProduct[Sequence@@(TensorComponents/@(List@@Times[tt]))];
(* extract repeated indices *)
ix=Indices/@(List@@Times[tt]);
repeatedindices=CollectRepeatedIndices[Sequence@@ix];
(* sum over repeated indices using TensorContract *)
(* list of all indices w/ Sub/SuperMinus removed from repeated ones *)
allindices=(Join[Sequence@@ix]/.Flatten[{(SuperMinus[#]\[Rule]#),(SubMinus[#]\[Rule]#)}&/@repeatedindices]);
tensorproduct=TensorContract[
tensorproduct,
(* {{pair 1},{pair 2},...} *)
Flatten[Position[allindices,#]]&/@repeatedindices
];
(* remove repeated indices *)
allindices=DeleteCases[allindices,Alternatives@@repeatedindices];
(* return Tensor *)
(* output Tensor will inherit properties of the first Tensor *)
(* output Tensor indices are inherited from tt, from left to right, with repeated indices discarded *)
(List@@Times[tt])\[LeftDoubleBracket]1\[RightDoubleBracket]/.{
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)
}
]; *)


(* ::Input::Initialization:: *)
(* SwapIndices returns tt except the indices are permuted into idx; i.e. Indices[tt] \[Rule] idx *)
(* idx does not include the UnderBarred indices in tt *)
SwapIndices[tt_Tensor,idx_List]/;((Sort[RemoveUnderBarredIndices[Indices[tt]]]===Sort[idx])&&(Union[(TestIndices[#/.UnderBar[ss_]->ss]&/@idx)]==={True})):=tt/.{
(* replace TensorComponents *)
(TensorComponents->ss_):>(TensorComponents->Transpose[
TensorComponents[tt],Flatten[Position[(* this is the ordering of indices we want *)idx,#]&/@RemoveUnderBarredIndices[Indices[tt]]]]),
(* replace Indices but remember not to throw away the UnderBarred Indices *)
(Indices->ss_):>(Indices->(ss/.Thread[Rule[RemoveUnderBarredIndices[Indices[tt]],idx]]))
};


(* ::Input::Initialization:: *)
(* MoveIndices[tt_Tensor,idx_List,m_Tensor] returns tt with its indices moved/replaced to idx *)
(* idx does not include the UnderBarred indices in tt but has to contain the same number of indices *)
(* idx may also contain coordinates; i.e., MoveIndices should be able to do evaluate specific components of the tensor *)
(* new code *)

MoveIndices[tt_Tensor,idx_List,m_Tensor]/;((* check that there are same number of indices in tt and idx *)(Length[RemoveUnderBarredIndices[Indices[tt]]]===Length[idx])&&((* check idx contain proper indices *)(*NewCode: MoveIndices for scalar*)(Union[(TestIndices/@idx)]==={True})||(Union[(TestIndices/@idx)]==={}))&&((* check m is a Metric; we are going use it to move the indices with *)TestMetricTensor[m])(*NewCode: OrthonormalFrameField*)&&(*check if the type of indices are all preserved*)((MatchQ[Union[Thread[(OverHatSgn[#]&/@idx) (OverHatSgn[#]&/@RemoveUnderBarredIndices[Indices[tt]])]],({}|{1})])&&(*We can only move on type of index, in coordinate basis or orthonormal basis*)TestMoveOnlyOneType[tt,idx])):=Module[
{outputindices,ttix,outputtensor,s,g,Invg,xxx123,i123,\[Mu],\[Nu]},
(* extract relevant indices of tt *)
ttix=RemoveUnderBarredIndices[Indices[tt]];
(* we will replace the indices of tt with idx *)
outputindices=Thread[Rule[ttix,idx]];
(* start with *)
(*NewCode: Normal in MoveIndices*)
outputtensor=Normal[TensorComponents[tt]];
(* first compute metric and inverse and extract TensorComponents of tt *)
g=TensorComponents[Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m]];
Invg=TensorComponents[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]];
(* we will run through all relevant indices of tt *)
(* compare each slot with the corresponding one in idx *)
Do[
Which[
(* different sgn; append appropriate g or Inv *)
(* raise index; contract Subscript[T, i1 i2 ... j ... iD] g^(j is); then transpose to get the right ordering of indices *)
(* last index does not need to be further transposed! *)
(Sgn[ttix[[s]]]===-1)&&(Sgn[idx[[s]]]===1),
outputtensor=Which[
s<Length[idx],Transpose[TensorContract[TensorProduct[outputtensor,Invg],{{s,Length[idx]+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,Length[idx]],s}],
s===Length[idx],TensorContract[TensorProduct[outputtensor,Invg],{{s,Length[idx]+1}}]],
(* lower index; contract T^(i1 i2 ... j ... iD) Subscript[g, j is]; then transpose to get the right ordering of indices *)
(* last index does not need to be further transposed! *)
(Sgn[ttix[[s]]]===1)&&(Sgn[idx[[s]]]===-1),
outputtensor=Which[
s<Length[idx],Transpose[TensorContract[TensorProduct[outputtensor,g],{{s,Length[idx]+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,Length[idx]],s}],
s===Length[idx],TensorContract[TensorProduct[outputtensor,g],{{s,Length[idx]+1}}]]
],{s,1,Length[idx]}];
(* output *)
tt/.{(TensorComponents->xxx123_)->(TensorComponents->outputtensor),(Indices->i123_):>(Indices->(i123/.outputindices))}
];

(*NewCode: OrthonormalFrameField*)
MoveIndices[tt_Tensor,idx_List,m_Tensor]/;((* check that there are same number of indices in tt and idx *)(Length[RemoveUnderBarredIndices[Indices[tt]]]===Length[idx])&&((* check idx contain proper indices *)Union[(TestIndices/@idx)]==={True})&&((* check m is a Metric; we are going use it to move the indices with *)TestMetricTensor[m])&&(Cases[{m},(OrthonormalFrameField->onff_)->onff,1]=!={Null})&&(Cases[{m},(InverseOrthonormalFrameField->invonff_)->invonff,1]=!={Null})&&(*The cases aren't taken care by previous code.*)!((Union[(*Thread[(Which[((Head[#\[LeftDoubleBracket]1\[RightDoubleBracket]])===Symbol),1,((Head[#\[LeftDoubleBracket]1\[RightDoubleBracket]])===OverHat),-1]&/@idx) (Which[((Head[#\[LeftDoubleBracket]1\[RightDoubleBracket]])===Symbol),1,((Head[#\[LeftDoubleBracket]1\[RightDoubleBracket]])===OverHat),-1]&/@Indices[tt])]*)Thread[(OverHatSgn[#]&/@idx) (OverHatSgn[#]&/@RemoveUnderBarredIndices[Indices[tt]])]]==={1})&&TestMoveOnlyOneType[tt,idx])(*&&(Cases[tt,(TensorType\[Rule]ttt_)\[Rule]ttt]=!={"Metric"})*)):=Module[
{outputindices,ttix,outputtensor,i123,rank,idxlist,tttemp,idxlist2,fm,onff,invonff,fmT,\[Mu],\[Nu],cc,s,ii},
(*basic arguments*)
rank=RankNumber[idx];
ttix=RemoveUnderBarredIndices[Indices[tt]];
(*Obtain indices list with indices only be moved by metric.*)
idxlist={};
Do[Which[(Sgn[ttix[[ii]]] Sgn[idx[[ii]]]===-1)&&OverHatSgn[ttix[[ii]]]===-1,idxlist=Append[idxlist,(ttix[[ii,1]]//idx[[ii,0]])],True,idxlist=Append[idxlist,ttix[[ii]]]],{ii,1,rank}];
(*First MoveIndices with metric*)
tttemp=MoveIndices[tt,idxlist,m];
(*Obtain indices list with indices only be moved by FlatMetric.*)
idxlist2={};
Do[idxlist2=Append[idxlist2,(idxlist[[ii,1]]//idx[[ii,0]])],{ii,1,rank}];
(*Extract FlatMetric and orthonormal frame field stuff.*)
fm=Cases[m,(FlatMetric->cc_)->cc,1][[1]];
onff=TensorComponents[Cases[m,(OrthonormalFrameField->cc_)->cc,1][[1]]];
invonff=TensorComponents[Cases[m,(InverseOrthonormalFrameField->cc_)->cc,1][[1]]];
(*Declare FlatMetric as a Tensor*)
fmT=Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],fm,TensorName->"g",CoordinateSystem->Coordinates[m],StartIndex->StartIndex[m]];
(*Second MoveIndices with FlatMetric.*)
tttemp=MoveIndices[tttemp,idxlist2,fmT];
(* we will replace the indices of tt with idx *)
outputindices=Thread[Rule[ttix,idx]];
(* start with *)
outputtensor=TensorComponents[tt];
(* we will run through all relevant indices of tt *)
(* compare each slot with the corresponding one in idx *)
(*Transform between orthonormal coordinate and basis coordinate.*)
Do[
Which[
(*Subscript[Overscript[\[Alpha], ^], -]\[Rule]Subscript[\[Mu], -]*)
(Sgn[ttix[[s]]]===-1)&&(OverHatSgn[ttix[[s]]]===1)&&(Sgn[idx[[s]]]===-1)&&(OverHatSgn[idx[[s]]]===-1),
outputtensor=Which[
s<rank,Transpose[TensorContract[TensorProduct[outputtensor,(*Contract w/ Subscript[\[Epsilon]^Overscript[\[Alpha], ^], \[Mu]]*)onff],{{s,rank+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,rank],s}],
(*Least index doesn't need a Transpose.*)s===rank,TensorContract[TensorProduct[outputtensor,(*Contract w/ Subscript[\[Epsilon]^Overscript[\[Alpha], ^], \[Mu]]*)onff],{{s,rank+1}}]],
(*Subscript[\[Mu], -]\[Rule]Subscript[Overscript[\[Alpha], ^], -]*)
(Sgn[ttix[[s]]]===-1)&&(OverHatSgn[ttix[[s]]]===-1)&&(Sgn[idx[[s]]]===-1)&&(OverHatSgn[idx[[s]]]===1),
outputtensor=Which[
s<Length[idx],Transpose[TensorContract[TensorProduct[outputtensor,(*Contract w/ Subscript[\[Epsilon], Overscript[\[Alpha], ^]]^\[Mu]*)invonff],{{s,Length[idx]+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,Length[idx]],s}],
s===Length[idx],TensorContract[TensorProduct[outputtensor,invonff],{{s,Length[idx]+1}}]],
(*\[Mu]^-\[Rule]Overscript[\[Alpha], ^]^-*)
(Sgn[ttix[[s]]]===1)&&(OverHatSgn[ttix[[s]]]===-1)&&(Sgn[idx[[s]]]===1)&&(OverHatSgn[idx[[s]]]===1),
outputtensor=Which[
s<Length[idx],Transpose[TensorContract[TensorProduct[outputtensor,(*Contract w/ Subscript[\[Epsilon]^Overscript[\[Alpha], ^], \[Mu]]*)onff],{{s,Length[idx]+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,Length[idx]],s}],
s===Length[idx],TensorContract[TensorProduct[outputtensor,onff],{{s,Length[idx]+1}}]],
(*Overscript[\[Alpha], ^]^-\[Rule]\[Mu]^-*)
(Sgn[ttix[[s]]]===1)&&(OverHatSgn[ttix[[s]]]===1)&&(Sgn[idx[[s]]]===1)&&(OverHatSgn[idx[[s]]]===-1),
outputtensor=Which[
s<Length[idx],Transpose[TensorContract[TensorProduct[outputtensor,(*Contract w/ Subscript[\[Epsilon], Overscript[\[Alpha], ^]]^\[Mu]*)invonff],{{s,Length[idx]+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,Length[idx]],s}],
s===Length[idx],TensorContract[TensorProduct[outputtensor,invonff],{{s,Length[idx]+1}}]]
],{s,1,Length[idx]}];
(* output *)
tttemp/.{(TensorComponents->xxx123_)->(TensorComponents->outputtensor),(Indices->i123_):>(Indices->(Indices[tt]/.outputindices))}
];

MoveIndices[tt_Tensor,OrthonormalBasis,m_Tensor]/;((* check that there are same number of indices in tt and idx *)((* check m is a Metric; we are going use it to move the indices with *)TestMetricTensor[m])&&(Cases[{m},(OrthonormalFrameField->onff_)->onff,1]=!={Null})&&(Cases[{m},(InverseOrthonormalFrameField->invonff_)->invonff,1]=!={Null})&&(*NewCode: ExtractFunctions*)(!Quiet[TestMetricTensor[tt]])):=MoveIndices[tt,Which[OverHatSgn[#]===1,#,OverHatSgn[#]===-1,(OverHat[#[[1]]])//#[[0]]]&/@Indices[tt],m]

MoveIndices[tt_Tensor,CoordinateBasis,m_Tensor]/;((* check that there are same number of indices in tt and idx *)((* check m is a Metric; we are going use it to move the indices with *)TestMetricTensor[m])&&(Cases[{m},(OrthonormalFrameField->onff_)->onff,1]=!={Null})&&(Cases[{m},(InverseOrthonormalFrameField->invonff_)->invonff,1]=!={Null})&&(*NewCode: ExtractFunctions*)(!Quiet[TestMetricTensor[tt]])):=MoveIndices[tt,Which[OverHatSgn[#]===1,#[[1,1]]//#[[0]],OverHatSgn[#]===-1,#]&/@Indices[tt],m]


(* ::Input::Initialization:: *)
(* RaiseAllIndices[tt_Tensor,m_Tensor] returns tt with all its indices raised *)
RaiseAllIndices[t_Tensor/;!TestScalarTensor[t],m_Tensor/;TestMetricTensor[m]]:=Module[{idx},
(* strip off all the SubMinus and SuperMinus and then replace them all with SuperMinus *)
idx=SuperMinus[#]&/@(#[[1]]&/@RemoveUnderBarredIndices[Indices[t]]);
MoveIndices[t,idx,m]];

RaiseAllIndices[t_Tensor/;TestScalarTensor[t],m_Tensor/;TestMetricTensor[m]]:=t

RaiseAllIndices[t_/;TestExpressionForm[t],m_Tensor/;TestMetricTensor[m]]:=t


(* ::Input::Initialization:: *)
(* LowerAllIndices[tt_Tensor,m_Tensor] returns tt with all its indices lowered *)
LowerAllIndices[t_Tensor/;!TestScalarTensor[t],m_Tensor/;TestMetricTensor[m]]:=Module[{idx},
(* strip off all the SubMinus and SuperMinus and then replace them all with SuperMinus *)
idx=SubMinus[#]&/@(#[[1]]&/@RemoveUnderBarredIndices[Indices[t]]);
MoveIndices[t,idx,m]];

LowerAllIndices[t_Tensor/;TestScalarTensor[t],m_Tensor/;TestMetricTensor[m]]:=t

LowerAllIndices[t_/;TestExpressionForm[t],m_Tensor/;TestMetricTensor[m]]:=t


(* ::Input::Initialization:: *)
(* UniqueIndices[tt_Tensor] returns tt with its indices made unique *)
UniqueIndices[t_Tensor]:=Module[{idx,xxx},
(* strip off the SubMinus and SuperMinus *)
idx=#[[1]]&/@RemoveUnderBarredIndices[Indices[t]];
(* replace them with Unique ones *)
idx=(#->Unique[#])&/@idx;
t/.(Indices->xxx_):>(Indices->(xxx/.idx))];


(* ::Input::Initialization:: *)
(*NewCode: SymmetrizeIndices*)
(*Partially SymmetrizeIndices*)
SymmetrizeIndices[TargetIndices_List,t_Tensor,opts:OptionsPattern[]]/;(*Check: All indices in TargetIndices should be included in Indices list of t*)(SubsetQ[RemoveUnderBarredIndices[Indices[t]],TargetIndices]):=Module[{indices,indices2,takelist,targetposition,newindiceslist,m,UntouchedIdx, ListwithVerticleBar},
(*indices2: Extract extracting Indices list preserving UnderBar. This will be used at the end*)
indices2=Indices[t];
(*indices:Extract Indices list removing UnderBar. Since UnderBar has no meaning in this operation,we should remove them first.*)
indices=RemoveUnderBarredIndices[indices2];
(*UntouchedIdx: To add curly bracket and vertical bar in the output indices list, we should extract those indices in indices list excluded from TargetIndices. We use Complement to get it.*)
UntouchedIdx=Complement[indices,TargetIndices];
(*targetposition: We convert TargetIndices into the position number.*)
targetposition=Sort[Flatten[Position[indices,#]&/@TargetIndices]];
(*m is the output TensorComponents. We get the symmetrized tensor of "t".*)
(*Note that in our definition, we have a factorial coefficient difference w/ Mathematica's one.*)m=Length[TargetIndices]!Normal[Symmetrize[TensorComponents[t],Symmetric[targetposition]]]//OptionValue[SymmetrizeIndicesOperator];
(*From here,we start to prepare the output indices list.*)
(*Take the list between the first and the last indices which need to be symmetrize.*)
takelist=Take[indices,{First[targetposition],Last[targetposition]}];
(*Extract the indices which need to add vertical bars around them,by getting intersection of takelist and UntouchedIdx*)
ListwithVerticleBar=takelist\[Intersection]UntouchedIdx;
(*Output indices list*)newindiceslist=indices2/.{First[TargetIndices]->Sequence[UnderBar["{"]//(First[TargetIndices])[[0]],First[TargetIndices]],Last[TargetIndices]->Sequence[Last[TargetIndices],UnderBar["}"]//(Last[TargetIndices])[[0]]],Sequence@@(Rule[#,Sequence[UnderBar["|"]//#[[0]],#,UnderBar["|"]//#[[0]]]]&/@ListwithVerticleBar)};
(*Change TensorComponents and Indices*)
t/.{(TensorComponents->mx_)->(TensorComponents->m),(Indices->idx_)->(Indices->newindiceslist)}
];
(*Fully SymmetrizeIndices*)
SymmetrizeIndices[t_Tensor,opts:OptionsPattern[]]:=SymmetrizeIndices[(*Recall Partially SymmetrizeIndices, but symmetrize w/ all indices.*)RemoveUnderBarredIndices[Indices[t]],t,SymmetrizeIndicesOperator->OptionValue[SymmetrizeIndicesOperator]];


(* ::Input::Initialization:: *)
(*Abondoned code: Start*)
(*(*NewCode: SymmetrizeIndices*)
SymmetrizeIndices[t_Tensor]:=Module[{indices,lgth,m,newindiceslist},
m=TensorComponents[t];
indices=Indices[t];
lgth=Length[indices];
m=(lgth! Normal[Symmetrize[m]])//FullSimplify;
newindiceslist=AddCurlyBrackets[Indices[t]];
t/.{(TensorComponents\[Rule]mx_)\[Rule](TensorComponents\[Rule]m),(Indices\[Rule]idx_)\[Rule](Indices\[Rule]newindiceslist)}];
(*Partially-SymmetrizeIndices*)
SymmetrizeIndices[TargetIndices_List,t_Tensor]/;(SubsetQ[RemoveUnderBarredIndices[Indices[t]],TargetIndices]):=Module[{indices,indices2,Permutelist,Tsum,newindiceslist,m,UntouchedIdx},
indices=RemoveUnderBarredIndices[Indices[t]];
indices2=Indices[t];
UntouchedIdx=Complement[indices,TargetIndices];
Permutelist=indices/.Thread[Rule[TargetIndices,#]]&/@Permutations[TargetIndices];
Tsum=(Plus@@(( SwapIndices[t,#])&/@Permutelist));
m=TensorComponents[Tsum]//FullSimplify;
LeftBracketPosition=Flatten[Position[indices,First[TargetIndices]]]\[LeftDoubleBracket]1\[RightDoubleBracket];
RightBracketPosition=Flatten[Position[indices,Last[TargetIndices]]]\[LeftDoubleBracket]1\[RightDoubleBracket];
ListwithVerticleBar=Take[indices,{LeftBracketPosition,RightBracketPosition}]\[Intersection]UntouchedIdx;
newindiceslist=indices2/.{First[TargetIndices]\[Rule]Sequence[UnderBar["{"]//(First[TargetIndices])\[LeftDoubleBracket]0\[RightDoubleBracket],First[TargetIndices]],Last[TargetIndices]\[Rule]Sequence[Last[TargetIndices],UnderBar["}"]//(Last[TargetIndices])\[LeftDoubleBracket]0\[RightDoubleBracket]],Sequence@@(Rule[#,Sequence[UnderBar["|"]//#\[LeftDoubleBracket]0\[RightDoubleBracket],#,UnderBar["|"]//#\[LeftDoubleBracket]0\[RightDoubleBracket]]]&/@ListwithVerticleBar)};
t/.{(TensorComponents\[Rule]mx_)\[Rule](TensorComponents\[Rule]m),(Indices\[Rule]idx_)\[Rule](Indices\[Rule]newindiceslist)}
];*)
(*Abondoned code: End*)


(* ::Input::Initialization:: *)
(*NewCode: AntiSymmetrizeIndices*)
(*Partially Anti-SymmetrizeIndices*)
AntiSymmetrizeIndices[TargetIndices_List,t_Tensor,opts:OptionsPattern[]]/;(*Check: All indices in TargetIndices should be included in Indices list of t*)(SubsetQ[RemoveUnderBarredIndices[Indices[t]],TargetIndices]):=Module[{indices,indices2,takelist,targetposition,newindiceslist,m,UntouchedIdx, ListwithVerticleBar},
(*indices2: Extract extracting Indices list preserving UnderBar. This will be used at the end*)
indices2=Indices[t];
(*indices:Extract Indices list removing UnderBar. Since UnderBar has no meaning in this operation,we should remove them first.*)
indices=RemoveUnderBarredIndices[indices2];
(*UntouchedIdx: To add square bracket and vertical bar in the output indices list, we should extract those indices in indices list excluded from TargetIndices. We use Complement to get it.*)
UntouchedIdx=Complement[indices,TargetIndices];
(*targetposition: We convert TargetIndices into the position number.*)
targetposition=Sort[Flatten[Position[indices,#]&/@TargetIndices]];
(*m is the output TensorComponents. We get the anti-symmetrized tensor of "t".*)
(*Note that in our definition, we have a factorial coefficient difference w/ Mathematica's one.*)m=Length[TargetIndices]!Normal[Symmetrize[TensorComponents[t],Antisymmetric[targetposition]]]//OptionValue[AntiSymmetrizeIndicesOperator];
(*From here,we start to prepare the output indices list.*)
(*Take the list between the first and the last indices which need to be anti-symmetrized.*)
takelist=Take[indices,{First[targetposition],Last[targetposition]}];
(*Extract the indices which need to add vertical bars around them,by getting intersection of takelist and UntouchedIdx*)ListwithVerticleBar=takelist\[Intersection]UntouchedIdx;
(*Output indices list*)newindiceslist=indices2/.{First[takelist]->Sequence[UnderBar["["]//(First[takelist])[[0]],First[takelist]],Last[takelist]->Sequence[Last[takelist],UnderBar["]"]//(Last[takelist])[[0]]],Sequence@@(Rule[#,Sequence[UnderBar["|"]//#[[0]],#,UnderBar["|"]//#[[0]]]]&/@ListwithVerticleBar)};
(*Change TensorComponents and Indices*)
t/.{(TensorComponents->mx_)->(TensorComponents->m),(Indices->idx_)->(Indices->newindiceslist)}
];
(*Fully-AntiSymmetrizeIndices*)
AntiSymmetrizeIndices[t_Tensor,opts:OptionsPattern[]]:=AntiSymmetrizeIndices[(*Recall Partially AntiSymmetrizeIndices, but symmetrize w/ all indices.*)RemoveUnderBarredIndices[Indices[t]],t,AntiSymmetrizeIndicesOperator->OptionValue[AntiSymmetrizeIndicesOperator]];


(* ::Input::Initialization:: *)
(* Partial derivative on a scalar: \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]stuff\) or \[Del]^\[Mu]stuff using the metric m *)
(* scalar, Same as CovariantD *)
PartialD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_,m_Tensor]/;((*Scalar Tensor Form*)(TestScalarTensor[stuff]||(*Scalar Expression Form*)(*NewCode: TestExpressionForm*)TestExpressionForm[stuff])&&(*m is a Metric*)(*NewCode: ExtractFunctions*)(TestMetricTensor[m])):=(*Recall CovariantD*)CovariantD[\[Mu]T,stuff,m];

(*NewCode: PartialD on a scalar (as a expression form) with given coordinates list.*)
PartialD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_,CoordinateSystem->coords_List]/;(*Scalar Expression Form*)(*NewCode: TestExpressionForm*)TestExpressionForm[stuff]:=
(*Recall by "PartialD for downstair on Tensor w/o third argument" code.*)
PartialD[\[Mu]T,(*Declare a new Tensor*)NonMetricTensor[{},stuff,stuff,CoordinateSystem->coords]]


(* Note III. Internally we build the PartialD as a Tensor with abstract indices then replace the \[PartialD]-index with \[Mu]T *)
(*NewCode: PartialD for downstair on Tensor w/o the third argument (metric)*)
PartialD[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor]/;(*Notice that now we accept a scalar or tensor as Tensor object. There is no scalar check*)MatchQ[\[Mu]T,SubMinus[_]](*Check for downstair*):=Module[
{coords,\[Mu]TT,grad,\[Mu],\[Nu],\[Sigma],\[Lambda],\[Kappa],lgth,si,ii,invmetricM,\[CapitalSigma],indices,TensorMatrix,ChristT,partialT,output,out,outputindices,FinalTensorType},
(* output Tensor has the following indices *)
outputindices={\[Mu]T,Sequence@@Indices[\[Tau]T]};
(* extract coordinates *)
coords=Coordinates[\[Tau]T];
(*Dimension*)
lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
si=StartIndex[\[Tau]T];
(* extract indices of \[Tau]T *)
indices=Indices[\[Tau]T];
(* extract components of \[PartialD](\[Tau]T) as a matrix *)
output=Table[TensorComponents[(*Recall "Derivative for Tensor".*)PD[\[Tau]T,coords[[\[Sigma]]]]],
{\[Sigma],1,lgth}];

(*Abondoned code: Start*)
(*Which[(!TestScalarTensor[\[Tau]T]),output=Table[D[\[Tau]T,coords\[LeftDoubleBracket]\[Sigma]\[RightDoubleBracket]]//TensorComponents,
{\[Sigma],1,lgth}(*,Evaluate[Sequence@@({#\[LeftDoubleBracket]1\[RightDoubleBracket],si,si+lgth-1}&/@RemoveUnderBarredIndices[indices])]*)],True,output=Table[D[\[Tau]T,coords\[LeftDoubleBracket]\[Sigma]\[RightDoubleBracket]]//TensorComponents,
{\[Sigma],1,lgth}]];*)
(*output=Table[D[\[Tau]T,coords\[LeftDoubleBracket]\[Sigma]\[RightDoubleBracket]],
{\[Sigma],1,lgth},Evaluate[Sequence@@({#\[LeftDoubleBracket]1\[RightDoubleBracket],si,si+lgth-1}&/@RemoveUnderBarredIndices[indices])]];*)
(*Which[Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]==={"Metric"}||Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]==={"ChristoffelSymbols"},FinalTensorType=Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]\[LeftDoubleBracket]1\[RightDoubleBracket],True,FinalTensorType="PartialDerivative(s)"];*)
(*Abondoned code: End*)

(*Prepend \[Mu]T in to new Indices list, add a "\[PartialD]" mark in front of TensorName, and update the TensorComponents.*)
\[Tau]T/.{

(*Abondoned code: Start*)
(* We change the TensorType so that even the CovariantD of a Metric will be displayed properly *)
(*NewCode: Delete TensorType "PartialDerivative(s)"*)
(*(TensorType\[Rule]ttt_)\[Rule](TensorType\[Rule]FinalTensorType),*)
(*Abondoned code: End*)

(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(TensorName->nnn_):>(TensorName->"\[PartialD]"[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->output)
}
];

(* Partial derivative \!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]Tensor\) using the metric m *)
(*NewCode: PartialD for given Metric or Coordinates list on Tensor as the third argument (Optional) (downstair PartialD).*)
PartialD[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor,(m_Tensor|(CoordinateSystem->coordslist_List))]/;((* Given m is a Metric, coordslist is Null.*)((*NewCode: ExtractFunctions*)((TestMetricTensor[m]===True)&&(coordslist===Null))||(*Given coordslist, m is Null*)((m===Null)&&!(coordslist===Null)))&&(*\[Mu]T is downstair*)MatchQ[\[Mu]T,SubMinus[_]]):=Module[
{coords,\[Mu]TT,grad,\[Mu],\[Nu],\[Sigma],\[Lambda],\[Kappa],lgth,si,ii,invmetricM,\[CapitalSigma],indices,TensorMatrix,ChristT,partialT,output,out,outputindices,FinalTensorType},
(* output Tensor has the following indices *)
outputindices={\[Mu]T,Sequence@@Indices[\[Tau]T]};
(* extract coordinates *)
Which[m===Null,coords=coordslist,True,coords=Coordinates[m]];
lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
si=StartIndex[\[Tau]T];
(* extract indices of \[Tau]T *)
indices=Indices[\[Tau]T];
(* extract components of \[PartialD](\[Tau]T) as a matrix *)
output=Table[TensorComponents[PD[\[Tau]T,coords[[\[Sigma]]]]],
{\[Sigma],1,lgth}];

(*Abondoned code: Start*)
(*output=Table[D[\[Tau]T,coords\[LeftDoubleBracket]\[Sigma]\[RightDoubleBracket]],
{\[Sigma],1,lgth},Evaluate[Sequence@@({#\[LeftDoubleBracket]1\[RightDoubleBracket],si,si+lgth-1}&/@RemoveUnderBarredIndices[indices])]];*)
(*Which[Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]===({"Metric"}|{"ChristoffelSymbols"}),FinalTensorType=Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]\[LeftDoubleBracket]1\[RightDoubleBracket],True,FinalTensorType="PartialDerivative(s)"];*)
(*Abondoned code: End*)

(*Prepend \[Mu]T in to new Indices list, add a "\[PartialD]" mark in front of TensorName, and update the TensorComponents.*)
\[Tau]T/.{

(*Abondoned code: Start*)
(* We change the TensorType so that even the CovariantD of a Metric will be displayed properly *)
(*NewCode: Delete TensorType "PartialDerivative(s)"*)
(*(TensorType\[Rule]ttt_)\[Rule](TensorType\[Rule]FinalTensorType),*)
(*Abondoned code: End*)

(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(*NewCode: ExtractFunctions*)
(TensorName->nnn_):>(TensorName->"\[PartialD]"[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->output)
}
];

(* Covariant derivative \[PartialD]^\[Mu]Tensor using the metric m (upper index)*)
PartialD[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor,m_Tensor]/;((* We have already dealt with scalars, to not conflict w/ previous code. Check \[Tau]T is not a scalar*)(!TestScalarTensor[\[Tau]T])&&(* check m is a Metric *)(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&(*upper index*)MatchQ[\[Mu]T,SuperMinus[_]]):=Module[{\[Sigma],\[Mu]TT,tempT,FinalTensorType},
tempT=PartialD[SubMinus[\[Sigma]],\[Tau]T,m];

(*Abondoned code: Start*)
(*Which[Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]===({"Metric"}|{"ChristoffelSymbols"}),FinalTensorType=Cases[\[Tau]T,(TensorType\[Rule]tt_)\[Rule]tt]\[LeftDoubleBracket]1\[RightDoubleBracket],True,FinalTensorType="PartialDerivative(s)"];*)
(*Abondoned code: End*)

\[Tau]T/.{

(*Abondoned code: Start*)
(* We change the TensorType so that even the CovariantD of a Metric will be displayed properly *)
(*NewCode: Delete TensorType "PartialDerivative(s)"*)
(*(TensorType\[Rule]ttt_)\[Rule](TensorType\[Rule]FinalTensorType),*)
(*Abondoned code: End*)

(*Prepend \[Mu]T in to new Indices list, add a "\[PartialD]" mark in front of TensorName, and update the TensorComponents.*)
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),(*NewCode: ExtractFunctions*)
(TensorName->nnn_):>(TensorName->"\[PartialD]"[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->TensorContract[TensorProduct[(*Matrix multiplication w/ inverse metric*)TensorComponents[Metric[SuperMinus[\[Mu]TT],SuperMinus[\[Sigma]],m]],TensorComponents[tempT]],{{2,3}}])
}
];

(*This allow us not to derivative w/ coord. list. For e.g., if the coord. list is {x,y,z}, we can derivative w.r.t {Overscript[x, .],Overscript[y, .],Overscript[z, .]} by inputting as the third argument. Right now it's supposed not to be a offical code. So I named it as PartialDWeiHao.*)
PartialDWeiHao[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor,Dlist_List]/;MatchQ[\[Mu]T,SubMinus[_]](*Check for downstair*):=Module[
{coords,\[Mu]TT,grad,\[Mu],\[Nu],\[Sigma],\[Lambda],\[Kappa],lgth,si,ii,invmetricM,\[CapitalSigma],indices,TensorMatrix,ChristT,partialT,output,out,outputindices,FinalTensorType},
(* output Tensor has the following indices *)
outputindices={\[Mu]T,Sequence@@Indices[\[Tau]T]};
(* extract coordinates *)
coords=Coordinates[\[Tau]T];
lgth=Length[coords];
(* extract StartIndex *)
si=StartIndex[\[Tau]T];
(* extract indices of \[Tau]T *)
indices=Indices[\[Tau]T];
(* extract components of \[PartialD](\[Tau]T) as a matrix *)
output=Table[TensorComponents[(*Recall "Derivative for Tensor".*)PD[\[Tau]T,(*Note that it's Dlist*)Dlist[[\[Sigma]]]]],
{\[Sigma],1,lgth}];
(*Prepend \[Mu]T in to new Indices list, add a "\[PartialD]" mark in front of TensorName, and update the TensorComponents.*)
\[Tau]T/.{
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(TensorName->nnn_):>(TensorName->"\[PartialD]"[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->output)
}
];

(*NewCode: Short-hand for PartialD*)
(*See also: Derivative for Tensor*)
Tensor/:D[t_Tensor,SubMinus[\[Mu]T_Symbol]]:=PartialD[SubMinus[\[Mu]T],t]
(*Tensor/:D[Tensor[stuff___],SubMinus[\[Mu]T_Symbol]]:=PartialD[Subscript[\[Mu]T, -],Tensor[stuff]]*)


(* ::Input::Initialization:: *)
(* Covariant derivative on a scalar: \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]stuff\) using the metric m *)
(* stuff with no Tensor Head *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_,m_Tensor]/;(*NewCode: TestExpressionForm*)(TestExpressionForm[stuff]&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&MatchQ[\[Mu]T,SubMinus[_]]):=Module[
{coords,grad,\[Mu],\[Nu],\[Lambda],lgth,idx,ii,output,outputt},
(* extract coordinates *)
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* return Tensor *)
output=(D[stuff,#]&/@coords);
Tensor[
(*NewCode: Delete TensorType "Gradient"*)
(*TensorType\[Rule]"Gradient",*)
TensorName->Del[stuff],
Indices->{\[Mu]T},StartIndex->idx,CoordinateSystem->coords,
(*NewCode: Comment out TooltipDisplay in CovariantD*)
(*TooltipDisplay\[Rule]output,*)
TensorComponents->output,
TooltipStyle-> TooltipStyle[m]
]
];
(* stuff w/ Tensor head *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_Tensor,m_Tensor]/;((* check stuff is indeed a scalar *)TestScalarTensor[stuff]&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&MatchQ[\[Mu]T,SubMinus[_]]):=Module[
{coords,grad,\[Mu],\[Nu],\[Lambda],lgth,idx,ii,contents,output,outputt},
(* extract coordinates *)
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* contents of stuff *)
contents=TensorComponents[stuff];
(* return Tensor *)
output=(D[contents,#]&/@coords);
outputt=stuff;
outputt=TensorName[outputt,Del[TensorName[stuff]]];
outputt=Indices[outputt,{\[Mu]T}];
outputt=StartIndex[outputt,idx];
outputt=Coordinates[outputt,coords];
(outputt/.{(TensorComponents-> tc_)->  (TensorComponents->output)})
];
(* Covariant derivative on a scalar: \[Del]^\[Mu]stuff using the metric m *)
(* stuff with no Tensor Head *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_,m_Tensor]/;(*NewCode: TestExpressionForm*)(TestExpressionForm[stuff]&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&MatchQ[\[Mu]T,SuperMinus[_]]):=Module[
{coords,grad,\[Mu],\[Nu],\[Lambda],lgth,idx,ii,invmetricM,output,outputt},
(* extract coordinates *)
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* extract inverse metric as a matrix *)
invmetricM=TensorComponents[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]];
(* return Tensor *)
output=invmetricM . (D[stuff,#]&/@coords);
Tensor[
(*NewCode: Delete TensorType "Gradient"*)
(*TensorType\[Rule]"Gradient",*)
TensorName->Del[stuff],
Indices->{\[Mu]T},StartIndex->idx,CoordinateSystem->coords,
(*NewCode: Comment out TooltipDisplay in CovariantD*)
(*TooltipDisplay\[Rule]output,*)
TensorComponents->output,
TooltipStyle-> TooltipStyle[m]
]
];
(* stuff w/ Tensor head *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],stuff_Tensor,m_Tensor]/;((* check stuff is indeed a scalar *)TestScalarTensor[stuff]&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&MatchQ[\[Mu]T,SuperMinus[_]]):=Module[
{coords,grad,\[Mu],\[Nu],\[Lambda],lgth,idx,ii,contents,invmetricM,output,outputt},
(* extract coordinates *)
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* contents of stuff *)
contents=TensorComponents[stuff];
(* extract inverse metric as a matrix *)
invmetricM=TensorComponents[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]];
(* return Tensor *)
output=invmetricM . (D[contents,#]&/@coords);
outputt=stuff;
outputt=TensorName[outputt,Del[TensorName[stuff]]];
outputt=Indices[outputt,{\[Mu]T}];
outputt=StartIndex[outputt,idx];
outputt=Coordinates[outputt,coords];
(outputt/.{(TensorComponents-> tc_)->  (TensorComponents->output)})
];


(* ::Input::Initialization:: *)
(* Covariant derivative \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]Tensor\) using the metric m *)
(* Note I. If \[Tau]T contains non-repeated UnderBarred indices then we cannot take its CovariantD because there isn't enough info since we'd have to sum over other components of the Tensor that are not avai. *)
(* Note II. If \[Tau]T contains repeated UnderBarred indices ___ SubMinus[UnderBar[\[Mu]]] ___ SuperMinus[UnderBar[\[Mu]]] ___ then these indices are "scalars" and do not take part in the CovariantD process *)
(* Note III. Internally we build the CovariantD as a Tensor with abstract indices then replace the Del-index with \[Mu]T *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor,m_Tensor]/;((* We have already dealt with scalars *)(!TestScalarTensor[\[Tau]T])&&(* check m is a Metric *)(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&(*\[Del] on \[CapitalGamma] is not a correct definition.*)(*NewCode: Do not allow CovariantD operator on a Christoffel*)
(*NewCode: ExtractFunctions*)(TensorTypeNoPart[\[Tau]T]=!={"ChristoffelSymbols"})&&MatchQ[\[Mu]T,SubMinus[_]]&&((* check for non-repeating UnderBarred Indices *)RemoveRepeatedUnderBarredIndices[Union[Flatten[Cases[Indices[\[Tau]T],(SuperMinus|SubMinus)[UnderBar[_]],\[Infinity]]]]]==={})(*NewCode: \[Del]g=0*)&&(\[Tau]T=!=m)):=Module[
{coords,ttM,\[Mu]TT,\[CapitalGamma]M,grad,\[Mu],\[Nu],\[Sigma],\[Lambda],\[Kappa],lgth,idx,ii,invmetricM,\[CapitalSigma],indices,TensorMatrix,ChristT,partialT,output,out,outputindices},
(* Christoffel symbol *)
\[CapitalGamma]M=TensorComponents[Christoffel[SuperMinus[\[Mu]],SubMinus[\[Nu]],SubMinus[\[Sigma]],m]];
(* output Tensor has the following indices *)
outputindices={\[Mu]T,Sequence@@Indices[\[Tau]T]};
(* extract coordinates *)
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* extract indices of \[Tau]T *)
(* remove repeated UnderBarred indices because they are irrelevant as far as CovariantD is concerned *)
indices=RemoveRepeatedUnderBarredIndices[Indices[\[Tau]T]];
(* extract components of \[Tau]T as a matrix *)
TensorMatrix=TensorComponents[\[Tau]T];
(* prepare summation indices *)
(* ... first prepare summation indices *)
(*NewCode: redundent symbols: \[CapitalSigma], \[Lambda], \[Kappa]*)
(*\[CapitalSigma]=Unique[\[Sigma]]&/@Range[1,Length[indices]];
(* ... then prepare summation indices and their summation range 1...d *)
\[Lambda]=Thread[{\[CapitalSigma],1,Dimensions[TensorMatrix]}];
\[Kappa]=(#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@\[Lambda]);*)
(* partial derivative terms *)
partialT=Table[D[TensorMatrix,coords[[\[Sigma]]]],{\[Sigma],1,Length[coords]}(*,Evaluate[(Sequence@@\[Lambda])]*)];
(* Christoffel terms *)
(* be careful re. ordering of indices *)
(* We contract Christoffel with Tensor (wrt to appropriate slot) term-by-term *)
(* ChristT=({Sgn[#],(* make sure the ordering of indices is correct *)SwapIndices[Which[
Sgn[#]===1,TensorsProduct[Christoffel[#,Subscript[\[Mu]TT, -],Subscript[\[Sigma], -],m](\[Tau]T/.#\[Rule]\[Sigma]^-)],
Sgn[#]===-1,TensorsProduct[Christoffel[\[Sigma]^-,Subscript[\[Mu]TT, -],#,m](\[Tau]T/.#\[Rule]Subscript[\[Sigma], -])]],
		RemoveRepeatedUnderBarredIndices[{Subscript[\[Mu]TT, -],Sequence@@Indices[\[Tau]T]}]]}&/@indices); *)
(* commented out code is a bit cryptic so let's do it slightly more directly? *)
(* \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\ 
\*SubscriptBox[
SuperscriptBox[\(T\), \(\(\(...\)\(\ \)\(\[Alpha]\)\)\  ... \)], \(\(\(...\)\(\ \)\(\[Beta]\)\)\  ... \)]\) = ... + Subscript[\[CapitalGamma]^\[Alpha], \[Mu]\[Sigma]] Subscript[T^(... \[Sigma] ...), ... \[Beta] ...] - Subscript[\[CapitalGamma]^\[Sigma], \[Mu]\[Beta]] Subscript[T^(... \[Alpha] ...), ... \[Sigma] ...] *)
(* old code
\[Lambda]=Thread[{\[CapitalSigma],idx,idx+lgth-1}];
ChristT=((Sgn[#] Which[
Sgn[#]===1,Sum[Christoffel[#,Subscript[\[Mu]TT, -],Subscript[\[Sigma], -],m](\[Tau]T/.#\[Rule]\[Sigma]^-),{\[Sigma],idx,idx+lgth-1}],
Sgn[#]===-1,Sum[Christoffel[\[Sigma]^-,Subscript[\[Mu]TT, -],#,m](\[Tau]T/.#\[Rule]Subscript[\[Sigma], -]),{\[Sigma],idx,idx+lgth-1}]])&/@indices);
ChristT=Table[Plus@@(ChristT/.Thread[Rule[(#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@indices),\[CapitalSigma]]]),{\[Mu]TT,idx,idx+lgth-1},Evaluate[(Sequence@@\[Lambda])]];
*)
(* new code May 2016 *)
ChristT={};
Do[
ChristT=Append[ChristT,Sgn[indices[[\[Sigma]]]]Transpose[TensorContract[TensorProduct[\[CapitalGamma]M,TensorMatrix],{{Which[Sgn[indices[[\[Sigma]]]]==1,3,Sgn[indices[[\[Sigma]]]]==-1,1],3+\[Sigma]}}],Which[Sgn[indices[[\[Sigma]]]]==1,{\[Sigma]+1,1,Sequence@@Range[2,\[Sigma]],Sequence@@Range[\[Sigma]+2,Length[indices]+1]},Sgn[indices[[\[Sigma]]]]==-1,{1,\[Sigma]+1,Sequence@@Range[2,\[Sigma]],Sequence@@Range[\[Sigma]+2,Length[indices]+1]}]]],{\[Sigma],1,Length[indices]}];
ChristT=Plus@@ChristT;
(* ChristT=(#\[LeftDoubleBracket]1\[RightDoubleBracket]TensorComponents[#\[LeftDoubleBracket]2\[RightDoubleBracket]])&/@ChristT; *)
(* combine the terms and sum them *)
(* output=Prepend[ChristT,partialT];output=Plus@@output; *)
output=partialT+ChristT;
(* return Tensor by prepending Del-index \[Mu]T and Applying Del to TensorName and replacing TensorComponents *)
\[Tau]T/.{
(* We change the TensorType so that even the CovariantD of a Metric will be displayed properly *)
(*NewCode: Delete TensorType:"CovariantDerivative(s)"*)
(*(TensorType\[Rule]ttt_)\[Rule](TensorType\[Rule]"CovariantDerivative(s)"),*)
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(*NewCode: ExtractFunctions*)
(TensorName->nnn_):>(TensorName->Del[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->output)
}
];
(* Covariant derivative \[Del]^\[Mu]Tensor using the metric m *)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],\[Tau]T_Tensor,m_Tensor]/;((* We have already dealt with scalars *)(!TestScalarTensor[\[Tau]T])&&(* check m is a Metric *)(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&(*\[Del] on \[CapitalGamma] is not a correct definition.*)(*NewCode: Do not allow CovariantD operator on a Christoffel*)(*NewCode: ExtractFunctions*)(TensorTypeNoPart[\[Tau]T]=!={"ChristoffelSymbols"})&&MatchQ[\[Mu]T,SuperMinus[_]](*NewCode: \[Del]g=0*)&&(\[Tau]T=!=m)):=Module[{\[Sigma],\[Mu]TT,tempT},
tempT=CovariantD[SubMinus[\[Sigma]],\[Tau]T,m];
\[Tau]T/.{
(* We change the TensorType so that even the CovariantD of a Metric will be displayed properly *)
(*NewCode: Delete TensorType:"CovariantDerivative(s)"*)
(*(TensorType\[Rule]ttt_)\[Rule](TensorType\[Rule]"CovariantDerivative(s)"),*)
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(*NewCode: ExtractFunctions*)
(TensorName->nnn_):>(TensorName->Del[TensorName[\[Tau]T]]),
(TensorComponents->ccc_)->(TensorComponents->TensorContract[TensorProduct[TensorComponents[Metric[SuperMinus[\[Mu]TT],SuperMinus[\[Sigma]],m]],TensorComponents[tempT]],{{2,3}}])
}
];
(*NewCode: \[Del]g=0*)
CovariantD[\[Mu]T_/;TestIndices[\[Mu]T],m_Tensor,m_Tensor]/;((* We have already dealt with scalars *)(* check m is a Metric *)(TestMetricTensor[m])):=0;


(* ::Input::Initialization:: *)
(*See: Operator Linearity & Operator ProductRule*)
(*
(* Thread over Plus automatically *)
(*NewCode: Redundant TagSetDelay*)
CovariantD[\[Mu]T_,tt_Plus,m_]:=(CovariantD[\[Mu]T,#,m]&/@tt); 
(* Implement product rule *)
CovariantD[\[Mu]T_,tt_,m_]:=Module[{allTensors,therest},
allTensors=Times@@Cases[(List@@tt),_Tensor];
therest=Times@@DeleteCases[(List@@tt),_Tensor];
therest CovariantD[\[Mu]T,allTensors,m]+allTensors Which[TensorIsZero[CovariantD[\[Mu]T,therest,m]],0,True,CovariantD[\[Mu]T,therest,m]]]/;(Head[tt]===Times)&&(Union[(Head/@(List@@tt))]=!={Tensor});
(* Use TensorsProduct to take care of TensorProduct's of Tensors *)
CovariantD[\[Mu]T_,tt_,m_]:=CovariantD[\[Mu]T,TensorsProduct[tt],m]/;((Head[tt]===Times)&&(Union[(Head/@(List@@tt))]==={Tensor}));
*)


(* ::Input::Initialization:: *)
(* Box on scalar function f *)
(* = g^{-1/2} \[PartialD]_\[Mu] ( g^{1/2} g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] f ) *)
(* = \[PartialD]_\[Mu] ( g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] f ) + (\[PartialD]_\[Mu] ln g^{1/2}) g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] f *)
(* = \[PartialD]_\[Mu] ( g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] f ) + \[CapitalGamma]^\[Mu]_{\[Mu]\[Lambda]} g^{\[Lambda]\[Nu]} \[PartialD]_\[Nu] f *)
CovariantBox[stuff_,m_Tensor]/;((*NewCode: TestExpressionForm*)(TestExpressionForm[stuff])&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])):=Module[
{coords,grad,\[Mu],\[Nu],\[Lambda],lgth,idx,ii},
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] stuff *)
grad=Table[
Sum[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]D[stuff,coords[[\[Nu]-idx+1]]],{\[Nu],idx,idx+lgth-1}],
{\[Mu],idx,idx+lgth-1}
];
(* \[PartialD]_\[Mu] grad^\[Mu] + \[CapitalGamma]^\[Mu]_{\[Mu]\[Nu]} grad^\[Nu] *)
Sum[D[grad[[\[Nu]-idx+1]],coords[[\[Nu]-idx+1]]]+Sum[Christoffel[SuperMinus[\[Mu]],SubMinus[\[Mu]],SubMinus[\[Nu]],m],{\[Mu],idx,idx+lgth-1}]grad[[\[Nu]-idx+1]],{\[Nu],idx,idx+lgth-1}]
];

(*NewCode: CovariantBox on Tensor*)
CovariantBox[t_Tensor,m_Tensor]/;(*m is a metric*)(*NewCode: ExtractFunctions*)(TestMetricTensor[m])&&(*CoordinateSystem should be the same.*)(*NewCode: ExtractFunctions*)(Coordinates[t]===Coordinates[m]):=Module[
{tempname,output,resumeindices,\[Mu]},
(*Extract the TensorName*)
(*NewCode: ExtractFunctions*)
tempname=TensorNameNoPart[t];
(*Extract the Indices*)
resumeindices=Indices[t];
(*Operate \[Square]\[Congruent]\!\(\*
StyleBox[
SubscriptBox["\[Del]", "\[Mu]"],
FontColor->RGBColor[1, 0, 1]]\(\*
StyleBox[
SuperscriptBox["\[Del]", "\[Mu]"],
FontColor->RGBColor[1, 0, 1]]\ on\)\) t to get \[Square]t*)
output=CovariantD[SubMinus[\[Mu]],CovariantD[SuperMinus[\[Mu]],t,m],m];
Which[TestExpressionForm[output],output=t/.{(TensorComponents-> tc___)-> TensorComponents-> output}];
(*Rename as \[Square]t and recover the original indices list*)
output/.{(TensorName->name_)->(TensorName->Square@@tempname),(Indices->idx_)->(Indices->resumeindices)}
];

(*NewCode: CovariantBox: calculate with CovariantD*)
(*CovariantBox[stuff_,m_Tensor,CovariantD]/;((*NewCode: TestExpressionForm*)(TestExpressionForm[stuff])&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])):=CovariantBox[stuff,m]*)

(*NewCode: CovariantBox: calculate with Determinant*)
(*CovariantBox[stuff_,m_Tensor,Determinant]/;((*NewCode: TestExpressionForm*)(TestExpressionForm[stuff])&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])):=Module[
{SqrtDet,\[Mu],\[Nu]},
SqrtDet=Determinant[m]^(1/2);

1/SqrtDet(PartialD[Subscript[\[Mu], -],(SqrtDet Metric[\[Mu]^-,\[Nu]^-,m] PartialD[Subscript[\[Nu], -], stuff,Coordinates[m]]),m])
];*)


(* ::Input::Initialization:: *)
(* (\[Del]f)^2 for scalar function f *)
(* this code is borrowed from CovariantBox *)
GradientSquared[stuff_,m_Tensor]/;((*NewCode: TestExpressionForm*)(TestExpressionForm[stuff])&&(*NewCode: ExtractFunctions*)(TestMetricTensor[m])):=Module[
{coords,gradu,gradd,\[Mu],\[Nu],\[Lambda],lgth,idx,ii},
coords=Coordinates[m];lgth=Length[coords];
(* extract StartIndex *)
(*NewCode: ExtractFunctions*)
idx=StartIndex[m];
(* g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] stuff *)
gradu=Table[
Sum[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]D[stuff,coords[[\[Nu]-idx+1]]],{\[Nu],idx,idx+lgth-1}],
{\[Mu],idx,idx+lgth-1}
];
(* \[PartialD]_\[Mu] stuff *)
gradd=Table[D[stuff,coords[[\[Nu]-idx+1]]],{\[Nu],idx,idx+lgth-1}];
(* \[PartialD]_\[Mu] stuff g^{\[Mu]\[Nu]} \[PartialD]_\[Nu] stuff = gradd.gradu *)
gradu . gradd
]


(* ::Input::Initialization:: *)
(*NewCode: InteriorProduct*)
InteriorProduct[X_Tensor/;(RankNumber[X]>0)(*&&(TestDifferentialVector[X])*)(*TestOneVector[X]*),\[Omega]_Tensor]/;((*TestDifferentialForm[\[Omega]]&&*)RankNumber[\[Omega]]>0):=Module[{originalXindices,original\[Omega]indices,Xindices,\[Omega]indices,length,length2,finallength,newIndicesrep,newIndices,i,output,newTensorName},
TestDifferentialForm[\[Omega]];
TestDifferentialVector[X];
originalXindices=Indices[X];
original\[Omega]indices=Indices[\[Omega]];
Xindices=RemoveUnderBarredIndices[originalXindices];
\[Omega]indices=RemoveUnderBarredIndices[original\[Omega]indices];
length=RankNumber[Xindices];
length2=RankNumber[\[Omega]indices];
finallength=Min[length,length2];
newIndicesrep=Table[(Xindices[[i,1]]->\[Omega]indices[[i,1]] ),{i,1,finallength}];
newIndices=originalXindices/.newIndicesrep;
Which[((length===length2)(*||(Abs[length-length2]===1)*)),output=1/finallength! TensorsProduct[{Indices[X,newIndices],\[Omega]}],True,output=TensorsProduct[{Indices[X,newIndices],\[Omega]}];
output=TensorsProduct[1/finallength! output,Tensor];
output=TensorName[output,Row[{Subscript["\[Iota]", TensorName[X]],TensorName[\[Omega]]}]];
output=RemoveRepeatedUnderBarredIndices[output]]
];

InteriorProduct[X_Tensor/;(RankNumber[X]>0)(*&&(TestDifferentialVector[X])*)(*TestOneVector[X]*),\[Omega]_Tensor,Tensor]/;((*TestDifferentialForm[\[Omega]]&&*)RankNumber[\[Omega]]>0):=Module[{originalXindices,original\[Omega]indices,Xindices,\[Omega]indices,length,length2,finallength,newIndicesrep,newIndices,i,output,newTensorName},
TestDifferentialForm[\[Omega]];
TestDifferentialVector[X];
originalXindices=Indices[X];
original\[Omega]indices=Indices[\[Omega]];
Xindices=RemoveUnderBarredIndices[originalXindices];
\[Omega]indices=RemoveUnderBarredIndices[original\[Omega]indices];
length=RankNumber[Xindices];
length2=RankNumber[\[Omega]indices];
finallength=Min[length,length2];
newIndicesrep=Table[(Xindices[[i,1]]->\[Omega]indices[[i,1]] ),{i,1,finallength}];
newIndices=originalXindices/.newIndicesrep;
output=TensorsProduct[{Indices[X,newIndices],\[Omega]},Tensor];
output=TensorsProduct[1/finallength! output,Tensor];
output=TensorName[output,Row[{Subscript["\[Iota]", TensorName[X]],TensorName[\[Omega]]}]];
output=RemoveRepeatedUnderBarredIndices[output]
];

Subscript[Global`\[Iota],a_Tensor][b_Tensor]:=InteriorProduct[a,b]


(* ::Input::Initialization:: *)
(*NewCode: ExteriorD*)
(*Input a new specified index and tensor t*)
ExteriorD[\[Mu]T_/;TestIndices[\[Mu]T],t_Tensor]/;(*index for PartialD should be lower one*)(Sgn[\[Mu]T]===-1)(*&&TestDifferentialForm[t]*)(*&&If[TestDifferentialForm[t],True,Message[TestDifferentialForm::TestDifferentialFormFalse,t];False]*):=Module[
{dF,ddFm,\[Mu]Ttemp=SubMinus[Unique[\[Alpha]]]},
TestDifferentialForm[t];
(*PartialD on t*)
dF=PartialD[\[Mu]Ttemp,t];
(*Fully AntiSymmetrizeIndices dF*)
ddFm=1/RankNumber[t]! TensorComponents[AntiSymmetrizeIndices[dF]];
(*Add a \[DifferentialD] in the TensorName and change the TensorComponents. Prepend a new index.*)
t/.{
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(TensorName->nnn_):>(TensorName->Row[{"\[DifferentialD]",TensorName[t]}]),
(TensorComponents->ccc_)->(TensorComponents->ddFm)
}
];

ExteriorD[\[Mu]T_/;TestIndices[\[Mu]T],t_Tensor,m_Tensor/;TestMetricTensor[m]]/;(*index for PartialD should be lower one*)(((Sgn[\[Mu]T]===-1)(*&&TestDifferentialForm[t]*))||((Sgn[\[Mu]T]===1)(*&&TestDifferentialVector[t]*))):=Module[
{dF,ddFm,\[Mu]Ttemp=SubMinus[Unique[\[Alpha]]],\[Mu]Ttemp2=SuperMinus[Unique[\[Alpha]]]},
(*PartialD on t*)
dF=Which[(Sgn[\[Mu]T]===-1),
TestDifferentialForm[t];
CovariantD[\[Mu]Ttemp,t,m],
(Sgn[\[Mu]T]===1),
TestDifferentialVector[t];
CovariantD[\[Mu]Ttemp2,t,m]];
(*Fully AntiSymmetrizeIndices dF*)
ddFm=1/RankNumber[t]! TensorComponents[AntiSymmetrizeIndices[dF]];
(*Add a \[DifferentialD] in the TensorName and change the TensorComponents. Prepend a new index.*)
t/.{
(Indices->iii_):>(Indices->Prepend[iii,\[Mu]T]),
(TensorName->nnn_):>(TensorName->Row[{"\[DifferentialD]",TensorName[t]}]),
(TensorComponents->ccc_)->(TensorComponents->ddFm)
}
];

(*Rename the whole bunch of indices.*)
ExteriorD[\[Mu]List_List,t_Tensor]/;(*The length of \[Mu]List should be rank+1*)(Length[\[Mu]List]===RankNumber[t]+1)(*&&(*check t is a fully anti-symm tensor*)TestDifferentialForm[t]*)&&(*Also, we want to check all indices in \[Mu]List are OK and lower.*)MatchQ[(Union[TestIndices[#]&/@\[Mu]List]),{True}]&&(MatchQ[(Union[Sgn[#]&/@\[Mu]List]),{-1}])&&(*Check all indices in \[Mu]List are abstract.*)MatchQ[Union[NotAbstractIndex[#,Coordinates[t],Sequence@@StartIndexNoPart[t]]&/@\[Mu]List],{False}]:=(*Recall ExteriorD*)ExteriorD[(*Part 1 of \[Mu]List*)\[Mu]List[[1]],t/.(Indices->idx_)->(Indices->(*W/ Drop 1,we can get the new indices for t*)Drop[\[Mu]List,1])];

(*Rename the whole bunch of indices.*)
ExteriorD[\[Mu]List_List,t_Tensor,m_Tensor/;TestMetricTensor[m]]/;(*The length of \[Mu]List should be rank+1*)(Length[\[Mu]List]===RankNumber[t]+1)(*&&(*check t is a fully anti-symm tensor*)TestDifferentialForm[t]*)&&(*Also, we want to check all indices in \[Mu]List are OK and lower.*)MatchQ[(Union[TestIndices[#]&/@\[Mu]List]),{True}]&&(MatchQ[(Union[Sgn[#]&/@\[Mu]List]),{-1}]||MatchQ[(Union[Sgn[#]&/@\[Mu]List]),{1}])&&(*Check all indices in \[Mu]List are abstract.*)MatchQ[Union[NotAbstractIndex[#,Coordinates[t],Sequence@@StartIndexNoPart[t]]&/@\[Mu]List],{False}]:=(*Recall ExteriorD*)ExteriorD[(*Part 1 of \[Mu]List*)\[Mu]List[[1]],t/.(Indices->idx_)->(Indices->(*W/ Drop 1,we can get the new indices for t*)Drop[\[Mu]List,1]),m];

(*ExteriorD w/o given a specified index.We will generate one Unique index for user.*)
ExteriorD[t_Tensor](*/;(*check t is a fully anti-symm tensor*)TestDifferentialForm[t]*):=(*Recall ExteriorD*)ExteriorD[(*Generate unique index*)SubMinus[Unique[\[Mu]]],t];

(*Shorthand for ExteriorD (\[DifferentialD]Tensor)*)
Tensor/:\[DifferentialD]t_Tensor:=ExteriorD[t];

(*Shorthand for ExteriorD w/ a new index for PartialD (\!\(
\*SubscriptBox[\(\[DifferentialD]\), 
SubscriptBox[\(\[Mu]T\), \(-\)]]Tensor\))*)
Tensor/:Dt[t_Tensor,SubMinus[\[Mu]T_Symbol]]:=ExteriorD[SubMinus[\[Mu]T],t]

(*Shorthand for ExteriorD w/ a new indices List for PartialD (\!\(
\*SubscriptBox[\(\[DifferentialD]\), \({
\*SubscriptBox[\(\[Mu]T\), \(-\)], 
\*SubscriptBox[\(a1\), \(-\)], 
\*SubscriptBox[\(a2\), \(-\)],  ... }\)]Tensor\))*)
Tensor/:Dt[t_Tensor,list_List]:=ExteriorD[list,t];


(* ::Input::Initialization:: *)
(*NewCode: PotentialForm*)
PotentialForm[\[Alpha]_Tensor/;((*TestDifferentialForm[\[Alpha]]&&*)!TestScalarTensor[\[Alpha]]),opts:OptionsPattern[]]:=Module[{indices,t,rep,xup,p,\[Mu]T,\[Beta]},
TestDifferentialForm[\[Alpha]];
indices=RemoveUnderBarredIndices[Indices[\[Alpha]]];
rep=Thread[Coordinates[\[Alpha]]->((t #)&/@Coordinates[\[Alpha]])];
xup=NonMetricTensor[{SuperMinus[indices[[1,1]]]},Coordinates[\[Alpha]],"x",CoordinateSystem->Coordinates[\[Alpha]]];
p=RankNumber[\[Alpha]];
\[Mu]T=TensorsProduct[(\[Alpha]/.(TensorComponents->mx_):>(TensorComponents->(mx/.rep))) xup];
Which[p===1,\[Beta]=Integrate[TensorComponents[\[Mu]T],{t,0,1}],True,\[Beta]=NonMetricTensor[RemoveUnderBarredIndices[Indices[\[Mu]T]],Map[Integrate[t^(p-1) #,{t,0,1}]&,(TensorComponents[\[Mu]T]),{p-1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]]]
];

(*PotentialForm[\[Alpha]_Tensor/;TestDifferentialForm[\[Alpha]],t_Symbol]:=Module[{rep,xup,p,\[Mu]T,\[Beta]},rep=Thread[Coordinates[\[Alpha]]\[Rule]((t #)&/@Coordinates[\[Alpha]])];
xup=NonMetricTensor[{Indices[\[Alpha]]\[LeftDoubleBracket]1,1\[RightDoubleBracket]^-},Coordinates[\[Alpha]],"x",CoordinateSystem\[Rule]Coordinates[\[Alpha]]];
p=RankNumber[\[Alpha]];
\[Mu]T=TensorsProduct[(\[Alpha]/.(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule](mx/.rep))) xup];
Which[p===1,\[Beta]=NonMetricTensor[{},Integrate[TensorComponents[\[Mu]T],{t,0,1}],"\[Beta]",CoordinateSystem\[Rule]Coordinates[\[Alpha]]],True,\[Beta]=NonMetricTensor[RemoveUnderBarredIndices[Indices[\[Mu]T]],Integrate[t^(p-1) #,{t,0,1}]&/@(TensorComponents[\[Mu]T]),"\[Beta]",CoordinateSystem\[Rule]Coordinates[\[Alpha]]]]
];*)
PotentialForm[\[Alpha]_Tensor/;((*TestDifferentialForm[\[Alpha]]&&*)!TestScalarTensor[\[Alpha]]),t_Symbol,opts:OptionsPattern[]]:=Module[{indices,rep,xup,p,\[Mu]T,\[Beta]},
TestDifferentialForm[\[Alpha]];
indices=RemoveUnderBarredIndices[Indices[\[Alpha]]];rep=Thread[Coordinates[\[Alpha]]->((t #)&/@Coordinates[\[Alpha]])];
xup=NonMetricTensor[{SuperMinus[indices[[1,1]]]},Coordinates[\[Alpha]],"x",CoordinateSystem->Coordinates[\[Alpha]]];
p=RankNumber[\[Alpha]];
\[Mu]T=TensorsProduct[(\[Alpha]/.(TensorComponents->mx_):>(TensorComponents->(mx/.rep))) xup];
Which[p===1,\[Beta]=Integrate[TensorComponents[\[Mu]T],{t,0,1}],True,\[Beta]=NonMetricTensor[RemoveUnderBarredIndices[Indices[\[Mu]T]],Map[Integrate[t^(p-1) #,{t,0,1}]&,(TensorComponents[\[Mu]T]),{p-1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]]]
];

PotentialForm[\[Alpha]_Tensor/;((*TestDifferentialForm[\[Alpha]]&&*)!TestScalarTensor[\[Alpha]]),Tensor,opts:OptionsPattern[]]:=Module[{indices,t,rep,xup,p,\[Mu]T,\[Beta]},
TestDifferentialForm[\[Alpha]];
indices=RemoveUnderBarredIndices[Indices[\[Alpha]]];
rep=Thread[Coordinates[\[Alpha]]->((t #)&/@Coordinates[\[Alpha]])];
xup=NonMetricTensor[{SuperMinus[indices[[1,1]]]},Coordinates[\[Alpha]],"x",CoordinateSystem->Coordinates[\[Alpha]]];
p=RankNumber[\[Alpha]];
\[Mu]T=TensorsProduct[(\[Alpha]/.(TensorComponents->mx_):>(TensorComponents->(mx/.rep))) xup];
Which[p===1,\[Beta]=NonMetricTensor[{},Integrate[TensorComponents[\[Mu]T],{t,0,1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]],True,\[Beta]=NonMetricTensor[RemoveUnderBarredIndices[Indices[\[Mu]T]],Map[Integrate[t^(p-1) #,{t,0,1}]&,(TensorComponents[\[Mu]T]),{p-1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]]]
];

PotentialForm[\[Alpha]_Tensor/;((*TestDifferentialForm[\[Alpha]]&&*)!TestScalarTensor[\[Alpha]]),t_Symbol,Tensor,opts:OptionsPattern[]]:=Module[{indices,rep,xup,p,\[Mu]T,\[Beta]},
TestDifferentialForm[\[Alpha]];
indices=RemoveUnderBarredIndices[Indices[\[Alpha]]];rep=Thread[Coordinates[\[Alpha]]->((t #)&/@Coordinates[\[Alpha]])];
xup=NonMetricTensor[{SuperMinus[indices[[1,1]]]},Coordinates[\[Alpha]],"x",CoordinateSystem->Coordinates[\[Alpha]]];
p=RankNumber[\[Alpha]];
\[Mu]T=TensorsProduct[(\[Alpha]/.(TensorComponents->mx_):>(TensorComponents->(mx/.rep))) xup];
Which[p===1,\[Beta]=NonMetricTensor[{},Integrate[TensorComponents[\[Mu]T],{t,0,1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]],True,\[Beta]=NonMetricTensor[RemoveUnderBarredIndices[Indices[\[Mu]T]],Map[Integrate[t^(p-1) #,{t,0,1}]&,(TensorComponents[\[Mu]T]),{p-1}],OptionValue[TensorName],CoordinateSystem->Coordinates[\[Alpha]],TooltipStyle-> TooltipStyle[\[Alpha]]]]
];


(* ::Input::Initialization:: *)
(*NewCode: LeviCivita*)
LeviCivita[\[Nu]I__,m_Tensor]/;TestMetricTensor[m]&&((* check space(time) dimensions *)Length[{\[Nu]I}]===Length[Coordinates[m]])&&(Union[TestIndices/@{\[Nu]I}]==={True}):=Module[
{mm,\[Sigma],si,cooo,d,LeviCivitaTemp},
cooo=Coordinates[m];
d=Length[cooo];
si=StartIndex[m];
mm=Power[Abs[Determinant[m]],1/2]LeviCivitaTensor[d];
(* LeviCivita w/ lower indices *)
LeviCivitaTemp=Tensor[
TensorName->OverTilde["\[Epsilon]"],
CoordinateSystem->cooo,
TensorComponents->mm,
StartIndex->si,
Indices->(SubMinus[Unique[\[Sigma]]]&/@{\[Nu]I}),
TooltipStyle-> TooltipStyle[m],
(*NewCode: TensorAssumption*)
TensorAssumption-> TensorAssumption[m],
(*NewCode: TensorOperator*)
TensorOperator->TensorOperator[m]
];
MoveIndices[LeviCivitaTemp,{\[Nu]I},m]
];

LeviCivita[\[Nu]I__,m_Tensor,Minus]/;TestMetricTensor[m]&&((* check space(time) dimensions *)Length[{\[Nu]I}]===Length[Coordinates[m]])&&(Union[TestIndices/@{\[Nu]I}]==={True}):=(LeviCivita[\[Nu]I,m]/.(TensorComponents->mx_):>(TensorComponents->-mx));

(*LeviCivita[\[Nu]I__,m_Tensor]/;TestMetricTensor[m]&&((* check space(time) dimensions *)Length[{\[Nu]I}]===Length[Coordinates[m]])&&(Union[TestIndices/@{\[Nu]I}]==={True}):=Module[
{mm,ss,\[Sigma],\[Sigma]1,\[Sigma]2,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,si,s1,s2,\[CapitalSigma]1,\[CapitalSigma]2,cooo,disp,d,cc,LeviCivitaTemp,RL,gDD,gUU,K\[Delta]},
cooo=Coordinates[m];
d=Length[cooo];
(*NewCode: ExtractFunctions*)
si=StartIndex[m];
(* prepare summation indices *)
\[CapitalSigma]1=Unique[\[Sigma]1]&/@Range[1,d];s1={\[CapitalSigma]1\[LeftDoubleBracket]#\[RightDoubleBracket],1,d}&/@Range[1,d];
mm=Power[Abs[Determinant[m]],1/2]Table[Signature[\[CapitalSigma]1],Evaluate[Sequence@@s1]];
disp="Volume form";
(* LeviCivita w/ lower indices *)
LeviCivitaTemp=Tensor[
(*NewCode: Comment out VolumeForm*)
(*TensorType\[Rule]"VolumeForm",*)
TensorName\[Rule]OverTilde["\[Epsilon]"],
CoordinateSystem\[Rule]cooo,
TensorComponents\[Rule]mm,
StartIndex\[Rule]si,
Indices\[Rule](Subscript[Unique[\[Sigma]], -]&/@{\[Nu]I})(*NewCode: Comment out VolumeForm*)(*,
TooltipDisplay\[Rule]disp*)
];
MoveIndices[LeviCivitaTemp,{\[Nu]I},m]
];*)


(* ::Input::Initialization:: *)
(* Implement the covariant Hodge Dual of Tensor \[Tau] using the Metric m *)
(* When # of Indices of \[Tau] is less than the # of dimensions *)
(*NewCode: CovariantHodgeDual*)
CovariantHodgeDual[\[Nu]I___,(\[Tau]_Tensor|(\[Tau]_/;TestExpressionForm[\[Tau]])),m_Tensor]/;TestMetricTensor[m]&&(Which[(Head[\[Tau]]===Tensor),Coordinates[\[Tau]]===Coordinates[m],True,True])&&((Union[TestIndices/@{\[Nu]I}]==={True})||(Union[TestIndices/@{\[Nu]I}]==={}))&&(Length[{\[Nu]I}]===Length[Coordinates[m]]-Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]):=Module[
{d,n,\[CapitalSigma],sF,\[Sigma],ii},
d=CoordinatesDimension[m];
n=RankNumber[\[Tau]];
\[CapitalSigma]=Table[SubMinus[Unique[\[Sigma]]],{ii,1,(d-n)}];
sF=NonMetricTensor[\[CapitalSigma],(-1)^(n (d-n)) Power[Abs[Determinant[m]],1/2] Which[n=!=0,HodgeDual[(RaiseAllIndices[\[Tau],m]//TensorComponents)],n===0,HodgeDual[(\[Tau]//TensorComponents),d]],Row[{"\[FivePointedStar]",TensorName[\[Tau]]}],CoordinateSystem->Coordinates[m],StartIndex-> StartIndex[m],TooltipStyle-> TooltipStyle[m]];
sF=MoveIndices[sF,{\[Nu]I},m];
Which[TestScalarTensor[sF],TensorComponents[sF],True,sF]
](*NewCode: CovariantHodgeDual Check condition*)(*/;((* Make sure \[Tau] (Which is LowerAllIndices one) is fully antisymmetric. *)Which[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}],TestTensorIsFullyAntiSymmetric[\[Tau]],True,TestTensorIsFullyAntiSymmetric[\[Tau],m]]||TestScalarTensor[\[Tau]]||(*Or scalar and vector*)(Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]<2)||(*Or zero Tensor*) TensorIsZero[\[Tau]]||TestExpressionForm[\[Tau]])*)

CovariantHodgeDual[\[Nu]I___,(\[Tau]_Tensor|(\[Tau]_/;TestExpressionForm[\[Tau]])),m_Tensor,Tensor]/;TestMetricTensor[m]&&(Which[(Head[\[Tau]]===Tensor),Coordinates[\[Tau]]===Coordinates[m],True,True])&&((Union[TestIndices/@{\[Nu]I}]==={True})||(Union[TestIndices/@{\[Nu]I}]==={}))&&(Length[{\[Nu]I}]===Length[Coordinates[m]]-Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]):=Module[
{d,n,\[CapitalSigma],sF,\[Sigma],ii},
d=CoordinatesDimension[m];
n=RankNumber[\[Tau]];
\[CapitalSigma]=Table[SubMinus[Unique[\[Sigma]]],{ii,1,(d-n)}];
sF=NonMetricTensor[\[CapitalSigma],(-1)^(n (d-n)) Power[Abs[Determinant[m]],1/2] Which[n=!=0,HodgeDual[(RaiseAllIndices[\[Tau],m]//TensorComponents)],n===0,HodgeDual[(\[Tau]//TensorComponents),d]],Row[{"\[FivePointedStar]",TensorName[\[Tau]]}],CoordinateSystem->Coordinates[m],StartIndex-> StartIndex[m],TooltipStyle-> TooltipStyle[m]];
sF=MoveIndices[sF,{\[Nu]I},m]
]

(*NewCode: CovariantHodgeDual: Automatically generate indices*)
CovariantHodgeDual[(\[Tau]_Tensor|(\[Tau]_/;TestExpressionForm[\[Tau]])),m_Tensor]/;(TestMetricTensor[m]&&(Which[(Head[\[Tau]]===Tensor),Coordinates[\[Tau]]===Coordinates[m],True,True])&&(Length[Coordinates[m]]>Length[RemoveUnderBarredIndices[Indices[\[Tau]]]])):=Module[
{\[Nu],l\[Nu]I,\[Nu]Ilist,i},
l\[Nu]I=Simplify[Length[Coordinates[m]]-Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]];
\[Nu]Ilist=Which[(Indices[\[Tau]]==={}),Table[SubMinus[Unique[\[Nu]]],{i,1,l\[Nu]I}],True,Which[(Head[Indices[\[Tau]][[1]]]===SuperMinus),Table[SubMinus[Unique[\[Nu]]],{i,1,l\[Nu]I}],((!MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}])&&(Head[Indices[\[Tau]][[1]]]===SubMinus)),Table[SubMinus[Unique[\[Nu]]],{i,1,l\[Nu]I}],((MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}])&&(Head[Indices[\[Tau]][[1]]]===SubMinus)),Table[SuperMinus[Unique[\[Nu]]],{i,1,l\[Nu]I}]]];
CovariantHodgeDual[Sequence@@\[Nu]Ilist,\[Tau],m]
]/;((* Make sure \[Tau] (Which is LowerAllIndices one) is fully antisymmetric. *)Which[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}],TestTensorIsFullyAntiSymmetric[\[Tau]],True,TestTensorIsFullyAntiSymmetric[\[Tau],m]]||TestScalarTensor[\[Tau]]||(*Or scalar and vector*)(Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]<2)||(*Or zero Tensor*) TensorIsZero[\[Tau]]||TestExpressionForm[\[Tau]])
(*CovariantHodgeDual[\[Nu]I__,\[Tau]_Tensor,m_Tensor]/;TestMetricTensor[m]&&(Coordinates[\[Tau]]===Coordinates[m])&&(Union[TestIndices/@{\[Nu]I}]==={True})&&(Length[{\[Nu]I}]===Length[Coordinates[m]]-Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]):=Module[
{mm,LCT,\[Sigma],\[Sigma]1,\[Sigma]2,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,s,si,s1,s2,\[CapitalSigma],\[CapitalSigma]1,\[CapitalSigma]2,cooo,disp,d,cc,LeviCivitaTemp,RL,gDD,gUU,K\[Delta]},
(* strategy: construct appropriate LeviCivita and then contract it with the Tensor \[Tau] *)
(* first construct dummy indices from the Indices of \[Tau] *)
(* remember to removeunderbarred indices *)
\[CapitalSigma]=Unique[\[Sigma]]&/@(#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]);
(* Levi-Civita tensor with the indices \[Nu]I appended with all lower indices *)
LCT=(TensorComponents[LeviCivita[\[Nu]I,(Sequence@@(SubMinus/@\[CapitalSigma])),m]]/Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]!);
(* now tensor it with \[Tau] and then contract *)
s=Length[{\[Nu]I}];
(*LCT=TensorContract[TensorProduct[LCT,TensorComponents[RaiseAllIndices[\[Tau],m]]],Table[{s+si,s+si+Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]},{si,1,Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]}]];*)

(*NewCode: CovariantHodgeDual for scalar*)LCT=Which[!TestScalarTensor[\[Tau]],TensorContract[TensorProduct[LCT,TensorComponents[RaiseAllIndices[\[Tau],m]]],Table[{s+si,s+si+Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]},{si,1,Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]}]],TestScalarTensor[\[Tau]],TensorComponents[\[Tau]] LCT];
\[Tau]/.{(* replace name *)
(TensorName\[Rule]s1_)\[RuleDelayed](TensorName\[Rule]Row[{"\[FivePointedStar]",s1}]),
(* replace tensorcomponents *)
(TensorComponents\[Rule]s2_)\[Rule](TensorComponents\[Rule]LCT),
(* replace Indices *)
(Indices\[Rule]s2_)\[Rule](Indices\[Rule]{\[Nu]I})
}
](*NewCode: CovariantHodgeDual Check condition*)/;((* Make sure \[Tau] (Which is LowerAllIndices one) is fully antisymmetric. *)Which[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}],TestTensorIsFullyAntiSymmetric[\[Tau]],True,TestTensorIsFullyAntiSymmetric[\[Tau],m]]||TestScalarTensor[\[Tau]]||(*Or scalar and vector*)(Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]<2)||(*Or zero Tensor*) TensorIsZero[\[Tau]])

(*NewCode: CovariantHodgeDual for scalar*)
CovariantHodgeDual[\[Nu]I__,\[Tau]_/;TestExpressionForm[\[Tau]],m_Tensor]/;TestMetricTensor[m]&&(Union[TestIndices/@{\[Nu]I}]==={True})&&(Length[{\[Nu]I}]===Length[Coordinates[m]]):=Module[
{mm,LCT,\[Sigma],\[Sigma]1,\[Sigma]2,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,s,si,s1,s2,\[CapitalSigma],\[CapitalSigma]1,\[CapitalSigma]2,cooo,disp,d,cc,LeviCivitaTemp,RL,gDD,gUU,K\[Delta]},
(* strategy: construct appropriate LeviCivita and then contract it with the Tensor \[Tau] *)
(* first construct dummy indices from the Indices of \[Tau] *)
(* remember to removeunderbarred indices *)
(* now tensor it with \[Tau] and then contract *)
LCT=\[Tau]  (TensorComponents[LeviCivita[\[Nu]I,m]]);
NonMetricTensor[{\[Nu]I},LCT,"\[FivePointedStar]"<>ToString[\[Tau],InputForm],CoordinateSystem\[Rule]Coordinates[m]]
]

(* When # of Indices of \[Tau] equal to # of dimensions *)
CovariantHodgeDual[\[Tau]_Tensor,m_Tensor]/;TestMetricTensor[m]&&(Coordinates[\[Tau]]===Coordinates[m])&&(Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]===Length[Coordinates[m]]):=Module[
{mm,LCT,\[Sigma],\[Sigma]1,\[Sigma]2,\[Mu],\[Nu],\[Alpha],\[Beta],\[Mu]1,\[Nu]1,\[Alpha]1,\[Beta]1,rl,s,si,s1,s2,\[CapitalSigma],\[CapitalSigma]1,\[CapitalSigma]2,cooo,disp,d,cc,LeviCivitaTemp,RL,gDD,gUU,K\[Delta]},
(* dimension *)
d=Length[Coordinates[m]];
(* strategy: construct appropriate LeviCivita and then contract it with the Tensor \[Tau] *)
(* first construct dummy indices from the Indices of \[Tau] *)
(* remember to removeunderbarred indices *)
\[CapitalSigma]=Unique[\[Sigma]]&/@Range[1,d];
(* Levi-Civita tensor with all lower indices *)
LCT=(1/d!TensorComponents[LeviCivita[(Sequence@@(SubMinus/@\[CapitalSigma])),m]]);
(* now tensor it with \[Tau] and then contract *)
(*NewCode: Scalar after CovariantHodgeDual: display ExpressionForm*)
LCT=TensorContract[TensorProduct[LCT,TensorComponents[RaiseAllIndices[\[Tau],m]]],Table[{si,d+si},{si,1,d}]](*;
\[Tau]/.{(* replace name *)
(TensorName\[Rule]s1_)\[RuleDelayed](TensorName\[Rule]Row[{"\[FivePointedStar]",s1}]),
(* replace tensorcomponents *)
(TensorComponents\[Rule]s2_)\[Rule](TensorComponents\[Rule]LCT),
(* replace Indices *)
(Indices\[Rule]s2_)\[Rule](Indices\[Rule]{})
}*)
](*NewCode: CovariantHodgeDual Check condition*)/;((* Make sure \[Tau] (Which is LowerAllIndices one) is fully antisymmetric. *)Which[MatchQ[(Union[Sgn[#]&/@RemoveUnderBarredIndices[Indices[\[Tau]]]]),{1}|{-1}],TestTensorIsFullyAntiSymmetric[\[Tau]],True,TestTensorIsFullyAntiSymmetric[\[Tau],m]]||TestScalarTensor[\[Tau]]||(*Or scalar and vector*)(Length[RemoveUnderBarredIndices[Indices[\[Tau]]]]<2)||(*Or zero Tensor*) TensorIsZero[\[Tau]])*)

(*NewCode: CovariantHodgeDual shortcut*)
(*\[FivePointedStar][\[Tau]_Tensor]:=CovariantHodgeDual[\[Tau],Cases[\[Tau],(Metric\[Rule]metric_)\[Rule]metric]\[LeftDoubleBracket]1\[RightDoubleBracket]];*)


(* ::Input::Initialization:: *)
LieDerivative[\[Xi]_Tensor,m_Tensor(*NewCode: LieDerivative OptionValue*),opts:OptionsPattern[]]/;(Quiet[TestMetricTensor[m]]&&(Dimensions[TensorComponents[\[Xi]]]==={Length[Coordinates[\[Xi]]]}==={Length[Coordinates[m]]})&&(StartIndex[\[Xi]]===StartIndex[m])&&((* either both upper or lower indices *)Times@@(Sgn[#]&/@Indices[m])===1)&&(*NewCode: LieDerivative Check Vector*)
(*NewCode: TestOneVector*)
(TestOneVector[\[Xi]](*MatchQ[Indices[\[Xi]],{SuperMinus[_]}]*))):=Module[
{Vec,\[Alpha],\[Mu],\[Nu],pd\[Xi],pdg,g\[Mu]\[Nu],g\[Mu]\[Nu]T,L1,L2,temp,idxl},
(* make sure we have a vector *)
Vec=RaiseAllIndices[\[Xi],m];
(* make sure we lowered the indices on g *)
g\[Mu]\[Nu]=Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m];
g\[Mu]\[Nu]T=TensorComponents[g\[Mu]\[Nu]];
(* Construct Partial Derivative of \[Xi] *)
pd\[Xi]=TensorComponents[PartialD[SubMinus[\[Mu]],Vec,m]];
(* Construct Partial Derivative of Subscript[g, \[Mu]\[Nu]] *)
pdg=TensorComponents[PartialD[SubMinus[\[Alpha]],g\[Mu]\[Nu],m]];
(* \[Xi]^\[Sigma]\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]
\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\) *)
L1=TensorContract[TensorProduct[TensorComponents[Vec],pdg],{{1,2}}];
(* \!\(
\*SubscriptBox[\(\[PartialD]\), \({\[Mu]\)]
\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)Subscript[g, \[Nu]}\[Sigma]] *)
L2=TensorContract[TensorProduct[pd\[Xi],g\[Mu]\[Nu]T],{{2,4}}];
(* ... remember to symmetrize *)
L2=Transpose[L2]+L2;
(*temp=Tensor[
TensorType\[Rule]"LieDerivative",
TensorName\[Rule]Row[{"\[Sterling]",Column[{Null,TensorName[\[Xi]]}],TensorName[m]}],
Indices\[Rule]Indices[g\[Mu]\[Nu]],
StartIndex\[Rule]StartIndex[\[Xi]],
CoordinateSystem\[Rule]Coordinates[\[Xi]],
TensorComponents\[Rule](*NewCode: LieDerivative OptionValue*)((L1+L2)//OptionValue[LieDerivativeOperator])];*)
(*NewCode: LieDerivative Inherit*)
temp=m/.{(TensorName->tn_)->(TensorName->Row[{"\[Sterling]",Column[{Null,TensorName[\[Xi]]}],TensorName[m]}]),
(TensorType->tn_)->(TensorType->"LieDerivative"),
(TensorComponents->mx_)->(TensorComponents->((L1+L2)//OptionValue[LieDerivativeOperator]))(*,
(TooltipDisplay\[Rule]td_)\[Rule](TooltipDisplay\[Rule]OptionValue[TooltipDisplay]),
(TooltipStyle\[Rule]tts_)\[Rule](TooltipStyle\[Rule]OptionValue[TooltipStyle])*)
};
Which[(OptionValue[TooltipDisplay]=!=Null),temp=TooltipDisplay[temp,OptionValue[TooltipDisplay]]];
Which[(OptionValue[TooltipStyle]=!={}),temp=TooltipStyle[temp,OptionValue[TooltipStyle]]];
(*NewCode: LieDerivative NewIndices*)
Which[(OptionValue[Indices]=!=Null&&((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[m]))),temp=MoveIndices[temp,OptionValue[Indices],m],True,temp=MoveIndices[temp,Indices[m],m]]
];

(*NewCode: LieDerivative on General Tensor*)
LieDerivative[\[Xi]1_Tensor,t_Tensor,opts:OptionsPattern[]]/;(!Quiet[TestMetricTensor[t]]&&(Dimensions[TensorComponents[\[Xi]1]]==={Length[Coordinates[\[Xi]1]]}==={Length[Coordinates[t]]})&&(StartIndex[\[Xi]1]===StartIndex[t])&&(Cases[TensorTypeNoPart[t],(*We have already cover the Metric one and Christoffel is not a Tensor. Check if t is not "Metric" or "ChristoffelSymbols".*)("Metric"|"ChristoffelSymbols")]==={})&&(*Since user didn't input the metric, we only allow them to be vector (w/ upper index).*)
(TestOneVector[\[Xi]1])):=Module[
{\[Xi],name,cs,si,indices,rank,pdT,\[Sigma],pd\[Xi]\[Sigma]down,pd\[Xi]\[Sigma]up,Tpd\[Xi]\[Sigma]down,Tpd\[Xi]\[Sigma]up,LieDT,tempT,i,\[Gamma],output},
(*Extract the TensorName*)
name=TensorName[\[Xi]1];
(*Extract the Coordinates*)
cs=Coordinates[\[Xi]1];
(*Extract the StartIndex*)
si=StartIndex[\[Xi]1];
(*Declare a function we can change the name of Killing vector's index.*)
\[Xi][\[Gamma]_]:=NonMetricTensor[{\[Gamma]},TensorComponents[\[Xi]1],name,CoordinateSystem->cs,StartIndex->si];
(*Extract the Indices list of t*)
indices=Indices[t];
(*RankNumber*)
rank=RankNumber[t];
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]
\*SubscriptBox[
SuperscriptBox[\(T\), \(\(
\*SubscriptBox[\(\[Mu]\), \(1\)] ... \)
\*SubscriptBox[\(\[Mu]\), \(N\)]\)], \(\(
\*SubscriptBox[\(\[Nu]\), \(1\)] ... \)
\*SubscriptBox[\(\[Nu]\), \(M\)]\)]\)*)
pdT=PartialD[SubMinus[\[Sigma]],t];
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]
\*SuperscriptBox[\(\[Xi]\), \(\[Gamma]\)]\)*)
pd\[Xi]\[Sigma]down=PartialD[SubMinus[\[Sigma]],\[Xi][SuperMinus[\[Gamma]]]];
(*\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Gamma]\)]
\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)*)
pd\[Xi]\[Sigma]up=PartialD[SubMinus[\[Gamma]],\[Xi][SuperMinus[\[Sigma]]]];
(*Subscript[T^(Subscript[\[Mu], 1]...Subscript[\[Mu], N]), Subscript[\[Nu], 1]...Subscript[\[Nu], M]]\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]
\*SuperscriptBox[\(\[Xi]\), \(\[Gamma]\)]\)*)
Tpd\[Xi]\[Sigma]down=TensorsProduct[{t,pd\[Xi]\[Sigma]down}];
(*Subscript[T^(Subscript[\[Mu], 1]...Subscript[\[Mu], N]), Subscript[\[Nu], 1]...Subscript[\[Nu], M]]\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Gamma]\)]
\*SuperscriptBox[\(\[Xi]\), \(\[Sigma]\)]\)*)
Tpd\[Xi]\[Sigma]up=TensorsProduct[{t,pd\[Xi]\[Sigma]up}];
(*Sum the \[Xi]^\[Sigma]\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Sigma]\)]
\*SubscriptBox[
SuperscriptBox[\(T\), \(\(
\*SubscriptBox[\(\[Mu]\), \(1\)] ... \)
\*SubscriptBox[\(\[Mu]\), \(N\)]\)], \(\(
\*SubscriptBox[\(\[Nu]\), \(1\)] ... \)
\*SubscriptBox[\(\[Nu]\), \(M\)]\)]\) first.*)
LieDT=(TensorsProduct[\[Xi][SuperMinus[\[Sigma]]] pdT]//TensorComponents);
(*Sum the rest of terms.*)
Do[Which[(*If i-th index of "T's" indices list is an upper index.*)Sgn[indices[[i]]]===1,
(*replace the i-th index w/ \[Sigma] and replace \[Gamma] w/the i-th index*)tempT=Tpd\[Xi]\[Sigma]down/.{indices[[i,1]]->\[Sigma],\[Gamma]->indices[[i,1]]};
(*Since we will operate TensorComponents at the end, we should make sure the indices order are consistent for every term.*)
tempT=(SwapIndices[tempT,indices]//TensorComponents);
(*For upper index, we should subtract it.*)
LieDT=LieDT-tempT,(*If i-th index of "T's" indices list is an lower index.*)Sgn[indices[[i]]]===-1,tempT=Tpd\[Xi]\[Sigma]up/.{indices[[i,1]]->\[Sigma],\[Gamma]->indices[[i,1]]};
tempT=(SwapIndices[tempT,indices]//TensorComponents);
(*For upper index, we should do plus w/ it.*)LieDT=LieDT+tempT],(*Run through all the indices*){i,1,rank}];
(*Tensor[
(*Change TensorType*)
TensorType\[Rule]"LieDerivative",
(*Add a Subscript[\[Sterling], \[Xi]] before the tensor t. \[Xi] here is the TensorName of \[Xi]1.*)
TensorName\[Rule]Row[{"\[Sterling]",Column[{Null,TensorName[\[Xi]1]}],TensorName[t]}],
(*Inherit old indices, StartIndex and CoordinateSystem.*)
Indices\[Rule]Which[(OptionValue[Indices]=!=Null&&((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[t]))),OptionValue[Indices],True,indices],
StartIndex\[Rule]si,
CoordinateSystem\[Rule]cs,
(*Sum up all the terms w/ TensorComponents and replace w/ new TensorComponents*)
TensorComponents\[Rule](LieDT//OptionValue[LieDerivativeOperator]),
TooltipStyle\[Rule]OptionValue[TooltipStyle],
TooltipDisplay\[Rule]OptionValue[TooltipDisplay]]*)
output=t/.{(TensorName->tn_)->(TensorName->Row[{"\[Sterling]",Column[{Null,TensorName[\[Xi]1]}],TensorName[t]}]),
(TensorType->tn_)->(TensorType->"LieDerivative"),(Indices->idx_)->(Indices->Which[(OptionValue[Indices]=!=Null&&((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[t]))),OptionValue[Indices],True,indices]),
(TensorComponents->mx_)->(TensorComponents->(LieDT//OptionValue[LieDerivativeOperator]))(*,
(TooltipDisplay\[Rule]td_)\[Rule](TooltipDisplay\[Rule]OptionValue[TooltipDisplay]),
(TooltipStyle\[Rule]tts_)\[Rule](TooltipStyle\[Rule]OptionValue[TooltipStyle])*)
};
Which[(OptionValue[TooltipDisplay]=!=Null),output=TooltipDisplay[output,OptionValue[TooltipDisplay]]];
Which[(OptionValue[TooltipStyle]=!={}),output=TooltipStyle[output,OptionValue[TooltipStyle]]];
output
];

(*NewCode: LieDerivative for ExpressionForm*)
LieDerivative[\[Xi]1_Tensor/;(Dimensions[TensorComponents[\[Xi]1]]==={Length[Coordinates[\[Xi]1]]})&&(*Since user didn't input the metric, we only allow them to be vector (w/ upper index).*)MatchQ[Indices[\[Xi]1],{SuperMinus[_]}],stuff_/;TestExpressionForm[stuff],opts:OptionsPattern[]]:=LieDerivative[\[Xi]1,NonMetricTensor[{},stuff,stuff,CoordinateSystem->Coordinates[\[Xi]1],StartIndex->StartIndex[\[Xi]1]],opts]//TensorComponents;

LieDerivative[stuff1_/;TestExpressionForm[stuff1],stuff2_,opts:OptionsPattern[]]:=0;

Subscript[Global`\[Sterling],a_Tensor][b_Tensor]:=LieDerivative[a,b]
(*(*NewCode: LieDerivative on Metric with new indices*)
(*For metric,we allow to move indices at the same time.*)
LieDerivative[(*New indices list*)indices_List,\[Xi]_Tensor,m_Tensor,opts:OptionsPattern[]]/;TestMetricTensor[m]&&(Dimensions[TensorComponents[\[Xi]]]==={Length[Coordinates[\[Xi]]]}==={Length[Coordinates[m]]})&&(Cases[\[Xi],(StartIndex\[Rule]mmm_)\[RuleDelayed]mmm,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]===Cases[m,(StartIndex\[Rule]mmm_)\[RuleDelayed]mmm,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket])&&((* either both upper or lower indices *)Times@@(Sgn[#]&/@Indices[m])===1)&&(MatchQ[Indices[\[Xi]],{SuperMinus[_]}])&&((Sgn[#]&/@indices)===(Sgn[#]&/@Indices[t])):=Module[
{temp},
(*Recall previous code*)
temp=LieDerivative[\[Xi],m,opts];
(*Use MoveIndices to rename and move indices*)
temp=MoveIndices[temp,indices,m]
];

(*NewCode: LieDerivative on General Tensor with new indices*)
(*For Non-metric,since user didn't input the metric,we only allow to re-name but not move the indices.*)
LieDerivative[indices_List,\[Xi]1_Tensor,t_Tensor]/;(Dimensions[TensorComponents[\[Xi]1]]==={Length[Coordinates[\[Xi]1]]}==={Length[Coordinates[t]]})&&(Cases[\[Xi]1,(StartIndex\[Rule]mmm_)\[RuleDelayed]mmm,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket]===Cases[t,(StartIndex\[Rule]mmm_)\[RuleDelayed]mmm,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket])&&(Cases[Cases[t,(TensorType\[Rule]tt_)\[Rule]tt],("Metric"|"ChristoffelSymbols")]==={})&&MatchQ[Indices[\[Xi]1],{SuperMinus[_]}]&&((Sgn[#]&/@indices)===(Sgn[#]&/@Indices[t])):=
LieDerivative[\[Xi]1,t]/.(*Re-name indices.*)(Indices\[Rule]idx_)\[Rule](Indices\[Rule]indices)*)

(*LieDerivative[\[Xi]1_Tensor,stuff_,opts:OptionsPattern[]]/;TestExpressionForm[stuff]:=*)


(* ::Input::Initialization:: *)
(*See: Operator Linearity & Operator ProductRule*)
(*
(*NewCode: LieDerivative Linearity*)
(* Thread over Plus automatically *)
LieDerivative[\[Xi]1_Tensor,t_Plus,opts:OptionsPattern[]]:=Plus@@(LieDerivative[\[Xi]1,#,opts]&/@t);
(* Implement product rule *)

LieDerivative[\[Xi]1_Tensor,t_Times/;(Union[(Head/@(List@@t))]=!={Tensor}),opts:OptionsPattern[]]:=Module[{allTensors,therest},
allTensors=Times@@Cases[(List@@t),_Tensor];
therest=Times@@DeleteCases[(List@@t),_Tensor];
therest Which[TensorIsZero[LieDerivative[\[Xi]1,allTensors,opts]],0,True,LieDerivative[\[Xi]1,allTensors,opts]]+allTensors LieDerivative[\[Xi]1,therest,opts]];

(* Use TensorsProduct to take care of TensorProduct's of Tensors *)
LieDerivative[\[Xi]1_Tensor,t_Times/;(Union[(Head/@(List@@t))]==={Tensor}),opts:OptionsPattern[]]:=LieDerivative[\[Xi]1,TensorsProduct[t],opts]
*)


(* ::Input::Initialization:: *)
(*NewCode: LieBracket*)
LieBracket[\[Xi]1_Tensor,\[Xi]2_Tensor,opts:OptionsPattern[]]/;(Dimensions[TensorComponents[\[Xi]1]]==={Length[Coordinates[\[Xi]1]]}==={Length[Coordinates[\[Xi]2]]})&&(StartIndex[\[Xi]1]===StartIndex[\[Xi]1])&&(*Since user didn't input the metric, we only allow them to be vector (w/ upper index).*)TestOneVector[\[Xi]1]&&TestOneVector[\[Xi]2]&&((Length[Cases[{opts},((LieBracketOperator|LieDerivativeOperator)->a_)->a]]===0)||(Length[Cases[{opts},((LieBracketOperator|LieDerivativeOperator)->a_)->a]]===1)):=Which[(Cases[{opts},(LieBracketOperator->a_)->LieBracketOperator]==={LieBracketOperator}),(Sequence@@List[\[Xi]1,\[Xi]2,Sequence@@({opts}/.{(LieBracketOperator->OptionValue[LieBracketOperator])->Nothing}),(LieDerivativeOperator->OptionValue[LieBracketOperator])])//LieDerivative,True,(Sequence@@List[\[Xi]1,\[Xi]2,opts])//LieDerivative]

LieBracket[stuff1_/;TestExpressionForm[stuff1],stuff2_,opts:OptionsPattern[]]:=0;

LieBracket[stuff1_,stuff2_/;TestExpressionForm[stuff2],opts:OptionsPattern[]]:=0;


(* ::Input::Initialization:: *)
(*NewCode: JacobianComponents*)
(*This piece is supposed to not include in the official version.*)
JacobianComponents[(*\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],*)ct:{Repeated[Rule[_Symbol,_]]}](*/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SuperMinus[_]}])&&(!(\[Mu]T\[LeftDoubleBracket]1\[RightDoubleBracket]===\[Nu]T\[LeftDoubleBracket]1\[RightDoubleBracket]))&&(Head[\[Mu]T\[LeftDoubleBracket]1\[RightDoubleBracket]]===Symbol&&Head[\[Nu]T\[LeftDoubleBracket]1\[RightDoubleBracket]]===Symbol)*):=Module[
{coords,rhs,lgth,jacobcomp,jacobm,i,j,row,col},
lgth=Length[ct];
coords=#[[1]]&/@ct;rhs=#[[2]]&/@ct;
jacobcomp[i_,j_]:=D[rhs[[j]](*index of \[Xi] should represent column*),coords[[i]](*index of x should represent row*)];
jacobm=Table[jacobcomp[row,col],{row,1,lgth},{col,1,lgth}]
];
JacobianComponents[(*\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],*)ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]}](*/;(MatchQ[{\[Mu]T,\[Nu]T},{SubMinus[_],SuperMinus[_]}])&&(!(\[Mu]T\[LeftDoubleBracket]1\[RightDoubleBracket]===\[Nu]T\[LeftDoubleBracket]1\[RightDoubleBracket]))&&(Head[\[Mu]T\[LeftDoubleBracket]1\[RightDoubleBracket]]===Symbol&&Head[\[Nu]T\[LeftDoubleBracket]1\[RightDoubleBracket]]===Symbol)*):=Module[
{coords,rhs,lgth,lgthrhs,jacobcomp,jacobm,i,j,row,col},
lgth=Length[ct];
lgthrhs=Length[newcoords];
rhs=#[[2]]&/@ct;
jacobcomp[i_,j_]:=D[rhs[[j]](*index of \[Xi] should represent column*),newcoords[[i]](*index of x should represent row*)];
jacobm=Table[jacobcomp[row,col],{row,1,lgthrhs},{col,1,lgth}]
];


(* ::Input::Initialization:: *)
(* Compute Jacobians for coordinate transformations *)
(* Enter r = {x \[Rule] f1[x,y,z,...], y \[Rule] f2[x,y,z,...], z \[Rule] f3[x,y,z,...], ...} *)
(* returns Union[r, {dx \[Rule] (\[PartialD]f1/\[PartialD]x)\[DifferentialD]x + (\[PartialD]f1/\[PartialD]y)\[DifferentialD]y + ..., dy \[Rule] (\[PartialD]f2/\[PartialD]x)\[DifferentialD]x + (\[PartialD]f2/\[PartialD]y)\[DifferentialD]y + ...} ] *)
(*NewCode: \[Del] transform*)
CoordinateTransformation[ct:{Repeated[Rule[_Symbol,_]]}]:=Module[
{coords,rhs,jacob,i,j,ds,R,lgth,dlist,drhs,dellist,delrhs,delR,jacobm,invjacobm},
coords=#[[1]]&/@ct;rhs=#[[2]]&/@ct;
(* dx \[Rule] (dx'/dx) dx *)
jacob[i_]:=Sum[D[rhs[[i]],coords[[j]]]\[DifferentialD]coords[[j]],{j,1,Length[coords]}];
ds=(\[DifferentialD]coords[[#]]->jacob[#])&/@Range[1,Length[coords]];
R=Flatten[{ds,ct}];
lgth=Length[ct];
(*Extract coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate Jacobian as d*d matrix form.*)
jacobm=Table[Coefficient[dlist[[a]]/.R,dlist[[b]]],{a,1,lgth},{b,1,lgth}];(*Generate inverse Jacobian as d*d matrix form.*)
(*invjacobm=Inverse[jacobm];*)
invjacobm=Transpose[Inverse[jacobm]]//Simplify;
dellist=\[Del]coords[[#]]&/@Range[1,lgth];
delR=Thread[dellist->invjacobm . dellist];
Flatten[{R,delR}]
];
(* Enter r = {x \[Rule] f1[x',y',z',...], y \[Rule] f2[x',y',z',...], z \[Rule] f3[x',y',z',...], ...} *)
(* i.e. allow for different names on the RHS than the previous *)
(* returns Union[r, {dx \[Rule] (\[PartialD]f1/\[PartialD]x')\[DifferentialD]x' + (\[PartialD]f1/\[PartialD]y')\[DifferentialD]y' + ..., dy \[Rule] (\[PartialD]f2/\[PartialD]x')\[DifferentialD]x' + (\[PartialD]f2/\[PartialD]y')\[DifferentialD]y' + ...} ] *)
(*NewCode: \[Del] transform*)
CoordinateTransformation[ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]}]:=Module[
{coords,rhs,jacob,i,j,ds,R,lgth,lgthrhs,dlist,drhs,dellist,delrhs,delR,jacobm,invjacobm},
(* extract coordinates and transformation rules *)
coords=#[[1]]&/@ct;
rhs=#[[2]]&/@ct;
(* dx \[Rule] (dx_old'/dx_new) dx_new *)
jacob[i_]:=Sum[D[rhs[[i]],newcoords[[j]]]\[DifferentialD]newcoords[[j]],{j,1,Length[newcoords]}];
ds=(\[DifferentialD]coords[[#]]->jacob[#])&/@Range[1,Length[coords]];
R=Flatten[{ds,ct}];
lgth=Length[ct];
lgthrhs=Length[newcoords];
(*New Dimension: length of newcoords. Right now it's might be redundent. Since this piece of code do not cover induced tensor.*)
(*Generate inverse Jacobian as d*d matrix form.*)
(*invjacobm=Inverse[jacobm];*)
Which[(lgth===lgthrhs),
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate a list with \[DifferentialD] in front of newcoords.*)
drhs=\[DifferentialD]newcoords[[#]]&/@Range[1,lgthrhs];
(*Generate Jacobian as d*d matrix form.*)
jacobm=Table[Coefficient[dlist[[a]]/.R,drhs[[b]]],{a,1,lgth},{b,1,lgthrhs}];invjacobm=Transpose[Inverse[jacobm]]//Simplify;
dellist=\[Del]coords[[#]]&/@Range[1,lgth];
delrhs=\[Del]newcoords[[#]]&/@Range[1,lgthrhs];
delR=Thread[dellist->invjacobm . delrhs];
Flatten[{R,delR}],(lgth=!=lgthrhs),R]
];

(*NewCode: CoordinateTransformation to one with the same symbols (Other than Metric and Christoffel)*)
CoordinateTransformation[t_Tensor/;Cases[TensorTypeNoPart[t],("Metric"|"ChristoffelSymbols")]==={}(*Shouldn't be Metric or Christoffel*)
,ct:{Repeated[Rule[_Symbol,_]]},OptionsPattern[]]/;((* check same coordinates *)#[[1]]&/@ct===Coordinates[t]):=Module[
{coords,lgth,jacobm,invjacobm,jacobT,invjacobT,R,dlist,drhs,lgthrhs,indices,idxl, newm,name,si,m,mx,tensorproduct,allindices,j,s,l},
indices=RemoveUnderBarredIndices[Indices[t]];
(*Rank number: indices list's length*)
idxl=Length[indices];
(*Dimension: length of coordinates transformation list*)
lgth=Length[ct];
(*Extract old coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*R: Jacobian replacement rule list.*)
R=CoordinateTransformation[ct];
(*Generate Jacobian as d*d matrix form.*)
jacobm=Table[Coefficient[dlist[[a]]/.R,dlist[[b]]],{a,1,lgth},{b,1,lgth}];
(*Generate inverse Jacobian as d*d matrix form.*)
(*invjacobm=Inverse[jacobm];*)
invjacobm=Transpose[Inverse[jacobm]];

(*Abondoned code: Start*)
(*jacobT[j_,i_]=NonMetricTensor[{Subscript[j, -],i^-},jacobm,"J",CoordinateSystem\[Rule]coords];
invjacobT[k_,j_]=NonMetricTensor[{Subscript[k, -],j^-},Inverse[jacobm],"J^-1",CoordinateSystem\[Rule]coords];*)
(*newm=t/.{(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule]mx/.ct)};*)
(*Abondoned code: End*)

(*New tensor: Inherit property form old one.*)
newm=t;

(*Abondoned code: Start*)
(*m=TensorComponents[t]/.ct;
mx=Table[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,invjacobm,Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,jacobm],{l,1,idxl}];
mx=Prepend[mx,m];
tensorproduct=TensorProduct[Sequence@@mx];*)
(*Abondoned code: End*)

(*Extract tensor components and perform it in new coord. We haven't contract with Jacobians yet.*)
mx=TensorComponents[t]/.ct;
(*Prepare a new indices list. Firstly inherit from the old one*)

(*
allindices=indices;
Do[
Which[(*If it's upper index*)Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,(*Tensor Product current tensor with inverse jacobian.*)mx=TensorProduct[mx,invjacobm];
(*Join Current indices list with Jacobians' indices.*)
allindices=Join[allindices//RemoveUnderBarredIndices,{SubMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]],SuperMinus[Unique[j]]}];

newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]mx)};
(*extract the new tensor components*)
mx=TensorComponents[newm];allindices=Indices[newm],
(*Same, but for lower index*)
Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,
mx=TensorProduct[mx,jacobm];allindices=Join[allindices//RemoveUnderBarredIndices,{SubMinus[Unique[j]],SuperMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]}];newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]mx)};mx=TensorComponents[newm];
allindices=Indices[newm]]
,{l,1,idxl}];*)

(*"Do" for idxl(rank number) times: 
Contract with Jacobians by hand. If current executed index is an upper index, contract with an inverse Jacobian. If it's a lower index, contract with a Jacobian.*)
Do[
Which[
(*If it's upper index, and in coordinate basis*)Sgn[indices[[s]]]===1&&(OverHatSgn[indices[[s]]]===-1),
mx=Which[
s<idxl,Transpose[TensorContract[TensorProduct[mx,(*Contract w/ inverse jacobian*)invjacobm],{{s,idxl+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,idxl],s}],
(*Least index doesn't need a Transpose.*)s===idxl,TensorContract[TensorProduct[mx,(*Contract w/ inverse jacobian*)invjacobm],{{s,idxl+1}}]],
(*If it's lower index, and in coordinate basis*)Sgn[indices[[s]]]===-1&&(OverHatSgn[indices[[s]]]===-1),
mx=Which[
s<idxl,Transpose[TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,idxl],s}],
(*Least index doesn't need a Transpose.*)s===idxl,TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}]]
],{s,1,idxl}];

(*Abondoned code: Start*)
(*allindices=indices;
Do[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,allindices=Join[allindices,{Subscript[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket], -],Unique[j]^-}],Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,allindices=Join[allindices,{Subscript[Unique[j], -],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]^-}]],{l,1,idxl}];*)
(*allindices=Table[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,{Subscript[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket], -],Unique[j]^-},Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,{Subscript[Unique[j], -],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]^-}],{l,1,idxl}];
allindices=Prepend[allindices,indices]//Flatten;
newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)};*)
(*Do[
Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,newm=TensorsProduct[newm invjacobT[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket],Unique[j]]],Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,newm=TensorsProduct[newm jacobT[Unique[j],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]]]
,{l,1,idxl}];*)
(*Abondoned code: End*)

(*Determine the output TensorName*)
name=Which[
(*If OptionValue is an integer. That is, user didn't specified it.*)
MatchQ[OptionValue[TensorName],_Integer],
(*Inherit from old tensor.*)
TensorName[t],
(*If user specified it.*)
True,
(*Specify it to be OptionValue.*)
OptionValue[TensorName]];
(*Determine the output StartIndex*)
si=Which[
(*If OptionValue is "not" an integer. That is, user didn't specified it.*)
!MatchQ[OptionValue[StartIndex],_Integer],
(*Inherit from old tensor.*)
StartIndex[t],
(*If user specified it.*)
True,
(*Specify it to be OptionValue.*)
OptionValue[StartIndex]];
(*Replace new Tensor with new TensorComponents, TensorName and StartIndex.*)
newm=newm/.{(TensorComponents->m_)->(TensorComponents->mx//OptionValue[CoordinateTransformationOperator]),(TensorName->tn_)->(TensorName->name),
(StartIndex->st_)->(StartIndex->si)
};
(*Determine the output Indices*)
Which[
(*Default value is a null list. Search: "Options[CoordinateTransformation]"
User should input a list w/ its length equals to the rank of tensor.
*)
(*If user input a proper new indices list*)
Length[OptionValue[Indices]]===idxl,
(*Make it become OptionValue.*)
indices=OptionValue[Indices]];
newm=newm/.(Indices->idx_)->(Indices->indices);
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,newm=Which[(TooltipDisplayNoPart[newm]==={}),Append[newm,TooltipDisplay->OptionValue[TooltipDisplay]],True,newm/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},newm=Which[(TooltipStyleNoPart[newm]==={}),Append[newm,TooltipStyle->OptionValue[TooltipStyle]],True,newm/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
(*Final output*)
newm
](*Check the OptionValue for indices list is OK. It's should be a list with same sign of original indices list or a null list*)/;(((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[t]))||(Sgn[#]&/@OptionValue[Indices]==={}));

(*NewCode: CoordinateTransformation to one with different symbols (Other than Metric and Christoffel)*)
CoordinateTransformation[t_Tensor/;Cases[TensorTypeNoPart[t],("Metric"|"ChristoffelSymbols")]==={}
,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},OptionsPattern[]]/;(((* check same coordinates *)#[[1]]&/@ct===Coordinates[t])&&(Length[ct]===Length[newcoords])):=Module[
{coords,lgth,jacobm,invjacobm,jacobT,invjacobT,R,dlist,drhs,lgthrhs,indices,idxl,newm,name,si,m,mx,tensorproduct,allindices,j,s,l},
indices=RemoveUnderBarredIndices[Indices[t]];
(*Rank number: indices list's length*)
idxl=Length[indices];
(*Dimension: length of coordinates transformation list*)
lgth=Length[ct];
(*New Dimension: length of newcoords. Right now it's might be redundent. Since this piece of code do not cover induced tensor.*)
lgthrhs=Length[newcoords];
(*Extract old coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate a list with \[DifferentialD] in front of newcoords.*)
drhs=\[DifferentialD]newcoords[[#]]&/@Range[1,lgthrhs];
(*R: Jacobian replacement rule list.*)
R=CoordinateTransformation[ct,newcoords];
(*Generate Jacobian as d*d matrix form.*)
jacobm=Table[Coefficient[dlist[[a]]/.R,drhs[[b]]],{a,1,lgth},{b,1,lgthrhs}];(*Generate inverse Jacobian as d*d matrix form.*)
(*invjacobm=Inverse[jacobm];*)
invjacobm=Transpose[Inverse[jacobm]];

(*Abondoned code: Start*)
(*jacobT[j_,i_]=NonMetricTensor[{Subscript[j, -],i^-},jacobm,"J",CoordinateSystem\[Rule]newcoords];
invjacobT[k_,j_]=NonMetricTensor[{Subscript[k, -],j^-},Inverse[jacobm],"J^-1",CoordinateSystem\[Rule]newcoords];*)
(*newm=t/.{(TensorComponents\[Rule]mx_)\[RuleDelayed](TensorComponents\[Rule]mx/.ct), 
(CoordinateSystem\[Rule]coords)\[Rule](CoordinateSystem\[Rule]newcoords)};*)
(*Abondoned code: End*)

(*New tensor: Inherit property form old one.*)
newm=t;

(*Abondoned code: Start*)
(*m=TensorComponents[t]/.ct;
mx=Table[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,invjacobm,Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,jacobm],{l,1,idxl}];
mx=Prepend[mx,m];
tensorproduct=TensorProduct[Sequence@@mx];*)
(*Abondoned code: End*)

(*Extract tensor components and perform it in new coord. We haven't contract with Jacobians yet.*)
mx=TensorComponents[t]/.ct;
(*Prepare a new indices list. Firstly inherit from the old one*)

(*
allindices=indices;
Do[
Which[(*If it's upper index*)
Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,
(*Tensor Product current tensor with inverse jacovian.*)
mx=TensorProduct[mx,invjacobm];
(*Join Current indices list with Jacobians' indices.*)
allindices=Join[allindices//RemoveUnderBarredIndices,{SubMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]],SuperMinus[Unique[j]]}];

newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]mx)};
(*extract the new tensor components*)
mx=TensorComponents[newm];allindices=Indices[newm],
(*Same, but for lower index*)
Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,mx=TensorProduct[mx,jacobm];allindices=Join[allindices//RemoveUnderBarredIndices,{SubMinus[Unique[j]],SuperMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]}];newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]mx)};mx=TensorComponents[newm];allindices=Indices[newm]],{l,1,idxl}];*)

(*"Do" for idxl(rank number) times: 
Contract with Jacobians by hand. If current executed index is an upper index, contract with an inverse Jacobian. If it's a lower index, contract with a Jacobian.*)
Do[
Which[
(*If it's upper index, and in coordinate basis*)Sgn[indices[[s]]]===1&&(OverHatSgn[indices[[s]]]===-1),
mx=Which[
s<idxl,Transpose[TensorContract[TensorProduct[mx,(*Contract w/ inverse jacobian*)invjacobm],{{s,idxl+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,idxl],s}],
(*Least index doesn't need a Transpose.*)s===idxl,TensorContract[TensorProduct[mx,(*Contract w/ inverse jacobian*)invjacobm],{{s,idxl+1}}]],
(*If it's lower index, and in coordinate basis*)Sgn[indices[[s]]]===-1&&(OverHatSgn[indices[[s]]]===-1),
mx=Which[
s<idxl,Transpose[TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,idxl],s}],
(*Least index doesn't need a Transpose.*)s===idxl,TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}]]
],{s,1,idxl}];

(*Abondoned code: Start*)
(*allindices=indices;
Do[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,allindices=Join[allindices,{SubMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]],SuperMinus[Unique[j]]}],Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,allindices=Join[allindices,{SubMinus[Unique[j]],SuperMinus[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]}]],{l,1,idxl}];*)
(*allindices=Table[Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,{Subscript[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket], -],Unique[j]^-},Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,{Subscript[Unique[j], -],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]^-}],{l,1,idxl}];
allindices=Prepend[allindices,indices]//Flatten;
newm=newm/.{(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)};*)
(*Do[
Which[Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===1,newm=TensorsProduct[newm invjacobT[indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket],Unique[j]]],Sgn[indices\[LeftDoubleBracket]l\[RightDoubleBracket]]===-1,newm=TensorsProduct[newm jacobT[Unique[j],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]]]
,{l,1,idxl}];*)
(*Abondoned code: End*)

(*Determine the output TensorName*)
name=Which[
(*If OptionValue is an integer. That is, user didn't specified it.*)
MatchQ[OptionValue[TensorName],_Integer],
(*Inherit from old tensor.*)
TensorName[t],
(*If user specified it.*)
True,
(*Specify it to be OptionValue.*)
OptionValue[TensorName]];
(*Determine the output StartIndex*)
si=Which[
(*If OptionValue is "not" an integer. That is, user didn't specified it.*)
!MatchQ[OptionValue[StartIndex],_Integer],
(*Inherit from old tensor.*)
StartIndex[t],
(*If user specified it.*)
True,
(*Specify it to be OptionValue.*)
OptionValue[StartIndex]];
(*Replace new Tensor with new TensorComponents, TensorName,  StartIndex and CoordinateSystem.*)
newm=newm/.{(TensorComponents->m_)->(TensorComponents->mx//OptionValue[CoordinateTransformationOperator]),(TensorName->tn_)->(TensorName->name),
(StartIndex->st_)->(StartIndex->si),(CoordinateSystem->coords)->(CoordinateSystem->newcoords)
};
(*Determine the output Indices*)
Which[
(*Default value is a null list. Search: "Options[CoordinateTransformation]"
User should input a list w/ its length equals to the rank of tensor.
*)
(*If user input a proper new indices list*)
Length[OptionValue[Indices]]===idxl,
(*Make it become OptionValue.*)
indices=OptionValue[Indices]];
newm=newm/.(Indices->idx_)->(Indices->indices);
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,newm=Which[(TooltipDisplayNoPart[newm]==={}),Append[newm,TooltipDisplay->OptionValue[TooltipDisplay]],True,newm/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},newm=Which[(TooltipStyleNoPart[newm]==={}),Append[newm,TooltipStyle->OptionValue[TooltipStyle]],True,newm/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
(*Final output*)
newm
](*Check the OptionValue for indices list is OK. It's should be a list with same sign of original indices list or a null list*)/;(((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[t]))||(Sgn[#]&/@OptionValue[Indices]==={}));


(* ::Input::Initialization:: *)
(*(* Induced Christoffel Symbol *)
CoordinateTransformation[mt_Tensor,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},opts:OptionsPattern[]]/;(((* check Metric *)Cases[mt,(TensorType\[Rule]tt_)\[Rule]tt]==={"Metric"})&&((* check same coordinates *)Sort[#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@ct]===Sort[Coordinates[mt]])(*&&((* check same dimension *)Length[#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@ct]===Length[newcoords])*)):=Module[
{coords,i,j,ds2,si,op},
(* extract old coordinates *)
coords=#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@ct;
(* extract StartIndex so we know what to sum over below *)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],Cases[mt,(StartIndex\[Rule]mmm_)\[Rule]mmm,\[Infinity]]\[LeftDoubleBracket]1\[RightDoubleBracket],True,OptionValue[StartIndex]];
(* extract metric in the form of coordinate differentials *)
ds2=TensorComponents[Metric[SubMinus[i],SubMinus[j],mt]];
ds2=Sum[ds2\[LeftDoubleBracket]i,j\[RightDoubleBracket]\[DifferentialD]coords\[LeftDoubleBracket]i\[RightDoubleBracket] \[DifferentialD]coords\[LeftDoubleBracket]j\[RightDoubleBracket],{i,1,Length[coords]},{j,1,Length[coords]}];
(* Apply CoordinateTransformation *)
op=OptionValue[CoordinateTransformationOperator];
ds2=(ds2/.CoordinateTransformation[ct,newcoords])//op;
(* Re-compute Metric using new coordinates *)
(* ensure new coordinates, StartIndex and TensorName are brought over *)
ds2=Metric[Subscript[i, -],Subscript[j, -],ds2,CoordinateSystem\[Rule]newcoords,StartIndex\[Rule]si,TensorName\[Rule]"g"];
(* output with the same indices *)
Christoffel[Sequence@@OptionValue[Indices],ds2]
]/;((Sgn[#]&/@OptionValue[Indices])==={1,-1,-1});*)
(* Coordinate transform a metric *)
(* Enter r = {x \[Rule] f1[x,y,z,...], y \[Rule] f2[x,y,z,...], z \[Rule] f3[x,y,z,...], ...} *)

(*Modified code: Change Indices for Metric*)
CoordinateTransformation[mt_Tensor,ct:{Repeated[Rule[_Symbol,_]]},opts:OptionsPattern[]]/;(((* check Metric *)(*NewCode: ExtractFunctions*)Quiet[TestMetricTensor[mt]])&&((* check same coordinates *)Sort[#[[1]]&/@ct]===Sort[Coordinates[mt]])(*No OverHat Indices*)&&(Cases[OverHatSgn[#]&/@Indices[mt],1]==={})):=Module[
{coords,i,j,ds2,si,op,name,output},
(* extract coordinates *)
coords=#[[1]]&/@ct;
(* extract StartIndex so we know what to sum over below *)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],(*NewCode: ExtractFunctions*)StartIndex[mt],True,OptionValue[StartIndex]];
(* extract metric in the form of coordinate differentials *)
ds2=TensorComponents[Metric[SubMinus[i],SubMinus[j],mt]];
ds2=Sum[ds2[[i,j]]\[DifferentialD]coords[[i]] \[DifferentialD]coords[[j]],{i,1,Length[coords]},{j,1,Length[coords]}];
(* Apply CoordinateTransformation *)
op=OptionValue[CoordinateTransformationOperator];
(*NewCode: Change Name for Metric*)
name=Which[MatchQ[OptionValue[TensorName],_Integer],(*NewCode: ExtractFunctions*)TensorName[mt],True,OptionValue[TensorName]];
ds2=(ds2/.CoordinateTransformation[ct])//op;
(* Re-compute Metric using new coordinates *)
(* ensure the StartIndex and TensorName are brought over *)
ds2=Metric[SubMinus[i],SubMinus[j],ds2,CoordinateSystem->coords,StartIndex->si,TensorName->name];
(* output with the same indices *)
(*NewCode: Change Indices for Metric*)
(*Default OptionValue of Indices is {}, whose length is 0. If user input correctly, change it for them.*)
output=Which[(Length[OptionValue[Indices]]===2),
Metric[Sequence@@OptionValue[Indices],ds2,TooltipStyle-> TooltipStyle[mt]],True,Metric[Sequence@@Indices[mt],ds2,TooltipStyle-> TooltipStyle[mt]]];
(*TooltipDisplay and TooltipStyle*)
(*Which[OptionValue[TooltipDisplay]=!=Null,output=Which[(TooltipDisplayNoPart[output]==={}),Append[output,TooltipDisplay\[Rule]OptionValue[TooltipDisplay]],True,output/.(TooltipDisplay\[Rule]td_)\[Rule](TooltipDisplay\[Rule]OptionValue[TooltipDisplay])]];*)
Which[(OptionValue[TooltipDisplay]=!=Null),output=TooltipDisplay[output,OptionValue[TooltipDisplay]]];
(*Which[OptionValue[TooltipStyle]=!={(*Small*)},output=Which[(TooltipStyleNoPart[output]==={}),Append[output,TooltipStyle\[Rule]OptionValue[TooltipStyle]],True,output/.(TooltipStyle\[Rule]tts_)\[Rule](TooltipStyle\[Rule]OptionValue[TooltipStyle])]];*)
Which[(OptionValue[TooltipStyle]=!={(*Small*)}),output=TooltipStyle[output,OptionValue[TooltipStyle]]];
output
];
(* Enter r = {x \[Rule] f1[x',y',z',...], y \[Rule] f2[x',y',z',...], z \[Rule] f3[x',y',z',...], ...} *)
(* i.e. allow for different names on the RHS than the previous *)
CoordinateTransformation[mt_Tensor,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},opts:OptionsPattern[]]/;(*NewCode: ExtractFunctions*)(((* check Metric *)Quiet[TestMetricTensor[mt]])&&((* check same coordinates *)Sort[#[[1]]&/@ct]===Sort[Coordinates[mt]])(*&&((* check same dimension *)Length[#\[LeftDoubleBracket]1\[RightDoubleBracket]&/@ct]===Length[newcoords])*)(*No OverHat Indices*)&&(Cases[OverHatSgn[#]&/@Indices[mt],1]==={})):=Module[
{coords,i,j,ds2,si,op,name,output},
(* extract old coordinates *)
coords=#[[1]]&/@ct;
(* extract StartIndex so we know what to sum over below *)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],(*NewCode: ExtractFunctions*)StartIndex[mt],True,OptionValue[StartIndex]];
(* extract metric in the form of coordinate differentials *)
ds2=TensorComponents[Metric[SubMinus[i],SubMinus[j],mt]];
ds2=Sum[ds2[[i,j]]\[DifferentialD]coords[[i]] \[DifferentialD]coords[[j]],{i,1,Length[coords]},{j,1,Length[coords]}];
(* Apply CoordinateTransformation *)
op=OptionValue[CoordinateTransformationOperator];
(*NewCode: Change Name for Metric*)
name=Which[MatchQ[OptionValue[TensorName],_Integer],(*NewCode: ExtractFunctions*)TensorName[mt],True,OptionValue[TensorName]];
ds2=(ds2/.CoordinateTransformation[ct,newcoords])//op;
(* Re-compute Metric using new coordinates *)
(* ensure new coordinates, StartIndex and TensorName are brought over *)
ds2=Metric[SubMinus[i],SubMinus[j],ds2,CoordinateSystem->newcoords,StartIndex->si,TensorName->name];
(* output with the same indices *)
(*NewCode: Change Indices for Metric*)
(*Default OptionValue of Indices is {}, whose length is 0. If user input correctly, change it for them.*)
output=Which[Length[OptionValue[Indices]]===2,
Metric[Sequence@@OptionValue[Indices],ds2,TooltipStyle-> TooltipStyle[mt]],True,Metric[Sequence@@Indices[mt],ds2,TooltipStyle-> TooltipStyle[mt]]];
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,output=Which[(TooltipDisplayNoPart[output]==={}),Append[output,TooltipDisplay->OptionValue[TooltipDisplay]],True,output/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},output=Which[(TooltipStyleNoPart[output]==={}),Append[output,TooltipStyle->OptionValue[TooltipStyle]],True,output/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
output
];

(*NewCode: Induced Tensor (Other than Metric and Christoffel) without OverHat*)
CoordinateTransformation[t_Tensor/;Cases[TensorTypeNoPart[t],("Metric"|"ChristoffelSymbols")]==={}(*Shouldn't be Metric or Christoffel*)
,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},AmbientSpaceMetric_Tensor/;TestMetricTensor[AmbientSpaceMetric],OptionsPattern[]]/;((* check same coordinates *)#[[1]]&/@ct===Coordinates[t])&&(Cases[OverHatSgn[#]&/@Indices[t],1]==={}):=Module[
{coords,lgth,jacobm, R,dlist,drhs,lgthrhs,indices,idxl, newt,name,si,tensorproduct,allindices,hyperm,InvInducedT,tempidxlist,Q,W,m,mx,l,j,lowerindices},
indices=RemoveUnderBarredIndices[Indices[t]];
(*Rank number: indices list's length*)
idxl=Length[indices];
(*Dimension: length of coordinates transformation list*)
lgth=Length[ct];
(*New Dimension: length of newcoords. Right now it's might be redundent. Since this piece of code do not cover induced tensor.*)
lgthrhs=Length[newcoords];
(*Extract old coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate a list with \[DifferentialD] in front of newcoords.*)
drhs=\[DifferentialD]newcoords[[#]]&/@Range[1,lgthrhs];
(*R: Jacobian replacement rule list.*)
R=CoordinateTransformation[ct,newcoords];
(*Generate Jacobian as d*n matrix form. n\[LessEqual]d*)
jacobm=Table[Coefficient[dlist[[a]]/.R,drhs[[b]]],{b,1,lgthrhs},{a,1,lgth}];
(*Determine the output Indices*)
Which[
(*Default value is a null list. Search: "Options[CoordinateTransformation]"
User should input a list w/ its length equals to the rank of tensor.
*)
(*If user input a proper new indices list*)
Length[OptionValue[Indices]]===idxl,
(*Make it become OptionValue.*)
indices=OptionValue[Indices]];
(*Lower all indices of tensor "t"*)
newt=LowerAllIndices[t/.ct,AmbientSpaceMetric];

(*Abondoned code: Start*)
(*Do[tensorproduct=TensorProduct[Sequence@@{(TensorComponents[newt]),jacobm}];
allindices=Join[Indices[newt],{Subscript[Unique[j], -],Indices[newt]\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]^-}];
,{l,1,idxl}];*)
(*Abondoned code: End*)

(*Abondoned code: Start*)
(*mx=Table[jacobm,{l,1,idxl}];
mx=Prepend[mx,m];
tensorproduct=TensorProduct[Sequence@@mx];
allindices=Table[{Subscript[Unique[j], -],indices\[LeftDoubleBracket]l\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]^-},{l,1,idxl}];
lowerindices=Table[Subscript[indices\[LeftDoubleBracket]l,1\[RightDoubleBracket], -],{l,1,idxl}];
allindices=Prepend[allindices,lowerindices]//Flatten;
newt=newt/.{
(Indices\[Rule]xxx_)\[Rule](Indices\[Rule]allindices),
(TensorComponents\[Rule]xxxxx_)\[Rule](TensorComponents\[Rule]tensorproduct)};*)
(*Abondoned code: End*)

(*prepare new matrix and indices*)
mx=TensorComponents[newt];
(*Since we have lower all indices, we should inherit the indices list but all w/ SubMinus*)
allindices=SubMinus[#[[1]]]&/@indices;
(*project into the hypersurface.*)
(*"Do" for idxl(rank number) times: 
Contract with Jacobians by hand. All indices are lower indices, so contract with Jacobians.*)
Do[
(*TensorProduct with a Jacobian*)
mx=TensorProduct[mx,jacobm];
(*Join Current indices list with Jacobians' indices.*)allindices=Join[(allindices//RemoveUnderBarredIndices),{SubMinus[Unique[j]],SuperMinus[indices[[l]][[1]]]}];
(*Execute the contraction. The inner contraction will be taken care by code here: Search "Einstein summation: Repeated indices are summed over""*)
newt=newt/.{(Indices->xxx_)->(Indices->allindices),
(TensorComponents->xxxxx_)->(TensorComponents->mx)};
(*extract the new tensor components*)
mx=TensorComponents[newt];allindices=Indices[newt],{l,1,idxl}];

(*generate induced inverse metric H^AB*)
(*Recall Metric coordinate transformation code.*)
InvInducedT=CoordinateTransformation[AmbientSpaceMetric,ct,newcoords,Indices->{SuperMinus[Q],SuperMinus[W]}];
(*Recover/Raise those indices which lower at the beginning.*)
newt=MoveIndices[newt,indices,InvInducedT]; 
(*Determine the output TensorName*)
name=Which[MatchQ[OptionValue[TensorName],_Integer],TensorName[t],True,OptionValue[TensorName]];
(*Determine the output StartIndex*)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],StartIndex[t],True,OptionValue[StartIndex]];
(*Replace new Tensor with new TensorComponents, TensorName,  StartIndex and CoordinateSystem.*)
newt=newt/.{(TensorComponents->mx_):>(TensorComponents->mx//OptionValue[CoordinateTransformationOperator]),(TensorName->tn_)->(TensorName->name),
(StartIndex->st_)->(StartIndex->si),
(CoordinateSystem->xxxxxx_)->(CoordinateSystem->newcoords),(Indices->idx_):> (Indices->(idx//RemoveRepeatedUnderBarredIndices))
};
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,newt=Which[(TooltipDisplayNoPart[newt]==={}),Append[newt,TooltipDisplay->OptionValue[TooltipDisplay]],True,newt/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},newt=Which[(TooltipStyleNoPart[newt]==={}),Append[newt,TooltipStyle->OptionValue[TooltipStyle]],True,newt/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
(*Final output*)
newt
];

(*NewCode: Induced Tensor (Other than Metric and Christoffel) with OverHat.*)
CoordinateTransformation[t_Tensor/;(Cases[TensorTypeNoPart[t],("Metric"|"ChristoffelSymbols")]==={})(*Shouldn't be Metric or Christoffel*)
,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},AmbientSpaceMetric_Tensor/;TestMetricTensor[AmbientSpaceMetric],OptionsPattern[]]/;((* check same coordinates *)#[[1]]&/@ct===Coordinates[t])&&!(Cases[OverHatSgn[#]&/@Indices[t],1]==={}):=Module[
{coords,lgth,jacobm, R,dlist,drhs,lgthrhs,indices,idxl, newt,name,si,tensorproduct,allindices,hyperm,InvInducedT,tempidxlist,Q,W,m,mx,l,j,lowerindices},
indices=RemoveUnderBarredIndices[Indices[t]];
(*Rank number: indices list's length*)
idxl=Length[indices];
(*Dimension: length of coordinates transformation list*)
lgth=Length[ct];
(*New Dimension: length of newcoords. Right now it's might be redundent. Since this piece of code do not cover induced tensor.*)
lgthrhs=Length[newcoords];
(*Extract old coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate a list with \[DifferentialD] in front of newcoords.*)
drhs=\[DifferentialD]newcoords[[#]]&/@Range[1,lgthrhs];
(*R: Jacobian replacement rule list.*)
R=CoordinateTransformation[ct,newcoords];
(*Generate Jacobian as d*n matrix form. n\[LessEqual]d*)
jacobm=Table[Coefficient[dlist[[a]]/.R,drhs[[b]]],{a,1,lgth},{b,1,lgthrhs}];
(*Determine the output Indices*)
Which[
(*Default value is a null list. Search: "Options[CoordinateTransformation]"
User should input a list w/ its length equals to the rank of tensor.
*)
(*If user input a proper new indices list*)
Length[OptionValue[Indices]]===idxl,
(*Make it become OptionValue.*)
indices=OptionValue[Indices]];
(*Lower all indices of tensor "t"*)
allindices=Which[(OverHatSgn[#]===-1),SubMinus[#[[1]]],(OverHatSgn[#]===+1),#]&/@indices;
newt=MoveIndices[t/.ct,allindices,AmbientSpaceMetric];

(*prepare new matrix and indices*)
mx=TensorComponents[newt];
(*Since we have lower all indices, we should inherit the indices list but all w/ SubMinus*)

(*project into the hypersurface.*)
(*"Do" for idxl(rank number) times: 
Contract with Jacobians by hand. If current executed index is an upper index, contract with an inverse Jacobian. If it's a lower index, contract with a Jacobian.*)
Do[
Which[
(*If it's in coordinate basis*)(OverHatSgn[indices[[s]]]===-1),
mx=Which[
s<idxl,Transpose[TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}],{Sequence@@Range[1,s-1],Sequence@@Range[s+1,idxl],s}],
(*Least index doesn't need a Transpose.*)s===idxl,TensorContract[TensorProduct[mx,(*Contract w/ jacobian*)jacobm],{{s,idxl+1}}]]
],{s,1,idxl}];

(*generate induced inverse metric H^AB*)
(*Recall Metric coordinate transformation code.*)
InvInducedT=CoordinateTransformation[AmbientSpaceMetric,ct,newcoords,Indices->{SuperMinus[Q],SuperMinus[W]}];
(*Recover/Raise those indices which lower at the beginning.*)
newt=MoveIndices[newt/.(TensorComponents->mmm_)->(TensorComponents->mx),indices,InvInducedT]; 
(*Determine the output TensorName*)
name=Which[MatchQ[OptionValue[TensorName],_Integer],TensorName[t],True,OptionValue[TensorName]];
(*Determine the output StartIndex*)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],StartIndex[t],True,OptionValue[StartIndex]];
(*Replace new Tensor with new TensorComponents, TensorName,  StartIndex and CoordinateSystem.*)
newt=newt/.{(TensorComponents->mx_):>(TensorComponents->mx//OptionValue[CoordinateTransformationOperator]),(TensorName->tn_)->(TensorName->name),
(StartIndex->st_)->(StartIndex->si),
(CoordinateSystem->xxxxxx_)->(CoordinateSystem->newcoords),(Indices->idx_):> (Indices->(idx//RemoveRepeatedUnderBarredIndices))
};
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,newt=Which[(TooltipDisplayNoPart[newt]==={}),Append[newt,TooltipDisplay->OptionValue[TooltipDisplay]],True,newt/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},newt=Which[(TooltipStyleNoPart[newt]==={}),Append[newt,TooltipStyle->OptionValue[TooltipStyle]],True,newt/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
(*Final output*)
newt
];

(*NewCode: CoordinateTransformation for Christoffel*)
CoordinateTransformation[chr_Tensor/;Cases[TensorTypeNoPart[chr],"ChristoffelSymbols"]=!={}
,ct:{Repeated[Rule[_Symbol,_]]},newcoords:{Repeated[_Symbol]},OptionsPattern[]]/;(((* check same coordinates *)#[[1]]&/@ct===Coordinates[chr])&&(RankNumber[chr]===3)(*No OverHat Indices*)&&(Cases[OverHatSgn[#]&/@Indices[chr],1]==={})):=Module[
{coords,lgth,jacobm,jacobT,invjacobT,R,dlist,drhs,lgthrhs,indices,idxl,newchr,name,si,cps,grandom,DoubleD,Secondterm,kk,Firstterm,disp,i,j,k,l,hessian,invjacobm},
(*Indices of input Christoffel*)
indices=RemoveUnderBarredIndices[Indices[chr]];
(*RankNumber: Christoffel is a rank-3 array.*)
idxl=3;
(*Determine the output Indices.*)
Which[Length[OptionValue[Indices]]===idxl,
indices=OptionValue[Indices]];
(*Dimension: length of coordinates transformation list*)
lgth=Length[ct];
(*New Dimension: length of newcoords. Right now it's might be redundent. Since this piece of code do not cover induced Christoffel.*)
lgthrhs=Length[newcoords];
(*Extract old coordinates*)
coords=#[[1]]&/@ct;
(*Generate a list with \[DifferentialD] in front of coordinates.*)
dlist=\[DifferentialD]coords[[#]]&/@Range[1,lgth];
(*Generate a list with \[DifferentialD] in front of newcoords.*)
drhs=\[DifferentialD]newcoords[[#]]&/@Range[1,lgthrhs];
(*R: Jacobian replacement rule list.*)
R=CoordinateTransformation[ct,newcoords];
(*Generate Jacobian as d*d matrix form.*)
jacobm=Table[Coefficient[dlist[[a]]/.R,drhs[[b]]],{b,1,lgthrhs},{a,1,lgth}];
(*Generate Jacobian as a Tensor object.*)
jacobT=NonMetricTensor[{SubMinus[i],SuperMinus[k]},jacobm,"J",CoordinateSystem->newcoords];
(*Generate Hessian as a Tensor object by utilize "PD". Search "Derivative for Tensor".*)
hessian=Table[D[jacobT,newcoords[[\[Sigma]]]],
{\[Sigma],1,lgthrhs},Evaluate[Sequence@@({#,0,lgthrhs-1}&/@{i,k})]];
(*Generate inverse Jacobian as d*d matrix form.*)
invjacobm=Inverse[jacobm];
(*Contract inverse Jacobian  and Hessian by hand.*)
Secondterm=NonMetricTensor[{SubMinus[k],SuperMinus[l],SubMinus[j],SubMinus[i],SuperMinus[k]},TensorProduct[Sequence@@{invjacobm,hessian}],"S",CoordinateSystem->newcoords];

(*Abondoned code: Start*)
(*grandom=Metric[Subscript[i, -],Subscript[j, -],Table[KroneckerDelta[row,col],{row,1,lgthrhs},{col,1,lgthrhs}],TensorName\[Rule]"g",CoordinateSystem\[Rule]newcoords];
jacobm=Table[Coefficient[dlist\[LeftDoubleBracket]a\[RightDoubleBracket]/.R,drhs\[LeftDoubleBracket]b\[RightDoubleBracket]],{b,1,lgthrhs},{a,1,lgth}];
jacobT[i_,k_]=NonMetricTensor[{Subscript[i, -],k^-},jacobm,"J",CoordinateSystem\[Rule]newcoords];
invjacobT[k_,l_]=NonMetricTensor[{Subscript[k, -],l^-},Inverse[jacobm],"J^-1",CoordinateSystem\[Rule]newcoords];
DoubleD[k_]=PartialD[indices\[LeftDoubleBracket]3\[RightDoubleBracket],jacobT[indices\[LeftDoubleBracket]2\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket],k],grandom];
Secondterm=SwapIndices[TensorsProduct[DoubleD[kk] invjacobT[kk,indices\[LeftDoubleBracket]1\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]]],indices];*)
(*Abondoned code: End*)

(*The first term is the one transform like a normal tensor.*)
Firstterm=CoordinateTransformation[chr/.(TensorType->"ChristoffelSymbols")->(TensorType->Null),ct,newcoords,Indices->indices];
(*Sum them up.*)
cps=TensorComponents[Firstterm+Secondterm]//OptionValue[CoordinateTransformationOperator];
(*Determine the output TensorName*)
name=Which[MatchQ[OptionValue[TensorName],_Integer],TensorName[chr],True,OptionValue[TensorName]];
(*Determine the output StartIndex*)
si=Which[!MatchQ[OptionValue[StartIndex],_Integer],StartIndex[chr],True,OptionValue[StartIndex]];
(*Determine the output TooltipDisplay*)
disp=Flatten[Table[(Row[{"\[CapitalGamma]",Column[{newcoords[[\[Mu]s]],Null}],Column[{Null,newcoords[[\[Alpha]s]]}],Column[{Null,newcoords[[\[Beta]s]]}]}]->cps[[\[Mu]s,\[Alpha]s,\[Beta]s]]),{\[Mu]s,1,lgthrhs},{\[Alpha]s,1,lgthrhs},{\[Beta]s,1,lgthrhs}]];
(*Only display nonzero components*)
disp=Select[disp,(Flatten[Cases[{#},(Row[__]->cc_)->cc]][[1]]=!=0)&];
(*Inherit old chr array and replace w/ new property.*)
newchr=chr/.{(TensorName->tn_)->(TensorName->name),
(StartIndex->st_)->(StartIndex->si),(TensorComponents->mx_)->(TensorComponents->cps), 
(CoordinateSystem->coords)->(CoordinateSystem->newcoords),(Indices->idx_)->(Indices->indices),(TooltipDisplay->dp_)->(TooltipDisplay->disp)
};
(*TooltipDisplay and TooltipStyle*)
Which[OptionValue[TooltipDisplay]=!=Null,Which[(TooltipDisplayNoPart[newchr]==={}),Append[newchr,TooltipDisplay->OptionValue[TooltipStyle]],True,newchr=newchr/.(TooltipDisplay->td_)->(TooltipDisplay->OptionValue[TooltipDisplay])]];
Which[OptionValue[TooltipStyle]=!={(*Small*)},newchr=newchr/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])];
Which[OptionValue[TooltipStyle]=!={(*Small*)},Which[(TooltipStyleNoPart[newchr]==={}),Append[newchr,TooltipStyle->OptionValue[TooltipStyle]],True,newchr=newchr/.(TooltipStyle->tts_)->(TooltipStyle->OptionValue[TooltipStyle])]];
(*Final output*)
newchr
](*check if user input new indices list, they are proper. Or it should be default one (Null list).*)/;(((Sgn[#]&/@OptionValue[Indices])===(Sgn[#]&/@Indices[chr]))||(Sgn[#]&/@OptionValue[Indices]==={}));


(* ::Input::Initialization:: *)
(* TensorIsZero returns True if every component of the input Tensor is zero and False otherwise *)
(*NewCode: TensorIsZero Pattern*)
TensorIsZero[(stuff_Tensor|stuff_Times|stuff_Plus)/;!TestExpressionForm[stuff],opts:OptionsPattern[]]:=Module[{stuffop,stuffopTorF,TIZop,TIZopTorF,tensorcomp=Normal[TensorComponents[stuff]]},
(*stuff's TensorOperator*)
stuffop=TensorOperator[Cases[{stuff},Tensor[___],Infinity][[1]]];
(*stuff's TensorOperator is Simplify or not Simplify. True for not Simplify. False for Simplify*)
stuffopTorF=Which[(stuffop=!=Simplify),True,True,False];
TIZop=OptionValue[TensorIsZeroOperator];
(*stuff's TensorOperator is Simplify or not Simplify. True for not Simplify. False for Simplify*)
TIZopTorF=Which[(TIZop=!=Simplify),True,True,False];
Which[
(* non-scalar *)(Head[tensorcomp]===List),(Which[(TIZopTorF===True),
Union[(Flatten[tensorcomp]//TIZop)],
(TIZopTorF===False),
Which[(stuffopTorF===True),
Union[(Flatten[tensorcomp]//stuffop)],
(stuffopTorF===False),
Union[Simplify[Flatten[tensorcomp]]]
]
]==={0}),
True,((* scalar case *)Which[(TIZopTorF===True),
Simplify[tensorcomp,TIZop],
(TIZopTorF===False),
Which[(stuffopTorF===True),
(tensorcomp//stuffop),
(stuffopTorF===False),
Simplify[tensorcomp]
]
]===0)]
];

(*NewCode: TensorIsZero for List*)
(*Now we allow it to input a List*)
TensorIsZero[stuff_List,opts:OptionsPattern[]]:=
(Union[(Flatten[stuff]//OptionValue[TensorIsZeroOperator])]==={0});

(*NewCode: TensorIsZero for ExpressionForm*)
TensorIsZero[stuff_/;TestExpressionForm[stuff],opts:OptionsPattern[]]:=((stuff//OptionValue[TensorIsZeroOperator])===0);


(* ::Input::Initialization:: *)
(*NewCode: TensorEquations*)
TensorEquations[(t_Tensor|t_Times|t_Plus),0(*,opts:OptionsPattern[]*)]/;(*If head is Times or Plus, there should be Tensor inside it*)(!TestExpressionForm[t]):=Module[{comp=Normal[TensorComponents[t]]},(*DeleteDuplicates*)Which[(Head[comp]=!=List),(comp==0),(Head[comp]===List),DeleteDuplicates[(#==0)&/@Flatten[comp]]/.(*Remove redundent True result.*)True->Nothing]];

TensorEquations[(LHSt_Tensor|LHSt_Times|LHSt_Plus),(RHSt_Tensor|RHSt_Times|RHSt_Plus)(*,opts:OptionsPattern[]*)]/;(!TestExpressionForm[LHSt])&&(!TestExpressionForm[RHSt]):=Module[{LHScomp=Normal[TensorComponents[LHSt]],RHScomp=Normal[TensorComponents[RHSt]],EqLHSmRHSm},Quiet[Which[(Head[LHScomp]=!=List)&&(Head[RHScomp]=!=List),(LHScomp==RHScomp),(Head[LHScomp]===List)&&(Head[RHScomp]===List),EqLHSmRHSm=Equal[LHScomp,RHScomp];
Which[(EqLHSmRHSm===True),True,(EqLHSmRHSm===False),False,True,DeleteDuplicates[Thread[Flatten/@EqLHSmRHSm]]/.{True->Nothing}]
]
](*/.(DeleteDuplicates[Nothing]\[Rule] {})*)
];

(*TensorEquations[t_,0(*,opts:OptionsPattern[]*)]/;(*If head is Times or Plus, there should be Tensor inside it*)(TestExpressionForm[t]):=(t\[Equal]0)*)

TensorEquations[LHSt_,RHSt_(*,opts:OptionsPattern[]*)]/;(TestExpressionForm[LHSt])&&(TestExpressionForm[RHSt]):=(LHSt==RHSt)

(*TensorEquations[LHSt_Tensor,RHSt_Tensor]/;((Sgn[#]&/@RemoveUnderBarredIndices[Indices[LHSt]])===(Sgn[#]&/@RemoveUnderBarredIndices[Indices[RHSt]]))&&(Coordinates[LHSt]===Coordinates[RHSt])&&(Dimensions[LHSt]===Dimensions[RHSt]):=Module[{rank,eqnlist},rank=RankNumber[LHSt];
eqnlist=Thread[TensorComponents[LHSt]==TensorComponents[RHSt]];
Do[eqnlist=(Flatten[Map[(Thread[#]&),eqnlist]]),rank-1];
DeleteDuplicates[eqnlist]/.True\[Rule]Nothing
];*)

(*TensorEquations[(LHSt_Tensor|LHSt_Times|LHSt_Plus),(RHSt_Tensor|RHSt_Times|RHSt_Plus)]/;(Cases[LHSt,Tensor[___],{0,Infinity}]\[NotEqual]{})&&(Cases[RHSt,Tensor[___],{0,Infinity}]\[NotEqual]{}):=Module[{rank,eqnlist},rank=RankNumber[First[Cases[LHSt,Tensor[___],{0,Infinity}]]];
eqnlist=Thread[TensorComponents[LHSt]==TensorComponents[RHSt]];
Do[eqnlist=(Flatten[Map[(Thread[#]&),eqnlist]]),rank-1];
DeleteDuplicates[eqnlist]/.True\[Rule]Nothing
];*)


(* ::Input::Initialization:: *)
(*NewCode: TensorDivision*)
TensorDivision[(*LHS is numerator.*)(LHSt_Tensor|LHSt_Times|LHSt_Plus),(*RHS is denominator.*)(RHSt_Tensor|RHSt_Times|RHSt_Plus),opts:OptionsPattern[]]/;(!TestExpressionForm[LHSt])&&(!TestExpressionForm[RHSt]):=Module[{stuffop,stuffopTorF,TDop,TDopTorF,op,LHScomp,RHScomp,NonTrivialcompN,EquilityList,\[Kappa],solnst,solns,solnsFlatten,solnsUnion,soln,LHSttemp=LHSt,RHSttemp=RHSt,rank=RankNumber[LHSt]},
Which[((Head[LHSt]===Times)||(Head[LHSt]===Plus)),LHSttemp=TensorsProduct[LHSt, Tensor]];
Which[((Head[RHSt]===Times)||(Head[RHSt]===Plus)),RHSttemp=TensorsProduct[RHSt, Tensor]];
(*stuff's TensorOperator*)
stuffop=TensorOperator[LHSttemp];
(*stuff's TensorOperator is Simplify or not Simplify. True for not Simplify. False for Simplify*)
stuffopTorF=Which[(stuffop=!=Simplify),True,True,False];
TDop=OptionValue[TensorDivisionOperator];
(*stuff's TensorOperator is Simplify or not Simplify. True for not Simplify. False for Simplify*)
TDopTorF=Which[(TDop=!=Simplify),True,True,False];
op=Which[TDopTorF,TDop,stuffopTorF,stuffop,True,TDop];
LHScomp=LHSttemp//TensorComponents//op;
RHScomp=RHSttemp//TensorComponents//op;
Which[(ComponentRankNumber[LHScomp]=!=0),
NonTrivialcompN=Length[(Flatten[LHScomp])/.{0->Nothing}];
EquilityList=MapThread[Equal,{LHScomp,\[Kappa] RHScomp},rank];
solnst=Map[Solve[#,\[Kappa]]&,EquilityList,{rank}];
solns=solnst//op;
solnsFlatten=(Flatten[solns/.({{}}->{{ "\!\(\*FractionBox[\(0\), \(0\)]\)"}}),{1,rank+2}])/.{{}->\[Infinity],{\[Kappa]->soln___}:> soln};
solnsUnion=((solnsFlatten//Flatten)//Union)/."\!\(\*FractionBox[\(0\), \(0\)]\)"-> Nothing;
Which[((Length[((solnsFlatten//Flatten)/."\!\(\*FractionBox[\(0\), \(0\)]\)"-> Nothing)]===NonTrivialcompN)&&(Length[solnsUnion]===1)),solnsUnion[[1]],True,LHSt/.{(TensorComponents->mx_)-> (TensorComponents->(solnsFlatten/.{"\!\(\*FractionBox[\(0\), \(0\)]\)"}->"\!\(\*FractionBox[\(0\), \(0\)]\)")),(TensorName->tn_)->(TensorName->TensorName[LHSttemp]/TensorName[RHSttemp])}],
(ComponentRankNumber[LHScomp]===0),(Solve[LHScomp==\[Kappa] RHScomp,\[Kappa]]/.{{{\[Kappa]->soln___}}:> (soln//op)})
]
];


(* ::Input::Initialization:: *)
GeodesicSystem[m_Tensor,opts:OptionsPattern[]]/;TestMetricTensor[m]:=Module[
{mm,ss,\[Sigma],\[Mu],\[Nu],si,cooo,d,cc,coo\[Lambda],coot,a\[Lambda],ct,comehere,L\[Lambda],Lt,output},
(* extract affine and non-affine parameter for solving geodesic eqn *)
a\[Lambda]=OptionValue[AffineParameter];
cooo=Coordinates[m];
(* non-affine parameter *)
ct=Intersection[{OptionValue[NonAffineParameter]},cooo];
Which[
(* if input NonAffineParameter is one of the coordinates *)
Length[ct]===1,
coot=Which[#===ct[[1]],ct[[1]],#=!=ct[[1]],#/.#->#[ct[[1]]]]&/@cooo,
(* if input NonAffineParameter is not one of the coordinates *)
ct==={},
coot=(#/.#->#[OptionValue[NonAffineParameter]])&/@cooo];
ct=OptionValue[NonAffineParameter];
(* coordinates as a function of affine parameter *)
coo\[Lambda]=(#/.#->#[a\[Lambda]])&/@cooo;
d=Length[cooo];
(* construct affine parameter Lagrangian *)
L\[Lambda]=TensorComponents[Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m]]/.Thread[Rule[cooo,coo\[Lambda]]];
L\[Lambda]=(1/2)Sum[L\[Lambda][[\[Mu],\[Nu]]]D[coo\[Lambda],a\[Lambda]][[\[Mu]]]D[coo\[Lambda],a\[Lambda]][[\[Nu]]],{\[Mu],1,d},{\[Nu],1,d}];
(* construct non-affine parameter Lagrangian *)
Lt=TensorComponents[Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m]]/.Thread[Rule[cooo,coot]];
Lt=Power[Sum[Lt[[\[Mu],\[Nu]]]D[coot,ct][[\[Mu]]]D[coot,ct][[\[Nu]]],{\[Mu],1,d},{\[Nu],1,d}],1/2];
(* output: 
(1) Lag in affine parameter form, Lag in non-affine parameter form;
(2) Geodesic Equations in affine parameter form;
(3) Geodesic Equations in non-affine parameter form *)
{L\[Lambda],Lt,EulerEquations[L\[Lambda],coo\[Lambda],a\[Lambda]],EulerEquations[Lt,Complement[coot,{ct}],ct]}
]/;((Head[OptionValue[AffineParameter]]===Symbol)&&(Head[OptionValue[NonAffineParameter]]===Symbol));


(* ::Input::Initialization:: *)
GeodesicLagrangians[m_Tensor,opts:OptionsPattern[]]/;TestMetricTensor[m]:=Module[
{mm,ss,\[Sigma],\[Mu],\[Nu],si,cooo,d,cc,coo\[Lambda],coot,a\[Lambda],ct,comehere,L\[Lambda],Lt,output},
(* extract affine and non-affine parameter for solving geodesic eqn *)
a\[Lambda]=OptionValue[AffineParameter];
cooo=Coordinates[m];
(* non-affine parameter *)
ct=Intersection[{OptionValue[NonAffineParameter]},cooo];
Which[
(* if input NonAffineParameter is one of the coordinates *)
Length[ct]===1,
coot=Which[#===ct[[1]],ct[[1]],#=!=ct[[1]],#/.#->#[ct[[1]]]]&/@cooo,
(* if input NonAffineParameter is not one of the coordinates *)
ct==={},
coot=(#/.#->#[OptionValue[NonAffineParameter]])&/@cooo];
ct=OptionValue[NonAffineParameter];
(* coordinates as a function of affine parameter *)
coo\[Lambda]=(#/.#->#[a\[Lambda]])&/@cooo;
d=Length[cooo];
(* construct affine parameter Lagrangian *)
L\[Lambda]=TensorComponents[Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m]]/.Thread[Rule[cooo,coo\[Lambda]]];
L\[Lambda]=(1/2)Sum[L\[Lambda][[\[Mu],\[Nu]]]D[coo\[Lambda],a\[Lambda]][[\[Mu]]]D[coo\[Lambda],a\[Lambda]][[\[Nu]]],{\[Mu],1,d},{\[Nu],1,d}];
(* construct non-affine parameter Lagrangian *)
Lt=TensorComponents[Metric[SubMinus[\[Mu]],SubMinus[\[Nu]],m]]/.Thread[Rule[cooo,coot]];
Lt=Power[Sum[Lt[[\[Mu],\[Nu]]]D[coot,ct][[\[Mu]]]D[coot,ct][[\[Nu]]],{\[Mu],1,d},{\[Nu],1,d}],1/2];
(* output: 
(1) Lag in affine parameter form, Lag in non-affine parameter form *)
{L\[Lambda],Lt}
]/;((Head[OptionValue[AffineParameter]]===Symbol)&&(Head[OptionValue[NonAffineParameter]]===Symbol));


(* ::Input::Initialization:: *)
GeodesicHamiltonianDynamics[m_Tensor,cp_List,a\[Lambda]_Symbol]/;TestMetricTensor[m]&&(* list of Rules relating coords to momenta *)MatchQ[cp[[1]],Repeated[Rule[lhs_,rhs_]]]&&(* lhs of Rules in cp should be the coordinates of m *)(Union[Evaluate[(cp/.Rule[lhs_,rhs_]->lhs)],Coordinates[m]]===Sort[Coordinates[m]])&&(* Affine Parameter should not be coordinate *)(Intersection[Coordinates[m],{a\[Lambda]}]==={}):=Module[
{mm,ss,\[Sigma],\[Mu],\[Nu],si,cooo,d,cc,coo\[Lambda],p\[Lambda],coot,ct,comehere,H\[Lambda],g\[Mu]\[Nu],Lt,output,coo\[Lambda]Eqn,p\[Lambda]Eqn},
(* extract affine and non-affine parameter for solving geodesic eqn *)
cooo=Coordinates[m];
(* coordinates as a function of affine parameter *)
coo\[Lambda]=(#/.#->#[a\[Lambda]])&/@cooo;
(* momentum as a function of affine parameter *)
p\[Lambda]=(#/.#->#[a\[Lambda]])&/@(cooo/.cp);
d=Length[cooo];
(* construct affine parameter Hamiltonian *)
g\[Mu]\[Nu]=TensorComponents[Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m]]/.Thread[Rule[cooo,coo\[Lambda]]];
H\[Lambda]=(1/2)Sum[g\[Mu]\[Nu][[\[Mu],\[Nu]]]p\[Lambda][[\[Mu]]]p\[Lambda][[\[Nu]]],{\[Mu],1,d},{\[Nu],1,d}];
(* Overscript[x, .]^\[Mu] = g^\[Mu]\[Nu]Subscript[p, \[Nu]] *)
coo\[Lambda]Eqn=(D[coo\[Lambda][[#]],a\[Lambda]]==Sum[g\[Mu]\[Nu][[#,\[Nu]]]p\[Lambda][[\[Nu]]],{\[Nu],1,d}])&/@Range[1,d];
(* Subscript[Overscript[p, .], \[Mu]] = - \[PartialD]H/\[PartialD]x^\[Mu] = -(1/2)\!\(
\*SubscriptBox[\(\[PartialD]\), \(\[Mu]\)]
\*SuperscriptBox[\(g\), \(\[Alpha]\[Beta]\)]\) Subscript[p, \[Alpha]] Subscript[p, \[Beta]] *)
p\[Lambda]Eqn=(D[p\[Lambda][[#]],a\[Lambda]]==-D[H\[Lambda],coo\[Lambda][[#]]])&/@Range[1,d];
(* output: Hamiltonian, {xdot eqns, pdot eqns} *)
{H\[Lambda],Join[coo\[Lambda]Eqn,p\[Lambda]Eqn]}
];


(* ::Input::Initialization:: *)
(*NewCode: SphericalHarmonicYTensor*)
SphericalHarmonicYTensor[l_,m_,\[Theta]_Symbol,\[Phi]_Symbol,opts:OptionsPattern[]]:=Module[{g,i,j,Y,k,result,tempidx},
g=Metric[SubMinus[i],SubMinus[j],({
 {1, 0},
 {0, Sin[\[Theta]]^2}
}),CoordinateSystem->{\[Theta],\[Phi]},TensorName->"g",StartIndex->1];
Y=NonMetricTensor[{},SphericalHarmonicY[l,m,\[Theta],\[Phi]],Row[{"Y",Column[{m,l}]}],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1,TensorAssumption-> {0<= \[Phi]<=2Pi,0<=\[Theta]<=Pi}];
Which[OptionValue[TooltipDisplay]=!=Null,Y=TooltipDisplay[Y,OptionValue[TooltipDisplay]]];
Which[OptionValue[TooltipStyle]=!={},Y=TooltipStyle[Y,OptionValue[TooltipStyle]]];
Y
]/;((Element[l,Complexes]===True)||MatchQ[Head[l],(Symbol|Plus|Times)])&&((Element[m,Complexes]===True)||MatchQ[Head[m],(Symbol|Plus|Times)])(*&&Which[((Element[l,Complexes]===True)&&(Element[m,Complexes]===True)),(l\[GreaterEqual]0)&&(-l\[LessEqual]m\[LessEqual]l),True,True]*);

SphericalHarmonicYTensor[l_,m_,g_Tensor/;(TestMetricTensor[g]&&(Dimensions[g]==={2,2})&&TensorIsZero[(g-Ricci[SubMinus[Unique[i]],SubMinus[Unique[j]],g])//Simplify]),opts:OptionsPattern[]]:=Module[{coord,i,j,Y,k,result,tempidx,FS,FSlist},
coord=Coordinates[g];
Y=NonMetricTensor[{},SphericalHarmonicY[l,m,Sequence@@coord],Row[{"Y",Column[{m,l}]}],CoordinateSystem->coord,StartIndex->1];
Y=TooltipDisplay[Y,OptionValue[TooltipDisplay]];
Y=TooltipStyle[Y,OptionValue[TooltipStyle]];
Y
]/;((Element[l,Complexes]===True)||MatchQ[Head[l],(Symbol|Plus|Times)])&&((Element[m,Complexes]===True)||MatchQ[Head[m],(Symbol|Plus|Times)])(*&&Which[((Element[l,Complexes]===True)&&(Element[m,Complexes]===True)),(l\[GreaterEqual]0)&&(-l\[LessEqual]m\[LessEqual]l),True,True]*);


(* ::Input::Initialization:: *)
(*NewCode: VectorSphericalHarmonic*)
VectorSphericalHarmonic[idx_/;(TestIndices[idx]),l_,m_,\[Theta]_Symbol,\[Phi]_Symbol,VectorType_/;MatchQ[VectorType,("Gradient"|"Curl")],opts:OptionsPattern[]]:=Module[{g,i,j,result,norm,tempidx,FS,FSlist,ltemp,mtemp},
norm=OptionValue[Normalize];
FSlist={0<= \[Phi]<=2Pi,0<=\[Theta]<=Pi};
Which[!IntegerQ[l],AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[!IntegerQ[m],AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l<=m<=l]];
(*We find that it took too long time to calculate a good form of VectorSphericalHarmonic.That' s why we want to save the result directly. See Wei-Hao test notebook part 2.*)
result=Which[(VectorType==="Gradient")&&(Head[idx]===SuperMinus),NonMetricTensor[{SuperMinus[tempidx]},{mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) Sqrt[(ltemp-mtemp) (1+ltemp+mtemp)] SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]],I mtemp Csc[\[Theta]]^2 SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]},Del[Row[{"Y",Column[{mtemp,ltemp}]}]],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1,TensorAssumption-> FSlist],
(VectorType==="Curl")&&(Head[idx]===SuperMinus),
NonMetricTensor[{SuperMinus[tempidx]},{I mtemp Csc[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]],-Csc[\[Theta]] (mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) \[Sqrt]((ltemp-mtemp) (1+ltemp+mtemp)) SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]])},Row[{"\[FivePointedStar]",Row[{"\[DifferentialD]",Row[{"Y",Column[{mtemp,ltemp}]}]}]}],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1,TensorAssumption-> FSlist],
(VectorType==="Gradient")&&(Head[idx]===SubMinus),NonMetricTensor[{SubMinus[tempidx]},{mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) Sqrt[(ltemp-mtemp) (1+ltemp+mtemp)] SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]],I mtemp SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]},Del[Row[{"Y",Column[{mtemp,ltemp}]}]],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1,TensorAssumption->FSlist],
(VectorType==="Curl")&&(Head[idx]===SubMinus),
NonMetricTensor[{SubMinus[tempidx]},{I mtemp Csc[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]],-Sin[\[Theta]] (mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) \[Sqrt]((ltemp-mtemp) (1+ltemp+mtemp)) SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]])},Row[{"\[FivePointedStar]",Row[{"\[DifferentialD]",Row[{"Y",Column[{mtemp,ltemp}]}]}]}],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1,TensorAssumption-> FSlist]];
(*g=Metric[Subscript[i, -],Subscript[j, -],(\[NoBreak]1	0
0	Sin[\[Theta]]^2

\[NoBreak]),CoordinateSystem\[Rule]{\[Theta],\[Phi]},TensorName\[Rule]"g",StartIndex\[Rule]1];*)result=(((*MoveIndices[*)Which[norm===True,(result/.{(TensorComponents-> comp_):> (TensorComponents->1/Sqrt[l (l+1)]  comp)}),True, result](*,{tempidx//idx\[LeftDoubleBracket]0\[RightDoubleBracket]},g]*)/.{tempidx->idx[[1]] })/.{ltemp-> l,mtemp-> m});
(*Which[!((!IntegerQ[l])&&(!IntegerQ[m])),FSlist={0\[LessEqual] \[Phi]\[LessEqual]2Pi,0\[LessEqual]\[Theta]\[LessEqual]Pi};
Which[!IntegerQ[l],AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[!IntegerQ[m],AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l\[LessEqual]m\[LessEqual]l]];
FS=FullSimplify[#,Evaluate[FSlist]]&;
result=result//FS
];*)
Which[OptionValue[TooltipDisplay]=!=Null,result=TooltipDisplay[result,OptionValue[TooltipDisplay]]];
Which[OptionValue[TooltipStyle]=!={},result=TooltipStyle[result,OptionValue[TooltipStyle]]];
result
]/;(IntegerQ[l]||MatchQ[Head[l],(Symbol|Plus|Times)])&&(IntegerQ[m]||MatchQ[Head[m],(Symbol|Plus|Times)])&&Which[(IntegerQ[l]&&IntegerQ[m]),(l>=0)&&(-l<=m<=l),True,True];

(*VectorSphericalHarmonic[idx_/;(TestIndices[idx]),l_,m_,\[Theta]_Symbol,\[Phi]_Symbol,VectorType_/;MatchQ[VectorType,("Gradient"|"Curl")],opts:OptionsPattern[]]:=Module[{g,i,j,Y,k,result,norm,tempidx,FS,FSlist},
norm=OptionValue[Normalize];
FSlist={0\[LessEqual] \[Phi]\[LessEqual]2Pi,0\[LessEqual]\[Theta]\[LessEqual]Pi};
Which[!IntegerQ[l],AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[!IntegerQ[m],AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l\[LessEqual]m\[LessEqual]l]];
FS=FullSimplify[#,Evaluate[FSlist]]&;
g=Metric[Subscript[i, -],Subscript[j, -],(\[NoBreak]1	0
0	Sin[\[Theta]]^2

\[NoBreak]),CoordinateSystem\[Rule]{\[Theta],\[Phi]},TensorName\[Rule]"g",StartIndex\[Rule]1];
Y=NonMetricTensor[{},SphericalHarmonicY[l,m,\[Theta],\[Phi]],Row[{"Y",Column[{m,l}]}],CoordinateSystem\[Rule]{\[Theta],\[Phi]},StartIndex\[Rule]1];
result=Which[(VectorType==="Gradient"),CovariantD[tempidx^-,Y,g],(VectorType==="Curl"),(Normal[CovariantHodgeDual[tempidx^-,(\!\(
\*SubscriptBox[\(\[DifferentialD]\), 
SubscriptBox[\(k\), \(-\)]]Y\)),g]])];
result=(MoveIndices[Which[norm===True,(result/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule]1/Sqrt[l (l+1)]  comp)}),True, result],{tempidx//idx\[LeftDoubleBracket]0\[RightDoubleBracket]},g]/.{tempidx\[Rule]idx\[LeftDoubleBracket]1\[RightDoubleBracket] })//FS;
Which[OptionValue[TooltipDisplay]=!=Null,result=TooltipDisplay[result,OptionValue[TooltipDisplay]]];
Which[OptionValue[TooltipStyle]=!={},result=TooltipStyle[result,OptionValue[TooltipStyle]]];
result
]/;(IntegerQ[l]||MatchQ[Head[l],(Symbol|Plus|Times)])&&(IntegerQ[m]||MatchQ[Head[m],(Symbol|Plus|Times)])&&Which[(IntegerQ[l]&&IntegerQ[m]),(l\[GreaterEqual]0)&&(-l\[LessEqual]m\[LessEqual]l),True,True];*)
VectorSphericalHarmonic[idx_/;(TestIndices[idx]),l_,m_,g_Tensor/;(TestMetricTensor[g]&&(Dimensions[g]==={2,2})&&TensorIsZero[(g-Ricci[SubMinus[Unique[iiiii]],SubMinus[Unique[jjjjj]],g])//Simplify]),VectorType_/;MatchQ[VectorType,("Gradient"|"Curl")],opts:OptionsPattern[]]:=Module[{coord,result,norm,tempidx,FS,FSlist,\[Theta],\[Phi],ltemp,mtemp},
norm=OptionValue[Normalize];
coord=Coordinates[g];
\[Theta]=coord[[1]];
\[Phi]=coord[[2]];
result=Which[(VectorType==="Gradient"),NonMetricTensor[{SuperMinus[tempidx]},{mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) Sqrt[(ltemp-mtemp) (1+ltemp+mtemp)] SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]],I mtemp Csc[\[Theta]]^2 SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]},Del[Row[{"Y",Column[{mtemp,ltemp}]}]],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1],(VectorType==="Curl"),NonMetricTensor[{SuperMinus[tempidx]},{I mtemp Csc[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]],-Csc[\[Theta]] (mtemp Cot[\[Theta]] SphericalHarmonicY[ltemp,mtemp,\[Theta],\[Phi]]+E^(-I \[Phi]) \[Sqrt]((ltemp-mtemp) (1+ltemp+mtemp)) SphericalHarmonicY[ltemp,1+mtemp,\[Theta],\[Phi]])},Row[{"\[FivePointedStar]","d"[Row[{"Y",Column[{mtemp,ltemp}]}]]}],CoordinateSystem->{\[Theta],\[Phi]},StartIndex->1]];result=((MoveIndices[Which[norm===True,(result/.{(TensorComponents-> comp_):> (TensorComponents->1/Sqrt[l (l+1)]  comp)}),True, result],{tempidx//idx[[0]]},g]/.{tempidx->idx[[1]] })/.{ltemp-> l,mtemp-> m});
Which[!((!IntegerQ[l])&&(!IntegerQ[m])),FSlist={0<= \[Phi]<=2Pi,0<=\[Theta]<=Pi};
Which[!IntegerQ[l],AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[!IntegerQ[m],AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l<=m<=l]];
FS=FullSimplify[#,Evaluate[FSlist]]&;
result=result(*//FS*)
];
Which[OptionValue[TooltipDisplay]=!=Null,result=TooltipDisplay[result,OptionValue[TooltipDisplay]]];
Which[OptionValue[TooltipStyle]=!={},result=TooltipStyle[result,OptionValue[TooltipStyle]]];
result
]/;(IntegerQ[l]||MatchQ[Head[l],(Symbol|Plus|Times)])&&(IntegerQ[m]||MatchQ[Head[m],(Symbol|Plus|Times)])&&Which[(IntegerQ[l]&&IntegerQ[m]),(l>=0)&&(-l<=m<=l),True,True];

(*VectorSphericalHarmonic[idx_/;(TestIndices[idx]),l_,m_,g_Tensor/;(TestMetricTensor[g]&&(Dimensions[g]==={2,2})(*&&TensorIsZero[(g-Ricci[Subscript[Unique[i], -],Subscript[Unique[j], -],g])//Simplify]*)),VectorType_/;MatchQ[VectorType,("Gradient"|"Curl")],opts:OptionsPattern[]]:=Module[{coord,i,j,Y,k,result,norm,tempidx,FS,FSlist},
norm=OptionValue[Normalize];
coord=Coordinates[g];
FSlist={0\[LessEqual] coord\[LeftDoubleBracket]2\[RightDoubleBracket]\[LessEqual]2Pi,0\[LessEqual] coord\[LeftDoubleBracket]1\[RightDoubleBracket]\[LessEqual]Pi};
Which[Head[l]===Symbol,AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[Head[m]===Symbol,AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l\[LessEqual]m\[LessEqual]l]];
FS=FullSimplify[#,Evaluate[FSlist]]&;
Y=NonMetricTensor[{},SphericalHarmonicY[l,m,Sequence@@coord],Row[{"Y",Column[{m,l}]}],CoordinateSystem\[Rule]coord,StartIndex\[Rule]1];
result=Which[(VectorType==="Gradient"),CovariantD[tempidx^-,Y,g],(VectorType==="Curl"),(Normal[CovariantHodgeDual[tempidx^-,(\!\(
\*SubscriptBox[\(\[DifferentialD]\), 
SubscriptBox[\(k\), \(-\)]]Y\)),g]])];
result=(MoveIndices[Which[norm===True,(result/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule]1/Sqrt[l (l+1)]  comp)}),True, result],{tempidx//idx\[LeftDoubleBracket]0\[RightDoubleBracket]},g]/.{tempidx\[Rule]idx\[LeftDoubleBracket]1\[RightDoubleBracket] })//FS;
Which[OptionValue[TooltipDisplay]=!=Null,result=TooltipDisplay[result,OptionValue[TooltipDisplay]]];
Which[OptionValue[TooltipStyle]=!={},result=TooltipStyle[result,OptionValue[TooltipStyle]]];
result
]/;(IntegerQ[l]||MatchQ[Head[l],(Symbol|Plus|Times)])&&(IntegerQ[m]||MatchQ[Head[m],(Symbol|Plus|Times)])&&Which[(IntegerQ[l]&&IntegerQ[m]),(l\[GreaterEqual]0)&&(-l\[LessEqual]m\[LessEqual]l),True,True];*)

(*VectorSphericalHarmonic[idx_/;(TestIndices[idx]&&MatchQ[idx,SuperMinus[_]]),l_,m_,\[Theta]p_Symbol,\[Phi]p_Symbol,VectorType_/;MatchQ[VectorType,("Gradient"|"Curl")],opts:OptionsPattern[]]:=Module[{g,i,j,Y,k,result,norm,tempidx,FS,FSlist,\[Phi],\[Theta]},
norm=OptionValue[Normalize];
FSlist={0\[LessEqual] \[Phi]\[LessEqual]2Pi,0\[LessEqual]\[Theta]\[LessEqual]Pi};
Which[Head[l]===Symbol,AppendTo[FSlist,l\[Element]NonNegativeIntegers]];
Which[Head[m]===Symbol,AppendTo[FSlist,m\[Element]Integers]];
Which[!(IntegerQ[l]&&IntegerQ[m]),AppendTo[FSlist,-l\[LessEqual]m\[LessEqual]l]];
FS=FullSimplify[#,Evaluate[FSlist]]&;
g=Metric[Subscript[i, -],Subscript[j, -],(\[NoBreak]1	0
0	Sin[\[Theta]]^2

\[NoBreak]),CoordinateSystem\[Rule]{\[Theta],\[Phi]},TensorName\[Rule]"g",StartIndex\[Rule]1];
Y=NonMetricTensor[{},SphericalHarmonicY[l,m,\[Theta],\[Phi]],Row[{"Y",Column[{Null,l}],Column[{m,Null}]}],CoordinateSystem\[Rule]{\[Theta],\[Phi]},StartIndex\[Rule]1];
result=Which[(VectorType==="Gradient"),CovariantD[tempidx^-,Y,g],(VectorType==="Curl"),(CovariantHodgeDual[tempidx^-,(\!\(
\*SubscriptBox[\(\[DifferentialD]\), 
SubscriptBox[\(k\), \(-\)]]Y\)),g])];
((Which[norm===True,(result/.{(TensorComponents\[Rule] comp_)\[RuleDelayed] (TensorComponents\[Rule]1/Sqrt[l (l+1)]  comp)}),True, result]/.{tempidx^-\[Rule] idx})//FS)/.{\[Theta]\[Rule]\[Theta]p,\[Phi]\[Rule]\[Phi]p}
]/;(IntegerQ[l]||Head[l]===Symbol)&&(IntegerQ[m]||Head[m]===Symbol)&&Which[(IntegerQ[l]&&IntegerQ[m]),(l\[GreaterEqual]0)&&(-l\[LessEqual]m\[LessEqual]l),True,True];*)


(* ::Input::Initialization:: *)
ElectromagneticStressEnergyTensor[\[Mu]T1_/;TestIndices[\[Mu]T1],\[Mu]T2_/;TestIndices[\[Mu]T2],F_Tensor/;(TensorType[F]==="Faraday"),m_Tensor/;TestMetricTensor[m],opts:OptionsPattern[]]:=Module[{Tup,\[Mu],\[Nu],\[Alpha],\[Beta]},
Tup=RemoveUnderBarredIndices[TensorsProduct[Which[(OptionValue[MetricSignature]==="Mostly minus"), -1, (OptionValue[MetricSignature]==="Mostly plus"), 1] (TensorsProduct[{MoveIndices[F,{SuperMinus[\[Mu]],SuperMinus[\[Alpha]]},m], MoveIndices[F,{SuperMinus[\[Nu]],SubMinus[\[Alpha]]},m]}]-TensorsProduct[{1/4,Metric[SuperMinus[\[Mu]],SuperMinus[\[Nu]],m],MoveIndices[F,{SubMinus[\[Alpha]],SubMinus[\[Beta]]},m], MoveIndices[F,{SuperMinus[\[Alpha]],SuperMinus[\[Beta]]},m]}]),Tensor,TensorName-> "T"]];
MoveIndices[Tup,{\[Mu]T1,\[Mu]T2},m]
];


(* ::Input::Initialization:: *)
MHDSystem[{ph1_,ph2_,ph3_},rho_Function,gBH_Tensor,OptionsPattern[]]/;TestMetricTensor[gBH]:=Module[{MHDRules,\[Rho]0,nT,q123,n,\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Zeta],F\[Mu]\[Nu],F\[Mu]\[Nu]T,LHS1,LHS2,RHS1,RHS2,RHS3,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi]3,x0,x1,x2,x3,si,\[Sigma],\[Rho],\[Alpha],\[Beta],\[Gamma],X,Y,Z,\[Mu],\[Nu],\[Beta]1,\[Gamma]1,q123T,q1,q2,q3,q1T,q2T,q3T,\[Rho]0q123T,\[Rho]0q123,P,PT,divF,divFT,F2,MaxwellT,PlasmaT,coords,Opr,gsgn,TotalT},
(* metric signature converted to sign of eta_00 *)
gsgn=Which[
(OptionValue[MetricSignature]==="Mostly minus"),1,
(OptionValue[MetricSignature]==="Mostly plus"),-1
];
(* gradients of X Y Z *)
coords=Coordinates[UniqueIndices[gBH]];
(* Replacement rules *)
MHDRules={
\[CapitalPhi]1->Function[Evaluate[coords],ph1],
\[CapitalPhi]2->Function[Evaluate[coords],ph2],
\[CapitalPhi]3->Function[Evaluate[coords],ph3],
\[Rho]0->rho};
(* Opr acts on output *)
Opr=OptionValue[MHDOperator];
(*NewCode: ExtractFunctions*)
si=StartIndex[gBH];
q1T[\[Sigma]_]=Tensor[
TensorType->"Gradient",
TensorName ->Del["\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(1\)]\)"],
Indices->{SubMinus[\[Sigma]]},
StartIndex->si,
TensorComponents->((D[\[CapitalPhi]1[Sequence@@coords],#]&/@coords)/.MHDRules),
CoordinateSystem->coords];
q1[\[Rho]_]:=MoveIndices[q1T[\[Alpha]],{\[Rho]},UniqueIndices[gBH]];
q2T[\[Sigma]_]=Tensor[
TensorType->"Gradient",
TensorName ->Del["\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(2\)]\)"],
Indices->{SubMinus[\[Sigma]]},
StartIndex->si,
TensorComponents->((D[\[CapitalPhi]2[Sequence@@coords],#]&/@coords)/.MHDRules),
CoordinateSystem->coords];
q2[\[Rho]_]:=MoveIndices[q2T[\[Sigma]],{\[Rho]},UniqueIndices[gBH]];
q3T[\[Sigma]_]=Tensor[
TensorType->"Gradient",
TensorName ->Del["\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(3\)]\)"],
Indices->{SubMinus[\[Sigma]]},
StartIndex->si,
TensorComponents->((D[\[CapitalPhi]3[Sequence@@coords],#]&/@coords)/.MHDRules),
CoordinateSystem->coords];
q3[\[Rho]_]:=MoveIndices[q3T[\[Sigma]],{\[Rho]},UniqueIndices[gBH]];
(* Maxwell tensor and its divergence *)
F\[Mu]\[Nu]T[\[Sigma]_,\[Rho]_]=Tensor[
TensorType->"Maxwell",
TensorName ->"\!\(\*
StyleBox[\"F\",\nFontSlant->\"Italic\"]\)",
Indices->{SubMinus[\[Sigma]],SubMinus[\[Rho]]},
StartIndex->si,
TensorComponents->Normal[TensorWedge[TensorComponents[q1[SubMinus[\[Alpha]]]],TensorComponents[q2[SubMinus[\[Beta]]]]]],
CoordinateSystem->coords];
F\[Mu]\[Nu][\[Alpha]_,\[Beta]_]:=MoveIndices[F\[Mu]\[Nu]T[\[Sigma],\[Rho]],{\[Alpha],\[Beta]},UniqueIndices[gBH]];
(* maxwell stress tensor *)
F2=TensorContract[TensorProduct[TensorComponents[F\[Mu]\[Nu][SubMinus[\[Alpha]],SubMinus[\[Beta]]]],TensorComponents[F\[Mu]\[Nu][SuperMinus[\[Alpha]],SuperMinus[\[Beta]]]]],{{1,3},{2,4}}];
F2=Opr[gsgn(-TensorContract[TensorProduct[TensorComponents[F\[Mu]\[Nu][SubMinus[\[Alpha]],SubMinus[\[Beta]]]],TensorComponents[F\[Mu]\[Nu][SubMinus[\[Alpha]],SuperMinus[\[Beta]]]]],{{2,4}}]+1/4 TensorComponents[Metric[SubMinus[\[Alpha]],SubMinus[\[Beta]],gBH]]F2)];
MaxwellT[\[Sigma]_,\[Rho]_]=Tensor[
TensorType->"MHDMaxwell",
TensorName ->"\!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[EM]",
Indices->{SubMinus[\[Sigma]],SubMinus[\[Rho]]},
StartIndex->si,
TensorComponents->F2,
CoordinateSystem->coords];
(* dX \[Wedge] dY \[Wedge] dZ *)
q123T[\[Alpha]1_,\[Alpha]2_,\[Alpha]3_]=Tensor[
TensorType->"3-Form",
TensorName ->OverTilde["\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)"],
Indices->{SubMinus[\[Alpha]1],SubMinus[\[Alpha]2],SubMinus[\[Alpha]3]},
StartIndex->si,
TensorComponents->Normal[TensorWedge[TensorComponents[q1[SubMinus[\[Beta]]]],TensorComponents[q2[SubMinus[\[Beta]]]],TensorComponents[q3[SubMinus[\[Beta]]]]]],
CoordinateSystem->coords];
q123[\[Alpha]_,\[Beta]_,\[Gamma]_]:=Module[{\[Mu]1,\[Mu]2,\[Mu]3},MoveIndices[q123T[\[Mu]1,\[Mu]2,\[Mu]3],{\[Alpha],\[Beta],\[Gamma]},UniqueIndices[gBH]]];
(* Plasma current *)
nT[\[Mu]_]=((CovariantHodgeDual[SuperMinus[\[Mu]],q123[SubMinus[\[Alpha]],SubMinus[\[Beta]],SubMinus[\[Gamma]]],UniqueIndices[gBH]]//Opr)/.(TensorName->name_)->(TensorName->"\!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\)"));
n[\[Mu]_]:=MoveIndices[nT[\[Sigma]],{\[Mu]},UniqueIndices[gBH]];
(* Construct P^\[Beta]\[Gamma] in the notes *)
\[Rho]0q123T[\[Alpha]_,\[Beta]_,\[Gamma]_]=Tensor[
TensorType->"3-Form",
TensorName ->"\!\(\*
StyleBox[\"P\",\nFontSlant->\"Italic\"]\)",
Indices->{SuperMinus[\[Alpha]],SuperMinus[\[Beta]],SuperMinus[\[Gamma]]},
StartIndex->si,
TensorComponents->Opr[((gsgn \[Rho]0'[(1/2)gsgn TensorComponents[n[SubMinus[\[Sigma]]]] . TensorComponents[n[SuperMinus[\[Sigma]]]]])/.MHDRules)]TensorComponents[q123[SuperMinus[\[Alpha]1],SuperMinus[\[Beta]1],SuperMinus[\[Gamma]1]]],
CoordinateSystem->coords];
\[Rho]0q123[\[Alpha]_,\[Beta]_,\[Gamma]_]:=MoveIndices[\[Rho]0q123T[\[Alpha]1,\[Alpha]2,\[Alpha]3],{\[Alpha],\[Beta],\[Gamma]},UniqueIndices[gBH]];
PT[\[Beta]_,\[Gamma]_]=Tensor[
TensorType->"2-Form",
TensorName ->"\!\(\*
StyleBox[\"P\",\nFontSlant->\"Italic\"]\)",
Indices->{SuperMinus[\[Beta]],SuperMinus[\[Gamma]]},
StartIndex->si,
TensorComponents->TensorComponents[CovariantD[SubMinus[\[Sigma]],\[Rho]0q123[SuperMinus[\[Sigma]],SuperMinus[\[Beta]1],SuperMinus[\[Gamma]1]],UniqueIndices[gBH]]],
CoordinateSystem->coords];
P[\[Beta]_,\[Gamma]_]:=MoveIndices[Opr[PT[\[Alpha]1,\[Alpha]2]],{\[Beta],\[Gamma]},UniqueIndices[gBH]];
(* perfect fluid stress tensor of plasma *)
F2=Opr[TensorComponents[n[SubMinus[\[Sigma]]]] . TensorComponents[n[SuperMinus[\[Sigma]]]]];
F2=(gsgn TensorComponents[Metric[SuperMinus[\[Alpha]],SuperMinus[\[Beta]],UniqueIndices[gBH]]](\[Rho]0[gsgn F2/2]-\[Rho]0'[gsgn F2/2]gsgn F2)+\[Rho]0'[gsgn F2/2]TensorProduct[TensorComponents[n[SuperMinus[\[Mu]]]],TensorComponents[n[SuperMinus[\[Nu]]]]])/.MHDRules;
PlasmaT[\[Sigma]_,\[Rho]_]=Tensor[
TensorType->"MHDPlasma",
TensorName ->"\!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[Plasma]",
Indices->{SuperMinus[\[Sigma]],SuperMinus[\[Rho]]},
StartIndex->si,
TensorComponents->Opr[F2],
CoordinateSystem->coords];
(* total stress tensor *)
TotalT[\[Sigma]_,\[Rho]_]=Tensor[
TensorType->"MHDMaxwellPlasma",
TensorName ->"\!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)[Total]",
Indices->{SuperMinus[\[Sigma]],SuperMinus[\[Rho]]},
StartIndex->si,
(* remember we defined photon T\[Mu]\[Nu] with both lower indices and plasma with both upper *)
TensorComponents->TensorComponents[RaiseAllIndices[MaxwellT[\[Mu],\[Nu]],UniqueIndices[gBH]]]+TensorComponents[PlasmaT[\[Mu],\[Nu]]],
CoordinateSystem->coords];
(* EM current *)
divFT[\[Mu]_]=Tensor[
TensorType->"MaxwellCurrent",
TensorName ->"\!\(\*
StyleBox[\"J\",\nFontSlant->\"Italic\"]\)",
Indices->{SubMinus[\[Mu]]},
StartIndex->si,
TensorComponents->(TensorComponents[CovariantD[SuperMinus[\[Sigma]],F\[Mu]\[Nu][SubMinus[\[Sigma]],SubMinus[\[Rho]]],UniqueIndices[gBH]]]//Opr),
CoordinateSystem->coords];
divF[\[Rho]_]:=MoveIndices[divFT[\[Alpha]],{\[Rho]},UniqueIndices[gBH]];
(* EOM I : \!\(
\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\[Zeta]\) \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]
\*SuperscriptBox[\(F\), \(\[Mu]\[Sigma]\)]\) = Subscript[q1, \[Alpha]] Subscript[q3, \[Beta]] P^\[Alpha]\[Beta] *)
LHS1=((TensorComponents[q1[SubMinus[\[Sigma]]]] . TensorComponents[divF[SuperMinus[\[Rho]]]])//Opr);
RHS1=Opr[TensorContract[TensorProduct[TensorComponents[q1[SubMinus[\[Sigma]]]],TensorComponents[q3[SubMinus[\[Sigma]]]],TensorComponents[P[SuperMinus[\[Sigma]],SuperMinus[\[Rho]]]]],{{1,3},{2,4}}]];
(* EOM II : \!\(
\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]Y\) \!\(
\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]
\*SuperscriptBox[\(F\), \(\[Mu]\[Sigma]\)]\) = Subscript[q2, \[Alpha]] Subscript[q3, \[Beta]] P^\[Alpha]\[Beta] *)
LHS2=(TensorComponents[q2[SubMinus[\[Sigma]]]] . TensorComponents[divF[SuperMinus[\[Rho]]]])//Opr;
RHS2=Opr[TensorContract[TensorProduct[TensorComponents[q2[SubMinus[\[Sigma]]]],TensorComponents[q3[SubMinus[\[Sigma]]]],TensorComponents[P[SuperMinus[\[Sigma]],SuperMinus[\[Rho]]]]],{{1,3},{2,4}}]];
(* EOM III : 0 = Subscript[q2, \[Alpha]] Subscript[q3, \[Beta]] P^\[Alpha]\[Beta] *)
RHS3=Opr[TensorContract[TensorProduct[TensorComponents[F\[Mu]\[Nu][SubMinus[\[Sigma]],SubMinus[\[Rho]]]],TensorComponents[P[SuperMinus[\[Sigma]],SuperMinus[\[Rho]]]]],{{1,3},{2,4}}]];
(* output *)
MHDSystem[
(* 3 scalars *)
MHDScalarFunction1->ph1,
MHDScalarFunction2->ph2,
MHDScalarFunction3->ph3,
MHD1FormTensor1->(q1T[Unique[\[Sigma]]]),
MHD1FormTensor2->(q2T[Unique[\[Sigma]]]),
MHD1FormTensor3->(q3T[Unique[\[Sigma]]]),
MHD3FormTensor->(q123T[Unique[\[Alpha]1],Unique[\[Alpha]2],Unique[\[Alpha]3]]),
MHDMaxwellTensor->(F\[Mu]\[Nu]T[Unique[\[Sigma]],Unique[\[Rho]]]),
MHDPlasmaCurrentTensor->(nT[Unique[\[Mu]]]),
MHDRank2PTensor->(PT[Unique[\[Beta]],Unique[\[Gamma]]]),
MHDMaxwellCurrentTensor->(divFT[Unique[\[Rho]]]),
MHDEquationsList->({(* eq 1: {LHS,RHS} *){LHS1,RHS1},(* eq 2: {LHS,RHS} *){LHS2,RHS2},(* eq 3: {LHS=0,RHS} *){0,RHS3}}),
(* stress tensors *)
MHDMaxwellStressTensor->(MaxwellT[Unique[\[Sigma]],Unique[\[Rho]]]),
MHDPlasmaStressTensor->(PlasmaT[Unique[\[Sigma]],Unique[\[Rho]]]),
MHDTotalStressTensor->TotalT[Unique[\[Sigma]],Unique[\[Rho]]],
MHDPlasmaEnergyDensityOperator->rho,
(* MHD Lagrangian -\[Rho]0-(1/4)F^2 *)
MHDLagrangianDensity->-(\[Rho]0[(1/2)gsgn (TensorComponents[n[SubMinus[\[Sigma]]]] . TensorComponents[n[SuperMinus[\[Sigma]]]])//Opr]/.MHDRules)-(1/4)TensorContract[TensorProduct[TensorComponents[F\[Mu]\[Nu][SubMinus[Unique[\[Sigma]]],SubMinus[Unique[\[Rho]]]]],TensorComponents[F\[Mu]\[Nu][SuperMinus[Unique[\[Sigma]]],SuperMinus[Unique[\[Rho]]]]]],{{1,3},{2,4}}],
(* store metric info too *)
MHDMetricTensor->UniqueIndices[gBH],
CoordinateSystem->Coordinates[UniqueIndices[gBH]],
MetricSignature->OptionValue[MetricSignature]
]]/;((OptionValue[MetricSignature]==="Mostly minus")||(OptionValue[MetricSignature]==="Mostly plus"));


(* ::Input::Initialization:: *)
(* Appearance of MHDSystem *)
MHDSystem/:Format[MHDSystem[
xxx___,
MHDScalarFunction1->ph1_,
MHDScalarFunction2->ph2_,
MHDScalarFunction3->ph3_,
MetricSignature->ss_,
MHDPlasmaEnergyDensityOperator->rho_,
MHDMetricTensor->ggg_
]]:=Module[{sg},
(* metric signature *)
sg=Which[ss==="Mostly minus","+",ss==="Mostly plus","-"];
MHDSystem[MatrixForm[
{(* {ph1,ph2,ph3,"n^\[Mu]"\[Rule]TensorComponents[nnnT]},
{"Subscript[F, \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[F\[Mu]\[Nu]TT]],"J^\[Mu]"\[Rule]TensorComponents[MaxJTT]},
{"T[EMSubscript[], \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[MaxTT]],"T[PlasmaSubscript[], \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[PlasmaTT]]}, *)
"Ideal MHD/Maxwell's equation 1: \!\(\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\)\!\(\*SuperscriptBox[
StyleBox[\"F\",\nFontSlant->\"Italic\"], \(\[Mu]\[Sigma]\)]\) = \!\(\*SubscriptBox[\(\[Del]\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Beta]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\) \!\(\*SuperscriptBox[
StyleBox[\"P\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\)",
"Ideal MHD/Maxwell's equation 2: \!\(\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Mu]\)]\)\!\(\*SuperscriptBox[
StyleBox[\"F\",\nFontSlant->\"Italic\"], \(\[Mu]\[Sigma]\)]\) = \!\(\*SubscriptBox[\(\[Del]\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\) \!\(\*SubscriptBox[\(\[Del]\), \(\[Beta]\)]\)\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\) \!\(\*SuperscriptBox[
StyleBox[\"P\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\)",
"Ideal MHD/Plasma equation: 0 = \!\(\*SubscriptBox[
StyleBox[\"F\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\) \!\(\*SuperscriptBox[
StyleBox[\"P\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\)",
"With \!\(\*SuperscriptBox[
StyleBox[\"P\",\nFontSlant->\"Italic\"], \(\[Alpha]\[Beta]\)]\) \[Congruent] "<>sg<>"\!\(\*SubscriptBox[\(\[Del]\), \(\[Sigma]\)]\)\!\(\*
StyleBox[\"(\",\nFontSize->16]\)\!\(\*SubscriptBox[\(\[Rho]\), \(0\)]\)["<>sg<>"\!\(\*SuperscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\)/2] \!\(\*SuperscriptBox[\(\[Del]\), \([\[Sigma]\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(1\)]\)\!\(\*SuperscriptBox[\(\[Del]\), \(\[Alpha]\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(2\)]\)\!\(\*SuperscriptBox[\(\[Del]\), \(\(\[Beta]\)\(]\)\)]\)\!\(\*SubscriptBox[\(\[CapitalPhi]\), \(3\)]\)\!\(\*
StyleBox[\")\",\nFontSize->16]\)",
Row[{"Scalar fields : ",MatrixForm[{"\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(1\)]\)"->ph1,"\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(2\)]\)"->ph2,"\!\(\*SuperscriptBox[\(\[CapitalPhi]\), \(3\)]\)"->ph3}]}],
Row[{"Plasma energy density : "," \!\(\*SubscriptBox[\(\[Rho]\), \(0\)]\)["<>sg<>"\!\(\*SuperscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \(2\)]\)/2]"->rho[sg<>"\!\(\*
StyleBox[SuperscriptBox[
StyleBox[\"n\",\nFontSlant->\"Italic\"], \"2\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"/\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"2\",\nFontSlant->\"Italic\"]\)"]}],
{"\!\(\*SubscriptBox[\(g\), \(\[Mu]\[Nu]\)]\)"->MatrixForm[TensorComponents[ggg]],Coordinates->Coordinates[ggg]}}]]];


(* ::Input::Initialization:: *)
(* old code *)
(* MHDSystem/:Format[MHDSystem[
xxx___,
MHDScalar1\[Rule]ph1_,
MHDScalar2\[Rule]ph2_,
MHDScalar3\[Rule]ph3_,
MHDMaxwellTensor\[Rule]F\[Mu]\[Nu]TT_,
MHDMaxwellStressTensor\[Rule]MaxTT_,
MHDMaxwellCurrentTensor\[Rule]MaxJTT_,
MHDPlasmaStressTensor\[Rule]PlasmaTT_,
MHDEquationsList\[Rule]{{l1_,r1_},{l2_,r2_},{0,r3_}},
MHDPlasmaCurrentTensor\[Rule]nnnT_,
MHDMetricTensor\[Rule]ggg_
]]:=MHDSystem[MatrixForm[
{(* {ph1,ph2,ph3,"n^\[Mu]"\[Rule]TensorComponents[nnnT]},
{"Subscript[F, \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[F\[Mu]\[Nu]TT]],"J^\[Mu]"\[Rule]TensorComponents[MaxJTT]},
{"T[EMSubscript[], \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[MaxTT]],"T[PlasmaSubscript[], \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[PlasmaTT]]}, *)
{MatrixForm[{"Ideal MHD/Maxwell's equation 1: Subscript[\[Del], \[Sigma]]\[CapitalPhi]^1 Subscript[\[Del], \[Mu]]F^\[Mu]\[Sigma] = Subscript[\[Del], \[Alpha]]\[CapitalPhi]^1 Subscript[\[Del], \[Beta]]\[CapitalPhi]^3 P^\[Alpha]\[Beta]",l1==r1}]},{MatrixForm[{"Ideal MHD/Maxwell's equation 2: Subscript[\[Del], \[Sigma]]\[CapitalPhi]^2 Subscript[\[Del], \[Mu]]F^\[Mu]\[Sigma] = Subscript[\[Del], \[Alpha]]\[CapitalPhi]^2 Subscript[\[Del], \[Beta]]\[CapitalPhi]^3 P^\[Alpha]\[Beta]",l2==r2}]},
{MatrixForm[{"Ideal MHD/Plasma equation: 0 = Subscript[F, \[Alpha]\[Beta]] P^\[Alpha]\[Beta]",0==r3}]},
{"Subscript[g, \[Mu]\[Nu]]"\[Rule]MatrixForm[TensorComponents[ggg]],Coordinates\[Rule]Coordinates[ggg]}}]]; *)


(* ::Input::Initialization:: *)
(* scalars *)
MHDScalar[1,mm_MHDSystem]:=Module[{xx},Cases[mm,(MHDScalarFunction1->xx_):>xx,\[Infinity]][[1]]];
MHDScalar[2,mm_MHDSystem]:=Module[{xx},Cases[mm,(MHDScalarFunction2->xx_):>xx,\[Infinity]][[1]]];
MHDScalar[3,mm_MHDSystem]:=Module[{xx},Cases[mm,(MHDScalarFunction3->xx_):>xx,\[Infinity]][[1]]];
(* 1-forms/vectors *)
MHDScalar[\[Mu]T_/;TestIndices[\[Mu]T],1,mm_MHDSystem]:=Module[{\[Alpha],xx},MoveIndices[Cases[mm,(MHD1FormTensor1->xx_):>xx,\[Infinity]][[1]],{\[Mu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];
MHDScalar[\[Mu]T_/;TestIndices[\[Mu]T],2,mm_MHDSystem]:=Module[{\[Alpha],xx},MoveIndices[Cases[mm,(MHD1FormTensor2->xx_):>xx,\[Infinity]][[1]],{\[Mu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];
MHDScalar[\[Mu]T_/;TestIndices[\[Mu]T],3,mm_MHDSystem]:=Module[{\[Alpha],xx},MoveIndices[Cases[mm,(MHD1FormTensor3->xx_):>xx,\[Infinity]][[1]],{\[Mu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
MHD3Form[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],\[Gamma]T_/;TestIndices[\[Gamma]T],mm_MHDSystem]:=Module[{\[Alpha],\[Beta],xx},MoveIndices[Cases[mm,(MHD3FormTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T,\[Gamma]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
MHDPlasmaCurrent[\[Mu]T_/;TestIndices[\[Mu]T],mm_MHDSystem]:=Module[{xx},MoveIndices[Cases[mm,(MHDPlasmaCurrentTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
MHDMaxwell[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],mm_MHDSystem]:=Module[{xx},MoveIndices[Cases[mm,(MHDMaxwellTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
MHDMaxwellCurrent[\[Mu]T_/;TestIndices[\[Mu]T],mm_MHDSystem]:=Module[{xx},MoveIndices[Cases[mm,(MHDMaxwellCurrentTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
MHDRank2P[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],mm_MHDSystem]:=Module[{xx},MoveIndices[Cases[mm,(MHDRank2PTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
(* remember we have ordered the eqns from left to right (eq. 1, 2, 3 in Description above) *)
MHDEquations[mm_MHDSystem]:=Module[{xx},(Equal@@#)&/@Cases[mm,(MHDEquationsList->xx_):>xx,\[Infinity]][[1]]];


(* ::Input::Initialization:: *)
MHDEnergyMomentumShearStress[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],ss_String,mm_MHDSystem]/;((ss==="Maxwell")||(ss==="Photons")||(ss==="EM")||(ss==="Electromagnetic")||(ss==="Plasma")||(ss==="Total")):=Module[{xx},
Which[
(ss==="Maxwell")||(ss==="Photons")||(ss==="EM")||(ss==="Electromagnetic"),
		MoveIndices[Cases[mm,(MHDMaxwellStressTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]],
(ss==="Plasma"),
		MoveIndices[Cases[mm,(MHDPlasmaStressTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]],
(ss==="Total"),
		MoveIndices[Cases[mm,(MHDTotalStressTensor->xx_):>xx,\[Infinity]][[1]],{\[Mu]T,\[Nu]T},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]
]];


(* ::Input::Initialization:: *)
(* extract plasma energy density operator from MHDSystem *)
MHDPlasmaEnergyDensity[mm_MHDSystem]:=Module[{xx},Cases[mm,(MHDPlasmaEnergyDensityOperator->xx_):>xx,\[Infinity]][[1]]];


(* ::Input::Initialization:: *)
(* extract metric from MHDSystem *)
MHDMetric[\[Mu]T_/;TestIndices[\[Mu]T],\[Nu]T_/;TestIndices[\[Nu]T],mm_MHDSystem]:=Metric[\[Mu]T,\[Nu]T,Module[{xx},Cases[mm,(MHDMetricTensor->xx_):>xx,\[Infinity]][[1]]]];


(* ::Input::Initialization:: *)
(* extract Lagrangian density from MHDSystem *)
MHDLagrangian[mm_MHDSystem]:=Module[{xx},Cases[mm,(MHDLagrangianDensity->xx_):>xx,\[Infinity]][[1]]];


(* ::Input::Initialization:: *)
(* Protect these symbols so they cannot be altered *)
Protect[Del,SubMinus,SuperMinus,Tensor,TensorType,TensorName,Indices,Metric,Riemann,Weyl,Ricci,RicciScalar,Einstein,CoordinateSystem,Coordinates,TensorComponents,RiemannComponents,RicciComponents,Christoffel,RicciScalarInvariant,ChristoffelComponents,StartIndex,Determinant,MetricDeterminant,TooltipDisplay,ChristoffelOperator,RiemannOperator,RicciOperator,RicciScalarOperator,EinsteinOperator,WeylOperator,CovariantBox,CoordinateTransformation,GradientSquared,(*TensorsProduct,*)CovariantD,PartialD,SwapIndices,UnderBar,TensorIsZero,NonMetricTensor,MoveIndices,LeviCivita,RaiseAllIndices,LowerAllIndices,UniqueIndices,CovariantHodgeDual,GeodesicSystem,GeodesicLagrangians,GeodesicHamiltonianDynamics,AffineParameter,NonAffineParameter,LieDerivative,MHDSystem,MHDScalarFunction1,MHDScalarFunction2,MHDScalarFunction3,MHD1FormTensor1,MHD1FormTensor2,MHD1FormTensor3,MHD3Form,MHDMaxwellTensor,MHDPlasmaCurrentTensor,MHDRank2PTensor,MHDMaxwellCurrent,MHDEquations,MHDEquationsList,MHDMetricTensor,MHDScalar,MHD3Form,MHDPlasmaCurrent,MHDMaxwell,MHDMaxwellCurrent,MHDMaxwellStressTensor,MHDPlasmaStressTensor,MHDRank2P,MHDEnergyMomentumShearStress,MHDMetric,MHDOperator,MetricSignature,MHDTotalStressTensor,MHDLagrangian,MHDLagrangianDensity,MHDPlasmaEnergyDensityOperator,MHDPlasmaEnergyDensity(*NewCode: Protect*),CoordinateTransformationOperator,SymmetrizeIndices,AntiSymmetrizeIndices,SymmetrizeIndicesOperator,AntiSymmetrizeIndicesOperator,ExteriorD,MetricOperator,LieDerivativeOperator,TensorEquations,OrthonormalFrameField,OrthonormalFrameFieldOperator,InverseOrthonormalFrameField,FlatMetric,TestOrthonormalFrameField,OrthonormalFrameFieldIndices,OrthonormalBasis,CoordinateBasis,LieBracket,LieBracketOperator,PotentialForm,ExpressionForm(*,OperatorLinearity*),OperatorProductRule,VectorSphericalHarmonic,SphericalHarmonicYTensor,TensorAssumption,TensorIsZeroOperator,TensorOperator,TensorDivision,TensorDivisionOperator,(*TensorPlus,*)TensorComponentsManipulation,InteriorProduct,\[Iota],\[Sterling],WedgeProductExpand,ToTensorComponents,LT,TensorsProduct,ContractTensors,OperatorNullList,OperatorDistributeOverPlus,OperatorExpansion,OperatorFactorOutScalar,OperatorRemoveSingleComponentList,OperatorThreadThroughFunction,OperatorTensorReturnItself,OperatorExpressionFormReturnItself,OperatorTensorsProduct,OperatorContractThroughFunction,OutputBecomesOneTensor,OperatorThreadThroughTimes];


(* ::Input::Initialization:: *)
End[];
EndPackage[];



